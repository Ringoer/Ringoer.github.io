<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Welcome to No. 68 Floating Island]]></title>
    <url>%2Funcategorized%2Fmainpage%2F</url>
    <content type="text"><![CDATA[Are You Going To Scarborough Fair ?]]></content>
  </entry>
  <entry>
    <title><![CDATA[捕获并分析帧和IP报文]]></title>
    <url>%2Funcategorized%2Fcjtxm9lwd0015vwup8gh9881f%2F</url>
    <content type="text"><![CDATA[计算机网络实验3 实验目的 捕获并分析以太网的帧，获取目标与源网卡的MAC 地址 获取本机地址 获取远端MAC地址 实验环境 Windows 10 C# Visual Studio 2017 实验结果测试时，设置为超过10000Bps就会报警 实验总结 全局初始化 查看网卡信息通过调用ipconfig.exe实现 适配器 计时动作 载入适配器列表 载入适配器信息 开始侦听 收包动作 成帧 成帧时修改流量统计 监视流量 暂停侦听 继续侦听 停止侦听 保存日志 退出程序 技术细节 计算流量的方法构建新结构体（mac + ip +mode）放进dictionary当key，各key累计收发包大小当value。新建线程，每隔1s遍历各来源的收发流量，超过1MB的，可以认为在这1s内平流量达到1MBps以上，故而给本机警告 遍历dictionary因为多线程同时在访问dictionary，所以会出现在一个线程遍历dictionary的时候，另一个线程正在新增dictionary的项。此时采用foreach遍历会报错，因为foreach要求正在遍历的对象不能有变化 有网络但侦听不到包体如果确认程序没错，那么可能是 选错网卡，要注意选一个有网络的网卡 当前的网络收发包类型不是ip and tcp，应该是filter的问题，关掉filter即可 BitConverter会反向获取。如，现有byte[] test={0x01,0x10,0x0f,0xff};二进制为00000001 00010000 00001111 11111111十进制为17829887此时进行uint ans=BitConverter.ToUInt32(test,0);会得到ans= 4279177217十六进制为ff0f1001二进制为11111111 00001111 00010000 00000001可见不能得到想要的结果，因为BitConverter会反向转换所给的byte数组所以应该先将要转换的数组反向，再使用BitConverter]]></content>
  </entry>
  <entry>
    <title><![CDATA[日本語教程索引]]></title>
    <url>%2Funcategorized%2Fcjtxm8pu3000vvwupqb4an321%2F</url>
    <content type="text"><![CDATA[只是想写一个日语教程，为了将来方便给云霄一中日语部教学。于是这里就当成目录吧。待更新]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库系统实验报告-实验1 oracle 11g的安装、配置和使用]]></title>
    <url>%2Fdatabase-experiment%2Fdb-ex1%2F</url>
    <content type="text"><![CDATA[只是一篇实验报告。 实验目的 掌握Oracle 11g Server的安装 掌握Oracle的监听与网络配置 掌握Oracle数据库的启动与关闭 掌握Oracle的交互式开发环境、工具及常用管理操作命令 实验内容/步骤 安装Oracle 11g（服务器版本） 理解安装过程中各选项的含义及作用 了解内置用户的登录和服务器预定义角色 安装完成后以OEM方式登录、管理数据库 创建以自己学号为账号的新用户(S+自己学号)。 对账号做相应授权。 使用网络配置工具进行网络配置 存在的问题及解决方案(列出遇到的问题及其解决办法，列出没有解决的问题) Windows10安装障碍（不满足最低配置）① 提取iso中所有文件② 记事本打开\stage\cvu\cvu_prereq.xml③ 修改如图字段，重点修改6.2以及Windows 10参考链接 Environment Variable: “PATH” 失败① 打开环境变量配置，选择PATH② 先备份PATH，之后删除一部分PATH项，直到不会报错③ 正常安装，结束后恢复原PATH列表参考链接 以OEM方式登录访问localhost:1158/em/console/logon/logon 创建新用户① 打开SQL Plus② 新建数据表空间，语句如下： 123create tablespace dbsp_2 datafile &apos;url\filename.dbf&apos;size 10mextent management local autoallocate; 其中单引号内链接自行指定，注意指定的文件夹应是已创建的，且新建的文件后缀名为.dbf③ 新建用户，语句如下 1create user username identified by password 其中username为用户名，by后面为密钥④ 授权，语句格式如下： 1grant connect,resource,dba to username; 可以是如下形式： 1grant [权限] to [用户名]; 参考链接 配置网络① 运行Net Configuration Assist② 选择“本地网络服务名配置”③ 选择“添加”④ 这一步要求输入你要访问的数据库的“全局数据库名”，“全局数据库名”在安装数据库时指定，默认为name.domain（即：数据库名+数据库域名），当然也可以根据自己喜好随意命名，可以通过select * from global_name;进行查询。*可以直接命名为myorcl⑤ 选择网络语数据库的通信协议，默认TCP即可⑥ 主机名填写127.0.0.1用以访问本地数据库，并选择“使用标准端口号1521”⑦ 选择“是，进行测试”⑧ 默认的测试使用Oracle的Scott用户，因为用户被锁或口令不对，一般情况都会测试不成功，这时候可以通过“更改登录”重新输入数据库的用户/口令来进行测试是否连接成功⑨ 网络服务名，即为该远程连接配置命名。默认即可。至此，如果不需要再配置其他的网络服务，则该网络服务名配置完毕。参考链接]]></content>
      <categories>
        <category>database-experiment</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017へのさよなら]]></title>
    <url>%2Fdiary%2Fend-of-2017%2F</url>
    <content type="text"><![CDATA[2017也算是过去了，聊表感想。 PART1不知不觉2017已经过去了。实话实说，2017年，真是对我来说人生中重要的一年。经历了严酷的高三总复习，参加了大大小小的模拟考试（省质检一竟然还漏题了，笑），直到高考，直到来到XMU，直到……也算是命中注定吧，为了冲XMU经院，放着自招20分不用，报了普通本一批，第一志愿经院，第二志愿软院。但是在FJ，经院收到597分，而我才考了596，因而还是来了软院。若是我当时多考一分，现在又如何呢？ PART2除了正式的学业之外，我还参加了一些可做可不做的事。 云一OI培训 云一日语部 N3考试 等等但是结果？ NOIP2017无人通过初赛 集训学员学习热情忽高忽低 日语部成员竟然因为一个人退部了就热情降到冰点 N3考试尚无结果又有什么事情成功了呢？只是我的一厢情愿吗？ PART3在XMU软院，似乎借着FJTG2=的基础，大有风生水起之势。但lyh，YJQAQ，hiijar，都能在专业水平方面甩我若干条街。我能做些什么？怕是只有学习。即使是学习，也面临我长期以来的问题：听不下课。小学时期，我发现课不难，上课写作业的话回家可以有更多时间玩。于是一发不可收拾，直到高中毕业我都贯彻落实这一点。这直接造成我现在只有在上课时候才能写作业，也只有写作业才能保证清醒，否则我一旦认真听课，立刻睡着。长期以来的习惯，如今被婊了。我曾经也试过改，然后就睡着了，根深蒂固。但是我能怎么办呢？我就想上课睡觉吗？我就不想改吗？ PART412.30去了上海，在浦东赶星尘宝宝的演唱会，然后去松江找同学玩。从松江到外滩，真的蛮久的，用时好像在2小时？结果见到了重度污染的东方明珠，还因为地铁要封站而匆匆赶回。次日早上兜兜转转，虽然中午开心地聚餐了，但是飞机险些来不及，唉，虹桥居然提前20分钟截停，还是高崎15分钟截停好。只有照片，留下了一点回忆。 PART5想起一句名言？也许不算名言。“未来永远在手中，手中抓不住的是过去”。似乎没什么事情的2017，已经抓不住了。 那么，再见。]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++语言-11-竞赛相关的其余操作及编程时应有的良好习惯]]></title>
    <url>%2Fcpp%2Fcpp-11%2F</url>
    <content type="text"><![CDATA[待更新缩进高内聚，低耦合freopeninline]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++语言-10-指针]]></title>
    <url>%2Fcpp%2Fcpp-10%2F</url>
    <content type="text"><![CDATA[待更新地址（分配地址，取地址符号，取值符号）(*p)++*p++结构体指针（->）链表]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++语言-9-结构体与运算符重载]]></title>
    <url>%2Fcpp%2Fcpp-9%2F</url>
    <content type="text"><![CDATA[本章学习结构体与运算符重载。在各路题目中，我们有时候会看到，一个主体有很多个属性。比如你是一个学生，你可以被拆分为以下属性的集合体： 姓名 性别 年龄 年级 班级…… 而且，其余的学生也都是跟你一样有这些属性。那么，我们现在假设一个年级有1000人，难道我们要针对每个属性都开一个1000单位的数组吗？这时候我们就可以使用结构体，把这些属性整合，产生一个新的类型。比如上文中的属性，我们就可以整合为一个student类型。写法如下：123456789101112struct student//struct是必须的，不可更改；后面的student则可以自定义&#123; string name;//用一个名为name的字符串保存姓名 char sex;//假设我们用M和W来表示Man和Woman，那么可以用一个字符型来保存 int age; int grade; int class;//分别用三个int类型变量来保存年龄，年级和班级 void show() &#123; cout&lt;&lt;name&lt;&lt;” ”&lt;&lt;sex&lt;&lt;” ”&lt;&lt;age&lt;&lt;” ”&lt;&lt;grade&lt;&lt;” “&lt;&lt;class&lt;&lt;endl; &#125;//该函数可以输出5个变量&#125;;//注意这里有个分号，不要漏了 通过上文的代码段，我们就建立了一个结构体类型，类型名称为student。其下属有5个变量，我们称之为“成员变量”，又叫“成员表”；还有1个函数，我们称之为“成员函数”。这样，我们就可以总结一个格式：12345struct 类型名称&#123; 成员表 成员函数&#125;; 没有严格的顺序，但一般成员函数写在成员表之后，因为变量/数组等必须先定义才能调用。注意结构体的右大括号后必须有个分号，不要漏掉。 那么，我们如何使用结构体？ 结构体类型，俗称自定义类型。因此，可以效仿其它类型的定义方法。如上文中的student，此时就可以用作数据类型。如，我们称int a;为定义一个名为a的int类型变量。同样的，我们可以student a;来定义一个名为a的student类型变量。 因此，我们可以写出如下代码：12345678910111213#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student&#123; string name; int age;&#125;;int main()&#123; student a,b;//定义两个student类型的变量，分别名为a和b return 0;&#125; 定义student类型的变量也可以写在struct student的右大括号后分号前。写法如下：12345678910111213#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student&#123; string name; int age;&#125;a,b;//定义两个student类型的变量，分别名为a和bint main()&#123; return 0;&#125; 如果采取上述方法定义结构体变量，还可以不写结构体类型的类型名称。如下：12345678910111213#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct&#123; string name; int age;&#125;a,b;//定义两个student类型的变量，分别名为a和bint main()&#123; return 0;&#125; 此时该结构体类型是一次性类型，因为没有填写结构体类型名称，所以不可以被再次使用。 讲完了结构体类型变量的定义，现在我们来讲一下如何访问结构体变量的成员。 假设我们有如下结构体及变量定义：123456789struct student &#123; string name; int age; void show() &#123; cout&lt;&lt;name&lt;&lt;” ”&lt;&lt;age &lt;&lt;endl; &#125; &#125;a; 则我们可以通过“.”，就是跟小数点一样的那个点，来访问结构体变量的成员。示例：123456789101112131415161718#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; void show() &#123; cout&lt;&lt;name&lt;&lt;” ”&lt;&lt;age &lt;&lt;endl; &#125; &#125;a;int main()&#123; cin&gt;&gt;a.name&gt;&gt;a.age;//分别输入student类型变量a的成员变量name和age a.show();//调用student类型变量a的成员函数show return 0;&#125; 如上示例中，我们可以通过“.”来访问结构体变量的成员。此时“.”叫做“成员访问符”。访问到成员变量或成员数组或成员函数的时候，可以如同一般的变量/数组/函数一般使用。 对于结构体类型，我们还可以对其进行运算符重载。如，设有以下结构体类型及变量定义：1234struct complex//complex表示复数&#123; int a,b;//a表示实部，b表示虚部&#125;x,y,z; 关于复数 显然，我们不能直接使用+号来做到z=x+y;只能分别写z.a=x.a+y.a;和z.b=x.b+y.b;这样就显得很繁琐。那么，该如何才能用+号直接操作呢？我们可以在struct complex中进行对于+号的重载，格式如下：1234567891011struct complex//complex表示复数&#123; int a,b;//a表示实部，b表示虚部 friend complex operator +(const complex&amp; p,const complex&amp; q) &#123; complex ans; ans.a=p.a+q.a; ans.b=p.b+q.b; return ans; &#125;&#125;x,y,z; 这样就可以在程序的其余位置，对complex类型的变量使用+号直接操作了。同理，除加号外，“-”，“*”，“/”，“%”也可以采用这样的方式重载，格式为：1234friend 类型名 operator 符号(const 类型名&amp; a,const 类型名&amp; b)&#123; &#125; 以上，是对算术运算符的重载。 再设有以下结构体类型及变量定义：1234struct student&#123; double chinese,math;//用来表示语文成绩和数学成绩&#125;a,b; 这样虽然可以使用==和!=来判断a和b是否相等（所有成员变量的值完全相同与否），但不能直接使用大于号或小于号来判断a和b谁大谁小，因为它不知道要用哪个来判断。所以我们需要重载一下，告诉程序怎么处理。示例：123456789struct student&#123; double chinese,math;//用来表示语文成绩和数学成绩 friend bool operator &gt;(const student&amp; p,const student&amp; q) &#123; if(p.chinese!=q.chinese) return p.chinese&gt;q.chinese; return p.math&gt;q.math; &#125;&#125;a,b; 这样就可以使得大于号能判断a和b的大小（小于号还是不行）：在判断是否a&gt;b时，先判断a的语文成绩是否比b高，若是则a大；若语文成绩相等则判断数学成绩，若a数学成绩较高则a大；数学成绩也相等则a不比b大。同理，可以对其它逻辑符号进行重载，格式为：1234friend bool operator 符号(const 类型名&amp; a,const 类型名&amp; b)&#123; &#125; 以上，是对逻辑运算符的重载。 再设有以下结构体类型及变量定义：12345struct student &#123; string name; int age; &#125;a; 这样我们是不能使用cin和cout直接输入和输出的，需要重载流插入符合流输出符才行。示例：12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt; using namespace std;struct student &#123; string name; int age; friend istream&amp; operator &gt;&gt;(istream&amp; in,student&amp; x) &#123; in&gt;&gt;x.name&gt;&gt;x.age; return in; &#125;//对输入的重载，使得可以使用cin直接输入student类型的变量 friend ostream&amp; operator &lt;&lt;(ostream&amp; out,student&amp; x) &#123; out&lt;&lt;x.name&lt;&lt;" "&lt;&lt;x.age; return out; &#125;//对输出的重载，使得可以使用cout直接输出student类型的变量 //为了符合一般的使用习惯，endl一般不写在对&lt;&lt;的重载中&#125;a;int main()&#123; cin&gt;&gt;a; cout&lt;&lt;a&lt;&lt;endl; return 0;&#125; 以上便是对输入和输出的重载。格式为：对输入重载：12345friend istream&amp; operator &gt;&gt;(istream&amp; in,类型名&amp; x)&#123; in&gt;&gt;变量1&gt;&gt;变量2;//可以更多 return in;&#125; 对输出重载：12345friend ostream&amp; operator &lt;&lt;(ostream&amp; out,类型名&amp; x)&#123; out&lt;&lt;变量1&lt;&lt;” “&lt;&lt;变量2;//可以更多 return out;&#125; 以上，是对输入输出运算符的重载。 还可以对=,(),[],->四种运算符进行重载，但这已经严重超纲，有兴趣的同学可以自行百度一下。 第九章到此结束。]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++语言-8-递归与递推]]></title>
    <url>%2Fcpp%2Fcpp-8%2F</url>
    <content type="text"><![CDATA[本章学习递归/递推相关知识。首先，请大家熟悉对于斐波那契数列第n项的定义。斐波那契数列接下来，我们将借助斐波那契数列来说明递归和递推。 递归在上一章中我们学习了自定义函数，知道可以在主函数中，或其它函数中调用自定义函数。但其实，不止不同函数之间可以相互调用，函数自己也可以调用自己。这个过程称之为递归。递归的示例程序如下：123456789101112131415#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int f(int x)&#123; if(x==1||x==2) return 1; else return f(x-1)+f(x-2);&#125;int main()&#123; int x; cin&gt;&gt;x; cout&lt;&lt;f(x); return 0;&#125; 可以看到，在函数f中又调用了函数f。函数f内部的运行可以解释为下述过程： 判断x是否与1相等或x是否与2相等，若是，则函数返回值为1 若1中的判断失败，则函数返回值为【参数为x-1的函数f的返回值】与【参数为x-2的函数f的返回值】之和。 如x=4，则调用过程如图所示：1234567 f(4) f(3) f(2)f(2) f(1) 11 1 也就是说，函数首先发现要计算f(4)，但此时x=4，不满足x与1相等或x与2相等，所以将f(4)展开为f(3)和f(2)，先计算f(3)和f(2)的值，再相加后，作为f(4)的返回值。接下来根据从左往右执行的规则，函数要计算f(3)。计算f(3)的过程仍然与上述过程类似，展开为f(2)和f(1)后求和。接下来求解由f(3)展开而得到的f(2)，发现符合x与2相等，因此f(2)返回1求解由f(3)展开而得的的f(1)也同理返回1，因此f(3)=1+1=2，返回2现在f(3)求解完成，再求解由f(4)展开的f(2)，得1，所以f(4)=f(3)+f(2)=2+1=3，因此f(4)最终返回值为3。需要注意的是，在使用递归的时候，我们一定要给函数一个边界，让它不会在无限的自调用中迷失。该边界称为递归边界，没有边界的递归将如无限循环一般，必然造成超时。以上就是斐波那契数列的递归过程。但是在实际运行的时候我们发现，当求解斐波那契数列的项数较高的时候会卡在运行中很久，造成超时（TLE）。为什么呢？从上文我们对f(4)的分析就可以看出，f(2)被计算了2次。由此可以推断，当求解f(10)甚至f(100)的时候，会产生大量重复的计算过程，无意义地消耗了时间。此时，我们采用递归求解便不再合理，应该换用递推。 递推在上文中，求斐波那契数列第n项，我们采用的是从f(n)开始，一层层向下展开。而根据斐波那契数列的特点，我们其实可以从第1项开始向上推，直到第n项。代码如下：1234567891011121314#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int x,f[1000]; cin&gt;&gt;x; f[1]=1; f[2]=1; for(int i=3;i&lt;=x;i++) f[i]=f[i-1]+f[i-2]; cout&lt;&lt;f[x]; return 0;&#125; 对于上述代码，求解f[4]的过程就变为如下描述： 已知x==1或x==2时，f[x]=1，所以初始化令f[1]=1,f[2]=1。 因为f[1]和f[2]都已经赋值，所以接下来从f[3]开始计算就可以。枚举f[3]~f[x]的每个单位，根据f[x]=f[x-1]+f[x-2]来求解。此处f[x]=f[x-1]+f[x-2]称为递推式。 求解完成，输出f[x]。可以发现，递推求解是需要数组配合的。与递归不同的是，递推是采用空间换时间的做法，将每次求出来的f[x]保存下来，避免了重复求解，大大节约了时间。以上，就是对递归和递推的基本描述。 第八章到此结束。 本章练习：T17548 斐波那契数列T17551 Pell数列P1028 数的计算P1036 选数P1217 [USACO1.5]回文质数 Prime PalindromesP1706 全排列问题]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++语言-7-函数的自定义与函数的类型]]></title>
    <url>%2Fcpp%2Fcpp-7%2F</url>
    <content type="text"><![CDATA[本章学习函数相关知识。采用以下程序段进行说明：1234567891011121314#include&lt;iostream&gt;using namespace std;int f(double x)&#123; int a=x; return a;&#125;int main()&#123; double a; cin&gt;&gt;a; cout&lt;&lt;f(a); return 0;&#125; 样例输入1：1.1样例输出1：1样例输入2：0.9样例输出2：0 可以看出，我们在公共域（又称全局）里定义了两个函数，一个是int类型的f（自带一个参数，是double类型的x），另一个就是main。main就不多说了，毕竟int main()是强制要求，不能改动。但是这个f就很有意思了。首先，我们学到过在公共域直接int f的话表示定义一个int类型的名为f的变量，但现在为什么是个函数呢？那就是因为f后面的小括号了。那么就有以下定义及使用规范四点。 满足形如【数据类型 名称(参数列表)】的程序段，就是函数。 自定义函数的函数体只能写在公共域或自定义类型内。其中，当自定义函数的函数体写在公共域内时： 若自定义函数的函数体写在main函数之前，则可以不在main函数里写其定义语句，因为其函数体那边就已经定义了。 若自定义函数的函数体写在main函数之后，则必须在main函数里写其定义语句。总之就是必须满足先定义再使用。 只要是函数，就必须使用大括号来告诉程序哪些语句属于这个函数。 小括号里可以放空，也可以不放空，定义若干个参数。 前3点都是很好懂的，主要是这个第4点了。在文章开头的程序段中，我在f后面的空格里定义了一个double类型的x作为f的自带参数（当然也可以定义多个，中间用逗号隔开就行了），在main里定义了一个double类型的a，在f里int了一个a（根据变量的作用域，这个a属于不同的域，是不算重复的）。并且，在输入a之后，我让程序输出了f(a)的值。过程如下： cout检查到要输出f(a)。 按照填写的先后顺序访问填入f后面的括号中的变量所对应的值，并填入对应的位置（这个过程叫传递参数）。在本例中是访问main中a的值，填入f的括号中，使f的double类型的x等于main的double类型的a，并执行f。 进入f，定义一个属于f的int类型的a，使这个a等于x。 使f(x)返回a的值，并且此值重置为int类型。 返回main，输出f(a)此时的值。 关于第2点，举个例子。比如int f(int x,int y,int z)，那么main里如果定义了a，b，c三个变量的话，cout&lt;&lt;f(a,b,c);就是输出当f中的x等于main的a，f中的y等于main的b，f中的z等于main中的c时，f(x,y,z)返回的值。在上述过程中，第二步所提到的那些值里，在main中填入f函数括号内的，称为“实际参数”；而在传递到f函数，开始执行f函数时，f函数中的x称为“形式参数”。 回到本文的例子，在返回f(x)的值之前，程序中经历了以下3次的数据类型转换： 获得double类型的待传递参数的值，转换为被传递参数的double类型，并填入被传递参数。 获得double类型的f里的x的值，转换为int类型的值，并赋值给f里的a。 因为函数f返回f里a的值，所以获得int类型的f里的a的值，转换为int类型的值，并赋值给整个函数f，然后结束f。（如果你这时return 0的话，函数f一定就返回0，那输出也就是0了） 简而言之，在return某个值之前，每个自定义函数都和main一样，可以执行程序语句，不过main以外的其它自定义函数需要被某个正在执行的函数调用就是了。而一旦return某个值，函数就相当于变量，产生一个确定的值，但这个值是一次性的，下次函数再被调用时，依然要重新经过一遍语句的执行来得出一个新的结果。 以上就是函数的自定义了。那么，函数的类型又是什么呢？有的时候，你自定义一个函数，是为了让它执行一段语句，并不是为了让它返回一个值。这时，函数的类型可以都使用int，结尾都写return 0；也可以令函数的类型为void（英文翻译：虚空，此处用作“空类型”之意），结尾不写return 0;需要注意的是，void类型只能用于自定义函数，不可用于main函数，更不可用于一般变量/数组等等。且void类型的函数也可以强制退出，即，使用return;语句。此时return后不能写值，应该直接写分号，当void类型函数在执行中遇到return;时即结束。但是，更多的时候，你是为了让这个自定义函数返回一个值。这时候，函数的类型必须要与你要得到的值相同。如果你想让函数返回一个double类型的值，就必须定义函数为double类型，不可以是float类型，更别说int了。不过，函数后面的括号里的自带参量的类型，就没有特别要求，依你的需要而定。 那么，又是什么时候要使用自定义函数呢？这就涉及到编程时的一个重要思想：高内聚，低耦合。高内聚，就是相同或相似功能的语句块尽可能集中在一起。低耦合，就是功能差异较大的语句块尽可能不要集中在一起。那么，我们就需要用自定义函数，来表示一个功能。这个把功能实现为自定义函数的过程，叫做“封装”。这大概可以理解为，你手里有一件事情，这件事可以分解为几个不同的步骤，不同的步骤可以起到不同的效果（功能）。然后你把这几件事分配给另外的人（自定义函数），让他们替你去做。再结合上文的话，你要告诉他具体步骤怎么做，这就是他的函数体；还要告诉他应该用什么东西来做，这就是他的参数。大概就是这样了。 接下来，如何使用自定义函数呢？在之前的学习中，我们已经使用过诸如pow等数学函数。自定义函数也可以如同数学函数一般调用。如同本文开头的程序段，我们在主函数中输出语句处调用了自定义函数f。自然的，我们也可以在主函数其它区域调用自定义函数。这些地方都属于主函数的函数体。那么我们可以给出总结：可以在任意函数体内的任意合理位置调用任意函数（主函数除外）。比如，我们可以在自定义函数中输出helloworld，如下文代码：1234567891011#include&lt;iostream&gt;using namespace std;void pr()&#123; cout&lt;&lt;"helloworld"&lt;&lt;endl;&#125;int main()&#123; pr(); return 0;&#125; 在上述代码段中，我们定义了一个自定义函数pr。因为它不需要返回值，所以可以使用void类型；又因为它只是用来输出一个字符串常量，所以不需要参数，因此参数列表为空。如上，即是自定义函数的使用方法。 第七章到此结束。]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++语言-6-变量和语句的作用域]]></title>
    <url>%2Fcpp%2Fcpp-6%2F</url>
    <content type="text"><![CDATA[本章学习作用域相关知识。采用以下程序段进行说明：1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int x=1;int main()&#123; int a=1; while(a&lt;10) &#123; int b=3; a++; while(b&lt;5) &#123; int c=2; if(c&gt;=4) break; b++; c+=b; &#125; &#125; return 0;&#125; 先说明一下，a++的效果等于a+=1等于a=a+1，不过a++的执行速度比a=a+1快就是了。同理c+=b是等于c=c+b的。我们可以看到，在本程序段中有4个变量，分别是x，a，b，c，定义的位置各不相同，甚至x是定义在int main()之外的。这是什么意思呢？原来，变量不是定义了之后就通用的，而是有所属范围的。定义在int main外的，不属于任何函数的x，是可以在本程序所有函数中调用的。它定义的位置叫做公共域。而定义在int main里的a，是属于main而不是公共域的。它在main结束时就会清空，不能再访问。也就是说，x可以在程序的任何函数中被访问和修改，而a只能在main里被访问和修改。但是b，c去哪了？我们可以看到，在进入第1个while之后，b才被定义，而c更是定义在第2个while里，且这两个while都属于main，第2个while又属于第1个while。所以，变量b只能在第1个while中被访问和修改，变量c只能在第2个while中被修改。又因为第2个while属于第1个while，所以它能访问和修改变量b，而两个while都属于main，所以能访问和修改变量a。但反过来，不在第1个while里的话，main和其它定义在公共域的函数是不能访问和修改变量b的。同理，不是在第2个while里的话，即使是第1个while里的其它语句，也不能访问和修改变量c。至此，我们能得到一个上下级关系：1234程序本体——main————while——————while 下级可以访问和修改上级中已经定义的变量，而上级不可以访问和修改定义在下级中的变量。根据这套理论，你能猜到第2个while里的break作用范围有多大了吗？就是只能跳出第2个while而已，对第1个while半毛钱影响都没有。continue也是一样的。但是return 0不能乱写，这是特例，所有int类型的函数，比如main，在碰到return 0时会直接结束这个函数自身，跳过下面的所有语句。基于这个特性，也可以用return 0来当程序断点，用来检测当编译成功却运行时错误时哪些语句有问题。当然，不止是return 0，事实上自定义函数和main，碰到return时，不管return是什么都会结束函数。只不过main要求一定要return 0罢了。 第六章到此结束。]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++语言-5-字符型，字符数组与字符串]]></title>
    <url>%2Fcpp%2Fcpp-5%2F</url>
    <content type="text"><![CDATA[本章学习字符相关内容。让我们从介绍字符型（char）开始。 字符型字符型，顾名思义，就是可以保存字符的数据类型，与int、double等保存数字的略有区别。什么区别呢？ 表示上的区别比如我们要表示数字1，则int a=1;即可。而若要表示字符1，则需要char a=&#39;1&#39;;注意到字符1被单引号所围住。这就是表示字符的方法。若写char a=1;则会令a被赋值为一个与字符1毫无关系的符号。 使用上的区别首先声明三个概念：数字、数值、字符。毋庸置疑的是，在计算机内部，不论是数字还是字符，都是转化为数值进行处理的。显然，数字1的数值也是1，以此类推。但是字符1的数值就不是1了，而是49。为什么呢？可以查询一下ASCII码，此处不多解释。常见的字符与其数值：‘0’=48,’1’=49，以此类推‘A’=65,’B’=66，以此类推‘a’=97,’b’=98，以此类推但有时候我们还会经常看到’\n’,’\0’之类的。这些是什么呢？这些叫转义字符。其中，’\0’表示空字符，’\n’表示换行符。*printf(“\n”);与cout&lt;&lt;endl;一致。数值匹配如下：‘\0’=0‘\n’=10查看数值匹配的方法： cout&lt;&lt;int(‘0’);可以查看字符0的ascii码（数值） printf(“%d”,’0’);也可以实现1的效果 cout&lt;&lt;char(48);可以查看数值48对应的字符 printf(“%c”,48);也可以 以上，就是字符型的简单表示。接下来是字符数组。 字符数组在前几章中，我们已经学习了数组的相关知识。那么很显然，字符数组的声明应该满足下述格式：char str[100];本语句声明了一个名为str的char类型数组，有100个单位可供使用。我们知道，对于数组，其内部存储的时候是一个个值连续存储的。那么对于字符数组，因为字符型的值是字符，所以字符数组内部就是一个个字符连续存储的。如将“helloworld”保存在上述字符数组str内，则内部表示为’h’,’e’,’l’,’l’,’o’,’w’,’o’,’r’,’l’,’d’，如同一连串的字符，此时便可称之为字符串。对于字符数组的初始化，除了前述的对于数组的通用初始化方法，还可以使用双引号，也就是用字符串常量直接初始化。如： 采用通用方法：char str[100]={&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;w&#39;,&#39;o&#39;,&#39;r&#39;,&#39;l&#39;,&#39;d&#39;}; 采用双引号：char str[100]=&quot;helloworld&quot;; 注意到采用通用方法时，需要大括号，而采用字符串常量时不需要大括号。 上面我们为str数组开设了100个单位，并且注意到”helloworld”只有10个字符。那么我们可不可以只开10个单位呢？问题可以转化成，以下两种写法可不可行？ 采用通用方法：char str[10]={&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;w&#39;,&#39;o&#39;,&#39;r&#39;,&#39;l&#39;,&#39;d&#39;}; 采用双引号：char str[10]=&quot;helloworld&quot;; 答案是，两种都不可行。 在第一种中，虽然我们显式指定了str数组各个位上的值，但编译时其会在结尾补一个空字符’\0’，导致其最终有11个元素，超出了str数组10个元素的限制，引起访问错误。所以，在使用通用方法进行对字符数组的初始化时，应该预留足够的位置，至少应该是显示指定的字符数+1。 在第二种中，我们直接使用字符串常量来对字符数组进行初始化，依然会有第一种的问题，所以仍然需要多留一位。但要注意的是，第一种引发的是运行时的紊乱，而第二种引发的是编译错误，相比第一种更加容易发现。特殊的，可以采用这样的写法来对字符数组进行初始化：char str[]=&quot;helloworld&quot;;这样的写法可以不指定数组的长度，其内部会自动适配长度。但仅仅在对字符数组使用字符串常量进行初始化时可以不指定数组长度，其它类型/写法均不可以。 *仅在定义的时候可以用字符串常量对其进行赋值，在之后便不再可行，会引发编译错误。后续要操作的话只能按普通数组的方法。 对于二维数组，可以采用下述方法进行初始化：char a[][10]={&quot;hello&quot;,&quot;hi&quot;};第一维可以放空，若填写则不得少于字符串数量。第二维必填，不得少于最长的字符串长度+1。 一般不需要使用更多维的char数组。 在cstring头文件中，提供了下列函数来对字符数组进行操作。基本假设：设有char a[20]=&quot;hello&quot;,b[20]=&quot;hi&quot;; strcpy(目标，来源);此函数为复制函数，能将来源的字符串复制给目标。示例：strcpy(a,b);运行后a数组和b数组都将等于”hi”。 strcat(目标，来源);此函数为拼接函数，能将来源的字符串拼接到目标字符串后面。示例：strcat(a,b);运行后a数组将等于”hellohi”，b数组不变。 strlen(数组名称);此函数可以求出字符串长度（直到’\0’）。示例：strlen(a);求出来的值是”hello”的长度5。因为a数组内部有赋值的部分是’h’,’e’,’l’,’l’,’o’,’\0’，strlen会从下标0开始往后计算直到第一个’\0’之前。*若令a[2]=&#39;\0&#39;，则a数组内部有赋值的部分变为’h’,’e’,’\0’,’l’,’o’,’\0’，将导致strlen所求得的值变为2。*若令a[0]=&#39;\0&#39;，则a数组内部有赋值的部分变为’\0’,’e’,’l’,’l’,’o’,’\0’，将导致strlen所求得的值变为0。 strcmp(数组1名称，数组2名称);此函数可以按字典序比较数组1中的字符串1与数组2中的字符串2的大小。若字符串1大则返回正数，小则返回负数，一样大则返回0。*字典序的比较方法：设有char a[]=&quot;13&quot;,b[]=&quot;120&quot;;字典序是逐位比较的。先比较下标0的位置，发现字符串1和2的该位置都是’1’，则继续比较下标1的位置，发现字符串1的该位置是’3’而字符串2的该位置是’2’，因为’3’&gt;’2’，所以字符串1比字符串2大。再设有char a[]=&quot;12&quot;,b[]=&quot;120&quot;;先比较下标0的位置，发现字符串1和2的该位置都是’1’，则继续比较下标1的位置，发现字符串1和2的该位置都是’2’，则继续比较下标2的位置，发现字符串1的该位置是’\0’而字符串2的该位置是’0’，因为’\0’&lt;’0’，所以字符串1比字符串2小。 以上就是对于字符数组的相关描述。对字符串的了解有没有清晰一些呢？现在开始介绍string类型，也即字符串类型。 字符串类型使用string类型需要包含string头文件。 上面说到，一个一维字符数组可以表示一个字符串。那么对于string类型，该如何表示一个字符串呢？答案是一个变量即可。string在有string头文件的情况下可以如int等类型一般使用。示例：string str=&quot;helloworld&quot;;对于string类型，无需指定字符串长度，其内部会自动适配。且string类型可以在任意时候更改其赋值。如，可以在上述已有定义的情况下，令str=”hi”，则str会变成字符串”hi”。尽管我们上述声明的str仅仅是一个变量，不是数组，但因为它是string类型，所以我们也可以使用下标来访问它内部的字符。如在string str=”helloworld”的基础上，我们可以访问str[4]得到其第五个字符’o’，也可以令str[4]=’r’使得str变为”hellrworld”。 同样的，对于string类型，我们也可以使用数组。如string str[2]={&quot;hi&quot;,&quot;helloworld&quot;};可以通过str[i]来访问在str数组中下标为i的字符串，也可以通过str[i][j]来访问在str数组中下标为i的字符串的下标为j的位置。更多维数组同理。 在string头文件中，提供了下列成员函数来对string类型变量进行操作。基本假设：设有string a=&quot;hello&quot;,b=&quot;hi&quot;;（以下基于与上文中适用于字符数组的函数的对比） a=b;可以直接令a的值等于b的值，使用赋值符号即可。 a=a+b;可以直接令字符串a和字符串b拼接在一起产生一个新的字符串，然后再把这个新的字符串赋值给a。 length();可以求得字符串a的长度（求值方法与strlen一致）。 直接使用运算符进行比较。比较方法仍然是根据字典序（详见上文）。 以上，我们可以显而易见地发现，使用string类型比使用char数组更为方便。故实际使用时，若无特殊要求，一般建议使用string类型。 第五章到此结束。 本章练习：P1055 ISBN号码P1200 [USACO1.1]你的飞碟在这儿Your Ride Is HereP1308 统计单词数P1914 小书童——密码P1553 数字反转（升级版）]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++语言-4-数组]]></title>
    <url>%2Fcpp%2Fcpp-4%2F</url>
    <content type="text"><![CDATA[本章学习数组的定义及使用方式。数组，实际上就是一段连续的存储区间，概念上就是一个变量（元素）的集合。以变量作为例子，每定义一个变量，就相当于为这个变量声明了一个存储空间，用来保存它的值。而当你声明了很多变量时，比如你声明了10个不同变量，那就在内存里占用了10个单位的存储空间。但是，如果你使用数组的话，声明长度为10的数组，也相当于占用了10个单位的存储空间，且是连续的，所以又叫存储区间。语句就是：类型 名称[长度];如：int a[10];其中数组名称的命名要求也与变量一致。设名称为a，长度为n，用一张表格来表示的话，就是下面这样。 a0 a1 a2 … a(n-2) a(n-1) 值1 值2 值3 … 值n-1 值n 这样的一张表格，就表示一个数组。有0~n-1一共n个元素，每个元素对应一个值，并且每个元素都可以完全像变量一样使用。也可以用一个0~n-1的整数坐标轴来表示，每个整数点上有一个值。效果就相当于你定义了a0，a1，a2，…，an-1一共n个变量。简单说，就是： 可以当做变量使用。 是一个有n个不同下标的元素的集合。 如上，这是一维数组。那么二维数组怎么表示呢？int a[n][m];这样就是定义了一个n*m个单位的二维数组。表格形式如下。 a 0 1 2 … m-2 m-1 0 … 1 … 2 … … … n-2 … n-1 … 每个元素属于某一行某一列，设i表示行，j表示列，则当i和j确定时，所对应的元素唯一确定。以此类推，还有三维数组，四维五维……不过常用的就是一维和二维了。 当一个数组定义后，我们可以通过“数组下标”来访问数组内的元素。所谓“数组下标”就是数组后中括号里填的东西。如，假设我们现在有一个定义：int a[100];则我们可以使用a[i]来访问a数组中下标为i的元素，i的范围为0-99。发现了吧？假设数组被定义的长度为n，则可以使用的下标范围就是0~n-1，这正是上文中之所以写a0,a1,…,an-1的原因。这不以编程人员的意志为转移。哪怕你不使用下标为0的位置，它还是在那里，你最大可使用下标还是n-1。所以，设有int a[100];则对于每一个a[i]，都可以像普通变量一样使用。a[i]可以参与运算，也可以在等式左边来接受一个值。如int b=a[1];表示定义一个int类型变量b，并令其等于a数组第二个元素的值。同样的，也可以写a[10]=100;表示令a数组的第十一个元素的值等于100。同理，对于二维数组，可以使用a[i][j]来访问a数组中第i行第j列的元素。两个维度的下标范围各自分离。如有int a[n][m];则在a数组中第一维下标范围为0~n-1，第二维的下标范围为0~m-1。二维数组的a[i][j]，就如同一维数组的a[i]，就如同普通变量，可以参与运算或在等式左边来接受一个值。更多维数组可以以此类推。 但是数组只是定义的话，依然也是如同定义的变量一样，初始是未赋值状态。已知我们可以int a=0;来定义一个int类型的变量a，并对其赋初始值0。那么我们想对数组也进行每个位都赋初始值，该怎么做呢？可以写成如下形式：int a[100]={0};如上语句声明了一个int类型的数组a，有100个单位，将其每个单位都赋值为初始值0。但要注意的是，如果想赋初始值1，这样写是不行的：int a[100]={1};这样将导致只有a[0]的值被初始化为1，其余位仍然都是0。我们称这个1为显式指定的初始值。当使用大括号初始化时，数组会按顺序分配所有显式指定的初始值，而对没有显式指定的其余位置均分配为0。例如，int a[100]={3,1,2,4};这样会按顺序令a[0]=3,a[1]=1,a[2]=2,a[3]=4，之后令其余位置均赋初始值为0。所以，如果想全部初始化为1，则要么手写n个1在大括号里，要么用循环令a[i]=1。而对于多维数组，我们则需要使用嵌套大括号。假设有int a[2][3];则可以以如下方式初始化：1int a[2][3]=&#123;&#123;3,4,5&#125;,&#123;1,2,3&#125;&#125;; 因为数组第一维的容量是2，所以在最外层大括号中嵌套两层大括号，表示分别对第一维的每一行的三列进行初始化。而因为数组第二维容量是3，所以在每个第二级大括号里写3个数。上述声明执行过后，会令a[0][0]=3,a[0][1]=4,a[0][2]=5,a[1][0]=1,a[1][1]=2,a[1][2]=3。但其实写成这样：int a[2][3]={3,4,5,1,2,3};结果也与上述写法相同，只是对于人类来说没有那么直观。为什么会一样呢？因为数组内部在分配顺序的时候，是从最后一维开始分配的，比如有三维数组a[2][2][2]，则顺序是a[0][0][0],a[0][0][1],a[0][1][0],a[0][1][1],a[1][0][0],a[1][0][1],a[1][1][0],a[1][1][1]。可见，顺序的规则是恒定不变的，需要的是程序员来调整初始化数值的顺序。需要注意的是，如果不采用嵌套大括号，则必然是按顺序初始化。而采用嵌套大括号的话，可以按需求针对不同维度进行初始化。示例如下：假设有二维数组:int a[4][4];则我可以写:1int a[4][4]=&#123;&#123;0,1,1&#125;,&#123;1,2&#125;,&#123;3,1,4,5&#125;,&#123;6&#125;&#125;; 进行初始化。初始化的结果为：1234a[0][0]=0,a[0][1]=1,a[0][2]=1a[1][0]=1,a[1][1]=2a[2][0]=3,a[2][1]=1,a[2][2]=4,a[2][3]=5a[3][0]=6 其余单位因为没有显式指定而均为0。 第四章到此结束。 本章练习：P1046 陶陶摘苹果P1427 小鱼的数字游戏P1428 小鱼比可爱P1567 统计天数P1047 校门外的树P2141 珠心算测验]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++语言-3-循环语句及选择语句]]></title>
    <url>%2Fcpp%2Fcpp-3%2F</url>
    <content type="text"><![CDATA[本章学习循环结构和选择结构的基本用法。 循环语句while语句while语句实现”当型”循环，它的一般格式为：1234while (判断条件)&#123; 循环体&#125; 1、当判断条件成立时，循环执行大括号中语句。并且初始化部分和迭代部分是任选的。2、while语句首先检查判断条件，当条件满足时，才去执行循环中的语句。这是”当型”循环的特点。 do-while语句do-while语句实现”直到型”循环，它的一般格式为：1234do&#123; 循环体&#125;while (判断条件); 1、do-while语句首先执行循环体，然后检查判断条件，若成立，则循环执行大括号中的语句，直到判断条件不成立。2、与while语句不同的是，do-while语句的循环体至少执行一次，是”直到型”循环的特点。 for语句for语句也用来实现”当型”循环，它的一般格式为：1234for (初始化操作;判断条件;迭代部分)&#123; 循环体&#125; 1、for语句执行时，首先执行初始化操作，然后检查判断条件是否满足，如果满足，则执行循环体中的语句，最后执行迭代部分。完成一次循环后，重新判断终止条件。2、可以在for语句的初始化部分声明一个变量，它的作用域为一个for语句。3、for语句通常用来执行循环次数确定的情况(如对数组元素进行操作)，也可以根据循环结束条件执行循环次数不确定的情况。4、在初始化部分和迭代部分可以使用逗号语句，来进行多个动作。逗号语句是用逗号分隔的语句序列。例如：1234for(i=0,j=10;i&lt;j;i++,j--)&#123; 循环体&#125; 5、初始化、终止以及迭代部分都可以为空语句，且只要判断条件为空，就相当于一个无限循环，如：1234for(i=0;;i++)&#123; 循环体&#125; 循环语句的控制1、break跳出当前所在循环，忽略break以下的所有语句。2、continue直接执行下一次循环，忽略continue以下的所有语句。 条件语句if-else语句一般格式为：12345678if(判断条件)&#123; 语句1&#125;else&#123; 语句2&#125; 当判断条件成立时，执行语句1，否则执行语句2。 switch语句一般格式为：123456789101112switch(变量)&#123;case 值1: 语句1; break;case 值2: 语句2; break;default: 语句3; break;&#125; 当变量为值1时执行语句1，当为值2时执行语句2，当不为已给出的任何情况时执行default的语句3。case可以无限添加，不只限2个。需要注意的是，当你没有break时，会一直向下执行。如以下程序段，若变量为值1，则语句1,2,3都将被执行。12345678910switch(变量)&#123;case 值1: 语句1;case 值2: 语句2;default: 语句3; break;&#125; 逻辑判断符号小于：&lt; 大于：&gt; 等于：==（两个等号） 小于等于：&lt;= 大于等于：&gt;= 不等于：!=特别的，计算时用的等于只有一个等号，判断时才用两个等号。逻辑联结符号且：&amp;&amp; 或：||或的符号由两个竖线组成，竖线可以由回车上方的那个键打出。如：1234if(((x&gt;1||x&lt;-1)&amp;&amp;y&gt;2)||(x&lt;-9&amp;&amp;y&gt;0))&#123; sum=sum+1;&#125; 这样表示当满足以下两种情况之一时，sum的值+1。① x大于1且y大于2，或x小于-1且y大于2时。② x小于-9且y大于0时。特别的，使用if(条件1||条件2)的时候，如果条件1成立，则不会判断条件2是否成立，直接进入if的语句块。上述两种符号也属于运算符。使用逻辑符号时的要点*不可以写连等式，如：如果x大于0小于100，不可以写if(0&lt;x&lt;100)，必须拆开，写成if(0&lt;x&amp;&amp;x&lt;100)。其余逻辑符号同理。 第三章到此结束。 本章练习：选择语句：P1422 小玉家的电费P1085 不高兴的津津P1089 津津的储蓄计划P1909 买铅笔T16594 小明的四则运算 循环语句：P1008 三连击P1035 级数求和P1423 小玉在游泳P1424 小鱼的航程(改进版)P1980 计数问题T17068 有多少平方数T17072 是质数吗？T17073 什么？！n！T17071 四个数的2nd问题]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++语言-2-数据类型与输入输出]]></title>
    <url>%2Fcpp%2Fcpp-2%2F</url>
    <content type="text"><![CDATA[本章将学习基本数据类型与输入输出的方法。首先，请大家先熟悉下面的计算指定的a+b的和并输出的代码。1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b; c=a+b; cout&lt;&lt;c; system("pause"); return 0;&#125; 样例输入：2 3样例输出：5在前一篇中讲过的部分就不再赘述，直接从第五行开始讲起。 第五行：int a,b,c;定义三个变量，分别叫做a,b,c，返回int类型（整型），句末要有分号。可以在定义里赋值，如int a=1,b=1,c=1;。int后面要有一个空格。 常用数据类型：short有符号（即表示有正负，下同）短整型，范围-32768~32767（-2^15~2^15-1），只支持整数。unsigned short无符号短整型，范围0~65535（2^16-1），只支持整数。int有符号整型，范围-2147483648~2147483647（-2^31~2^31-1），只支持整数。unsigned int无符号整型，范围0～4294967295（2^32-1），只支持整数。long long有符号长整型，范围-9223372036854775808~9223372036854775807（-2^63~2^63-1），只支持整数。unsigned long long无符号长整型，范围0~18446744073709551615（2^64-1），只支持整数。float单精度，支持小数，有效数字约8位，范围-3.40(10的38次方)~3.40(10的38次方)。double双精度，支持小数，有效数字约16位，范围-1.79(10的308次方)~1.79(10的308次方)。char有符号字符型，不支持字符串，范围-128~127。unsigned char无符号字符型，不支持字符串，范围0~255。string字符串，在第五章中有具体说明。bool布尔型，范围true或false，即非0或0。*当遇见有的程序只写一个unsigned时，默认是unsigned int。*在没有特殊强调时，整数类型一般用int，超过int的范围时可以使用long long或unsigned long long，别的一般不常用；浮点数类型一般用double，少用float。 标识符：上文中提到的变量，就是标识符的一种。对于所有的标识符，均需要满足如下名称要求： 只能是字母或下划线开头，严格区分大小写。 不可以包含数字或字母或下划线以外的其余符号。 不可以是系统正在使用的名称。如在linux系统中time是一个系统变量，则不可以使用time作为变量名称。 变量定义的写法： 定义一个int类型的变量a，写作int a; 定义一个long long类型的变量a，写作long long a; 定义一个float类型的变量a，写作float a; 定义一个double类型的变量a，写作double a; 定义一个char类型的变量a，写作char a; 定义一个string类型的变量a，写作string a; *string在编程环境中不会变色，但仍是可用类型。*要使用string类型，需要#include&lt;string&gt;。*string的具体用法在第五章中有具体说明。*定义里可以直接赋值，如int a=123;*定义里一句可以写多个变量，如int a,b,c;*如在定义时直接对变量赋值，需要对每个想赋值的变量都赋值。&ensp;如：int a,b=1;则a是未赋值变量，b被赋值为1&ensp;再如：int a=2,b=1;则a被赋值为2，b被赋值为1 第六行：cin&gt;&gt;a&gt;&gt;b;按顺序输入一个变量a和一个变量b。cin包含在iostream中。句末有分号。*每输入一个变量都需要写两个&gt;符号（该符号是半角大于号），箭头指向要输入的变量。*cin和cout会自动识别输入/输出的值的类型，无需特意说明。*若是使用cstdio头文件的话，需要写成scanf(“%d%d”,&amp;a,&amp;b);句末有分号，在变量前需加&amp;这个符号，相邻变量以逗号隔开。&quot;%d&quot;的意思是按整型来操作，有两个变量所以写两个%d。*scanf会比cin快一些，在输入量很大（大于10万个数据）时建议使用scanf。printf同理。 对于scanf和printf，其均满足以下写法：scanf(格式说明字符串,操作数);printf(格式说明字符串,操作数);其中，scanf和printf均可以只写格式说明字符串而不写操作数。当且仅当格式说明字符串中出现格式说明符（又叫占位符）时，才填写操作数。并且，scanf和cin一样，均会自动跳过回车，且在格式说明符不为%c和%s时均会跳过空格。 示例：仅格式说明字符串：scanf(&quot;a=b=&quot;);当输入是a=b=时可以正常执行printf(&quot;a=b=&quot;);输出字符串a=b=仅占位符：scanf(&quot;%d%d&quot;,&amp;a,&amp;b);当输入仅有两个数字时可以正常执行，按格式说明符%d来操作变量a和bprintf(&quot;%d&quot;,c);按格式说明符%d来操作变量c混用：scanf(&quot;a=%d,b=%d&quot;,&amp;a,&amp;b);当输入格式满足例如a=1,b=2时（就连逗号也不能漏掉），输入取得值1和2，分别赋值给a和bprintf(&quot;c=%d&quot;,c);将会原样输出c=，之后将变量c的值按格式说明符%d操作后，输出值 又如，本文开头的代码段可以转化为如下代码段，样例也可转化为对应样例：1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,c; scanf(“a=%d,b=%d”,&amp;a,&amp;b); c=a+b; printf(“c=%d”,c); system("pause"); return 0;&#125; 样例输入：a=2,b=3样例输出：c=5 注意到上文中，scanf的操作数前有加”&amp;”符号，而printf的操作数前没有。关于&amp;，将会在第十章中说明。 附，常见格式说明符：%d，表示按int类型处理%lld，表示按long long类型处理%ull，表示按unsigned long long类型处理%c，表示按char类型处理%s，表示按char数组来进行处理（关于数组，后续章节会讲到）%f，表示按float类型处理%lf，表示按double类型处理（因为double本质上是long float，所以其格式操作符取long float的缩写）上述格式操作符均会跳过空格和换行符。也就是说，在使用cin、或在scanf中使用上述格式操作符时，输入的不同值可以使用空格或换行符隔开。 关于格式操作符的特殊操作（以下仅1可以适用于scanf，其余均仅适用于printf）：1、按照指定宽度保留数字的方法：如对int类型保留4个数字的位宽，格式操作符可选用%4d*当数字的实际宽度大于要保留的位宽时，按照原宽度输出。所以若是%0d，就是按原宽度输出*当数字的实际宽度小于要保留的位宽时，将数字右对齐，并在左边补空格填充2、保留指定位数的小数（直接舍去，并不四舍五入）的方法：如对double类型保留两位小数，格式操作符可选用%0.2lf对其中0的说明，参加第1条；而小数点后的2，就表示保留两位小数此种情况下，0可以省略，如%0.2lf与%.2lf等效*内部操作是先计算保留小数，再计算保留位宽*对于小数，小数点也占一个位宽，所以如对于2.15使用格式说明符%4.1lf的话，会因为先计算保留1位小数而变为2.1，此时位宽为3。再因为保留4个位宽，而在2.1前补一个空格后输出3、可以使用0来代替空格进行填充（填充后需符合保留小数位数的要求，以及不能改变原数字大小）：如对于int类型数字100，使用格式操作符%4d，本来是在左边填充一个空格，如果改用格式操作符%04d的话，就会变成在左边填充一个0，这样执行printf(&quot;%04d&quot;,100);就会输出01004、可以使用-来实现左对齐如对于int类型数字100，使用格式操作符%-4d，就会在100右边填充一个空格后输出但如果使用格式操作符%-04d，并不会在右边填充一个0，因为这样会改变100原本的值，所以输出会是100和一个空格 综上，如果想对一个double类型的变量a，保留5位位宽，保留1位小数，用0填充空位，实现左对齐的话，可以写成：printf(&quot;%-05.1lf&quot;,a); 第七行：c=a+b;本句的执行过程是，先计算a+b的值，再赋值给c。本语句称之为赋值语句。赋值语句的等号左边必须是一个可以被赋值的对象。其中，对于+号，=号，我们均称之为运算符。常见运算符有：+,-,*,\，分别表示加减乘除=，表示赋值，先计算等式右边的值，再赋值给左边的对象%，表示取模，功能类似于取余数。如int a=100%7;最终c的值将等于100除以7的余数2+=，表示自加运算。如i+=2，表示i=i+2。其它的-=，*=，/=，%=同理++，表示自加1运算。如i++，表示i=i+1。三个或更多加号则不成立，只有两个+号的++可以表示自加运算。*特别的，++有前置和后置两种写法，如i++和++i，最终都会导致i=i+1。*当i++或++i单独存在时，它们并无区别。但当它们处于赋值语句中时，会引发差别。i++是先取得i的值，再自加；++i是先自加，再取得i的值。如，现在有int i=1,a;然后令a=i++，则先取得i的值1，赋值给a，然后i再自加，i变成2，所以执行完后a=1，i=2。相对的，如现在有int i=1,a;然后令a=++i，则i先自加，i变成2，再取得i的值2，赋值给a，所以执行完后a=,2，i=2。–与++同理。只有加减有这种写法，别的没有。 第二章到此结束。感谢PTW对本文的援助。 本章练习：P1001 A+B ProblemP1421 小玉买文具P1425 小鱼的游泳时间]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++语言-1-入门篇]]></title>
    <url>%2Fcpp%2Fcpp-1%2F</url>
    <content type="text"><![CDATA[本章用以给新手入门。首先，请大家先熟悉下面的，输出一串字符”helloworld”的代码。12345678#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;”helloworld”&lt;&lt;endl; return 0;&#125;//这是一句注释 该代码编译运行后，显示的结果如下面这一行： helloworld现在开始逐行解释。1、#include&lt;iostream&gt;，这句的意思是程序中包含一个叫做iostream的头文件，格式是#include&lt;&gt;，头文件名称填在单书名号中。单书名号结尾不需要加分号。需要包含多个头文件时换行写即可。例：#include&lt;iostream&gt;#include&lt;cstdio&gt;也有用双引号的，如#include&quot;cstdio&quot;，虽然这样也可以，不过建议写单书名号。区别在于双引号的是查找自己编写的类库（头文件），而单书名号是查找编译环境自带的类库。常用头文件有：iostream，这个单词由in/out stream组成，是标准输入输出流。cstdio，这个单词由c++ standard in/out组成，是标准输入输出。cmath，这个单词由c++ math组成，是数学库。cstring，这个单词由c++ string组成，是与字符处理有关的头文件。string，这个单词本身就存在，翻译名为“字符串”，使用string类型时需要包含该头文件。algorithm，这个单词本身就存在，翻译名为“算法”，主要包含一些现成的函数。有时候也会见到如”stdio.h”的头文件，这是C语言的头文件，不用管。请大家按C++写法写头文件。2、using namespace std;这句话，称为“使用(using)命名空间(namespace)std”，其中namespace就是“姓名”和“空间”两个单词的组合，称为“命名空间”。而std是standard的缩写，表示“标准的”。这句话写在所有include之后，不可修改。这是硬性规定，不做赘述。句末要有分号。不论包含多少头文件，都只需写一次。3、int main()main()表示主函数，括号不可丢，句末无分号。前面的int表示main函数返回int类型。这句其实也是硬性规定。4、左大括号，与第8行的右大括号匹配，构成一个封闭区域，表示main函数的函数体。大括号是函数的界限，表示这一组大括号里面的所有内容都属于这个函数。括号是一一匹配的，不会重复匹配，且每个左大括号只会匹配到离自己最近的且未被匹配的右大括号。5、cout&lt;&lt;&quot;helloworld&quot;&lt;&lt;endl;输出一个句子并换行。表示输出的是”cout”，是c++ out的缩写。要使用cout，需要包含iostream头文件。这个“句子”的专业表述为“字符串”，因为每个句子实际上都是由一串字符构成的。输出时，在输出的内容中没有双引号。endl是end line的缩写，表示一个换行符。所谓的换行符，就是通常意义上的回车。在输出换行符后，字符串末尾将如同被按下一个回车，光标会来到下一行。*每输出一个变量都需要写两个单书名号，箭头指向cout。&ensp;如cout&lt;&lt;a&lt;&lt;b&lt;&lt;c;//按先后顺序输出三个变量a，b，c。*直接按此方法输出时三个变量会连在一起，如a=1，b=2，c=3时，输入为123，这时需要手动添加空格作为分隔符，代码更改为cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c;输出变更为1 2 3。*cout支持两种换行符，endl和”\n”，如cout&lt;&lt;endl;或cout&lt;&lt;&quot;\n&quot;;都可以做到换行。*endl中是小写的L，而不是数字1。 既然cout是输出，相对的，就有输入。表示输出的是”cin”，是c++ in的缩写。要使用cin，需要包含iostream头文件。cin的用法，将在下一篇章中说明。6、return 0;表示正常结束程序。主函数的最后必须有这一句话，句末有分号，写在主函数中时不可改动。不论写在主函数的何处，只要程序执行时遇到这句话，都将使得程序正常结束。7、右大括号，与第4行的左大括号匹配，构成一个封闭区域，表示main函数的函数体。大括号是函数的界限，表示这一组大括号里面的所有内容都属于这个函数。括号是一一匹配的，不会重复匹配，且每个右大括号只会匹配到离自己最近的且未被匹配的左大括号。8、两个除号，//，表示注释，程序将会忽视在//之后的这一行的所有内容如果需要多行注释，可以选择/*内容*/的方式，程序将会忽略/*和*/之间的所有内容。示例：这里还没被忽略//这句会被忽略 这句也没被忽略 1234/*我们这几行全都被忽略了*/ 以上，就是对于本篇开头的代码段的完整解释。至此，可以总结出一个C++程序的基本框架。写程序时可以先打好该框架，然后再继续填充。框架如下：1234567#include&lt;iostream&gt;using namespace std;int main()&#123; return 0;&#125; 到此，第一章结束！感谢PTW对本文的援助。]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fothers%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这篇文章是Hexo自带的文章，有兴趣的各位可以浏览。Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
</search>
