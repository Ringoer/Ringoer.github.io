<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Welcome to No. 68 Floating Island]]></title>
    <url>%2Funcategorized%2Fmainpage%2F</url>
    <content type="text"><![CDATA[Are You Going To Scarborough Fair ?]]></content>
  </entry>
  <entry>
    <title><![CDATA[20190908 Keras试用]]></title>
    <url>%2FKeras%2F20190908%2F</url>
    <content type="text"><![CDATA[尝试了二元线性回归。只有代码和注释。12345678910111213141516171819202122232425262728import kerasfrom keras.models import Sequentialfrom keras.layers import Denseimport numpy as np#期望平面z=-6x+y+8trX = np.random.uniform(-100, 100, size=1001)trY = np.random.uniform(-100, 100, size=1001)trZ = 8 - 6 * trX + trY + np.random.randn(*trX.shape) * 0.2trXY = np.array(list(zip(trX,trY)))model = Sequential()#模型实现输入[x,y]，输出对应的z，属于2个输入决定一个输出，所以#第一层Dense的input_dim=2#最后一层Dense的output_dim=1model.add(Dense(input_dim=2, output_dim=200, init='uniform', activation='linear'))model.add(Dense(input_dim=200, output_dim=1, init='uniform', activation='linear'))model.compile(optimizer='adam', loss='mse')model.fit(trXY, trZ, nb_epoch=200, verbose=1)testX = [3,4,0]testY = [1,0,4]testXY = np.array(list(zip(testX,testY)))res = model.predict(testXY)print(testXY)print(res) 关于zip()方法设有123&gt;&gt;&gt; a=[1,4,7]&gt;&gt;&gt; b=[2,5,8]&gt;&gt;&gt; c=[3,6,9] 则有以下结果：12345678&gt;&gt;&gt; d=zip(a,b,c)&gt;&gt;&gt; d&lt;zip object at 0x0000019C55381848&gt;&gt;&gt;&gt; list(d)[(1, 2, 3), (4, 5, 6), (7, 8, 9)]&gt;&gt;&gt; d=[list(i) for i in zip(a,b,c)]&gt;&gt;&gt; d[[1, 2, 3], [4, 5, 6], [7, 8, 9]] 可见zip()方法的参数列表是可变参数列表，可以传入n个参数]]></content>
      <categories>
        <category>Keras</category>
      </categories>
      <tags>
        <tag>Keras</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190907 Keras试用]]></title>
    <url>%2FKeras%2F20190907%2F</url>
    <content type="text"><![CDATA[第一次入门TensorFlow，然后先搞搞Keras。装环境：1pip install tensorflow 没有合适版本的话，检查一下自己的pip是不是最新版的，python是32位还是64位。 入门代码：线性回归12345678910111213141516171819202122232425262728293031323334353637383940import kerasfrom keras.models import Sequentialfrom keras.layers import Denseimport numpy as np#生成训练集#trX和trY表示训练用的1000个点二维坐标的x和y，类型是nparray#trX中，有1000组数据，每组数据只有1个元素，所以下文中Dense的input_dim=1trX = np.random.uniform(-100, 100, size=1000) #生成1000个在-100~100之间的随机数，返回一个nparraytrY = 5 * trX + 6 + np.random.randn(*trX.shape) * 0.2 #期望y=5x+6，并加入一点点随机波动#实例化model为层次模型model = Sequential()#为模型添加layer#本示例是RNN，所以使用Dense作为layer#前一个Dense的output_dim必须和后一个的input_dim相同#第一个Dense的input_dim必须等于训练集输入的每组元素数#最后一个的output_dim必须等于训练集输出输出的每组元素数model.add(Dense(input_dim=1, output_dim=200, init='uniform', activation='linear'))model.add(Dense(input_dim=200, output_dim=1, init='uniform', activation='linear'))#编译模型，准备训练#optimizer是优化器，一般选adam#loss是损失函数，一般使用mse（均方误差）即可#loss越小，说明训练效果越好，但要小心过拟合model.compile(optimizer='adam', loss='mse')#训练#trX处填写训练集输入，trY处填写训练集输出#nb_epoch是迭代次数，verbose=1表示在控制台输出每次epoch的信息model.fit(trX, trY, nb_epoch=200, verbose=1)#np.array()要求传入一个list，返回一个nparray#arr.tolist()要求arr是一个nparray，返回一个list#model.predict要求传入一个nparrayl = np.array([3,1,-5,-23,-42,52]) #测试集res = model.predict(l) #结果print(l)print(res)]]></content>
      <categories>
        <category>Keras</category>
      </categories>
      <tags>
        <tag>Keras</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190715 Python学习随录]]></title>
    <url>%2Fpython%2Fpython-20190715%2F</url>
    <content type="text"><![CDATA[学习随录系列功能：实现对一个由若干行组成、每行均为[0.xxx, 0.xxx, …]格式的json文件的裁剪 README 在同一目录下新建一个input.txt，其中存放需要转换的文件名。！仅文件名，无后缀名，无路径 在该目录下放置同名的json文件 在该目录启动cmd，运行该py文件 本代码只注重效率，未考虑文件读取失败的问题，故请确保有合法输入文件 代码：1234567891011121314151617181920212223242526272829303132333435363738394041import sysimport ionumbers = [2,3,5] #只保留numbers[i]的整数倍行with open('input.txt', 'rb') as input_file: #读取文件名 files = input_file.read().decode('utf-8').split('\r') #读取.解码.分割 for filename in files: #遍历 if filename == '\n' or filename == '\r': break #防止空行异常跳出 if filename[0] == '\n': filename = filename[1:] #防止前导换行符 if filename[len(filename)-1] == '\n': filename = filename[:len(filename)-1] #防止后置换行符 infile = filename + '.' + 'json' #构造输入文件名 for n in numbers: #遍历切割依据 outfile = filename + '-' + str(n) + '.' + 'json' #构造输出文件名 with open(infile, 'rb') as fr: #打开输入文件 file_str = fr.read().decode('utf-8').split('[') #读取.解码.分割 with open(outfile, 'wb') as fw: #打开输出文件 ans = file_str[0] + '[' #预置 i = n + 1 #取数 while i &lt; len(file_str): #取所需行 ans += '[' + file_str[i] #构造输出文件 i += n if ans[len(ans)-1] != '&#125;': #防止异常结束 i = len(ans) - 1 while ans[i] != ',': i -= 1 ans = ans[:i] + ']&#125;' fw.write(ans.encode('utf-8')) #写文件]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[千鈴めい视频合集]]></title>
    <url>%2Fvtuber%2Fchisuzumei%2F</url>
    <content type="text"><![CDATA[千鈴めい视频合集仅下载链接 #00 打招呼【千铃鸣】千铃要初次直播了哦【千铃鸣】0416初配信节选 夜明けと蛍【千铃鸣】【熟肉】来决定问候语吧！【神回/熟肉】【千铃鸣】试着召唤古守了（事故联动回+迫害帕里妈妈千铃鸣直播生肉合集【千铃鸣】休息是大事哦【神回/熟肉】我家千铃是极道大小姐【千铃鸣】音酱解剖【千铃鸣】【新OP ED注意】イェイ！イェイ！イェイ！【手书/千铃鸣】祝·收益化—千铃鸣来了哦！【千铃鸣】和有栖mana酱双龙联动【千铃鸣】收益化庆祝回【千铃鸣】介绍下我家的执事【千铃鸣】猫又少女的奥数魔刃【千铃鸣】在寻找古守的家时发现meruto酱【千铃鸣】和吉他打好关系吧！【千铃鸣】QWOP Part 1【CCさくら】CLEAR_千鈴めい【歌ってみた】【千铃鸣】最终配信]]></content>
      <categories>
        <category>vtuber</category>
      </categories>
      <tags>
        <tag>vtuber</tag>
        <tag>chisuzumei</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 WinPCAP 监听并解析 FTP 口令]]></title>
    <url>%2Fnetwork-experiment%2FWinPCAP-FTP%2F</url>
    <content type="text"><![CDATA[计算机网络实验4 实验目的用 WinPCAP 监听并分析 FTP 协议并记录 IP、用户名、密码和登陆是否成功。 实验环境Windows10C# 实验结果 wireshark部分 连接 本机向ftp服务器申请连接，flag=SYN ftp服务器回复本机，flag=SYN，ACK 本机收到，向ftp服务器答复，flag=ACK ftp服务器收到，向本机发送数据，flag=PSH，ACK 断开 本机向ftp服务器申请断开，flag=FIN，ACK ftp服务器收到申请，向本机返信，flag=ACK ftp服务器已经断开与本机的连接，向本机发信，flag=FIN，ACK 本机收到，断开与ftp服务器连接，向ftp服务器返信，flag=ACK 监听部分 实验总结大部分与实验三相同。以下解释不同的部分。 全局变量用FTPmode来表示现在处于解析ftp口令的哪个阶段。取值范围为{“”,”NOW”,”END”}用MyDiary数组来保存一整次解析中，生成日志所需的数据。用MyXML来保存一整次解析中，生成XML文档所需的数据 收包动作当一整次FTP口令解析完成时，生成日志和XML 在get_frame函数中录入生成日志所需的信息，然后读取用户信息 按照COMMAND获取口令 保存停止侦听时询问保存]]></content>
      <categories>
        <category>network-experiment</category>
      </categories>
      <tags>
        <tag>计算机网络实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日本語動詞変化式]]></title>
    <url>%2FJapanese%2Fdoushihenkashiki%2F</url>
    <content type="text"><![CDATA[本文为动词变形备查表格。 在本文，以及本博客的整个日语教程中，都有以下全局设定： 五段活用动词的动词原形是去掉ます的部分示例：思（おも）います中，认为 思い 是动词原形 一段活用动词的动词原形是去掉ます的部分示例：食（た）べます中，认为 食べ 是动词原形 サ変動詞的动词原形是去掉します的部分示例：散歩（さんぽ）します中，认为 散步 是动词原形 对于カ変動詞，因为 来 这个汉字有不同发音，故另做处理 注意，此处认为的动词原形，和动词连用形略有区别。 五段活用动词对于あ行来说，对应あ段的变形，本来应该变为あ，但其实不是，应该变为わ。以下用到的单词： 单词 意思 買（か）います 购买 書（か）きます 写 脱（ぬ）ぎます 脱 立（た）ちます 站立 話（はな）します 说话 呼（よ）びます 称为、呼喊 死（し）にます 死亡 読（よ）みます 读 売（う）ります 卖 变形方式 敬体形就是ます形。 连用形与动词原形相同。 简体形将动词原形结尾的假名，变更为其对应う段。示例：死にます，原形部分结尾的假名是に，对应う段是ぬ，所以死にます的简体形是死ぬ。 可能形将动词原形结尾的假名，变更为其对应え段，再加ます/る。新词变形与一段活用动词相同。示例：死にます，原形部分结尾的假名是に，对应え段是ね，所以死にます的可能形是死ねます/死ねる。 使役态将动词原形结尾的假名，变更为其对应あ段，再加せ，再加ます/る。新词变形与一段活用动词相同。示例：死にます，原形部分结尾的假名是に，对应あ段是な，所以死にます的使役态是死なせます/死なせる。 被动态将动词原形结尾的假名，变更为其对应あ段，再加れ，再加ます/る。新词变形与一段活用动词相同。示例：死にます，原形部分结尾的假名是に，对应あ段是な，所以死にます的使役态是死なれます/死なれる。 使役被动态将动词原形结尾的假名，变更为其对应あ段，再加され，再加ます/る。新词变形与一段活用动词相同。示例：死にます，原形部分结尾的假名是に，对应あ段是な，所以死にます的使役态是死なされます/死なされる。 假定形将动词原形结尾的假名，变更为其对应え段，再加ば。示例：死にます，原形部分结尾的假名是に，对应え段是ね，所以死にます的假定形是死ねば。 命令形将动词原形结尾的假名，变更为其对应え段。示例：死にます，原形部分结尾的假名是に，对应え段是ね，所以死にます的假定形是死ね。 意志形将动词原形结尾的假名，变更为其对应お段，再加う。示例：死にます，原形部分结尾的假名是に，对应お段是の，所以死にます的假定形是死のう。 ない形将动词原形结尾的假名，变更为其对应あ段，再加ない。新词变形与イ形容词相同。示例：死にます，原形部分结尾的假名是に，对应あ段是な，所以死にます的ない形是死なない。 动词て形根据动词原形结尾假名不同，分为以下5种情况： き结尾，将き变为いて ぎ结尾，将ぎ变为いで ち、り、い结尾，结尾假名变为って び、み、に结尾，结尾假名变为んで し结尾，结尾假名变为して*特别的，行く的て形是行って 动词た形将て形中的て变为た、で变为だ即可 变形表格除第一列为敬体形参照，假定形、命令形、意志形、ない形、て形、た形均采用其原样，其它列均采用简体形表示。*五段活用动词在变为可能形、使役态、被动态、使役被动态时，可适用一段活用动词的敬体形、简体形变形方式。 敬体形 書きます 脱ぎます 立ちます 売ります 買います 呼びます 読みます 死にます 話します 连用形 書き 脱ぎ 立ち 売り 買い 呼び 読み 死に 話し 简体形 書く 脱ぐ 立つ 売る 買う 呼ぶ 読む 死ぬ 話す 可能形 書ける 脱げる 立てる 売れる 買える 呼べる 読める 死ねる 話せる 使役态 書かせる 脱がせる 立たせる 売らせる 買わせる 呼ばせる 読ませる 死なせる 話させる 被动态 書かれる 脱がれる 立たれる 売られる 買われる 呼ばれる 読まれる 死なれる 話される 使役被动态 書かされる 脱がされる 立たされる 売らされる 買わされる 呼ばされる 読まされる 死なされる 話さされる 假定形 書けば 脱げば 立てば 売れば 買えば 呼べば 読めば 死ねば 話せば 命令形 書け 脱げ 立て 売れ 買え 呼べ 読め 死ね 話せ 意志形 書こう 脱ごう 立とう 売ろう 買おう 呼ぼう 読もう 死のう 話そう ない形 書かない 脱がない 立たない 売らない 買わない 呼ばない 読まない 死なない 話さない て形 書いて 脱いで 立って 売って 買って 呼んで 読んで 死んで 話して た形 書いた 脱いだ 立った 売った 買った 呼んだ 読んだ 死んだ 話した 时态、语气表格此处只给出简体形部分，敬体形参看本链接 以「死にます」为例 时态 语气 表达 一般现在时 肯定式 死ぬ 一般现在时 否定式 死なない（ない形） 一般过去时 肯定式 死んだ（た形） 一般过去时 否定式 死ななかった（ない形，按イ形容词变化而成的过去式） 一段活用动词以下用到的单词：食（た）べます，吃 变形方式 敬体形就是ます形。 连用形与动词原形相同。 简体形动词原形+る。 可能形动词原形+られ，再加ます/る。新词变形与一段活用动词相同。 使役态动词原形+させ，再加ます/る。新词变形与一段活用动词相同。 被动态动词原形+られ，再加ます/る。新词变形与一段活用动词相同。 使役被动态动词原形+させられ，再加ます/る。新词变形与一段活用动词相同。 假定形动词原形+れば。 命令形动词原形+ろ。 意志形动词原形+よう。 ない形动词原形+ない。 动词て形动词原形+て。 动词た形动词原形+た。 变形表格 敬体形 食べます 连用形 食べ 简体形 食べる 可能形 食べられる 使役态 食べさせる 被动态 食べられる 使役被动态 食べさせられる 假定形 食べれば 命令形 食べろ 意志形 食べよう ない形 食べない て形 食べて た形 食べた 时态、语气表格此处只给出简体形部分，敬体形参看本链接 时态 语气 表达 一般现在时 肯定式 食べる 一般现在时 否定式 食べない（ない形） 一般过去时 肯定式 食べた（た形） 一般过去时 否定式 食べなかった（ない形，按イ形容词变化而成的过去式） サ変動詞以下用到的单词：散歩（さんぽ）します，散步 变形方式 敬体形就是ます形。 连用形动词原形+し。 简体形动词原形+する。 可能形动词原形+でき，再加ます/る。新词变形与一段活用动词相同。 使役态动词原形+させ，再加ます/る。新词变形与一段活用动词相同。 被动态动词原形+され，再加ます/る。新词变形与一段活用动词相同。 使役被动态动词原形+させられ，再加ます/る。新词变形与一段活用动词相同。 假定形动词原形+すれば。 命令形动词原形+しろ。 意志形动词原形+しよう。 ない形动词原形+しない。 动词て形动词原形+して。 动词た形动词原形+した。 变形表格 敬体形 散歩します 连用形 散歩し 简体形 散歩する 可能形 散歩できる 使役态 散歩させる 被动态 散歩される 使役被动态 散歩させられる 假定形 散歩すれば 命令形 散歩しろ 意志形 散歩しよう ない形 散歩しない て形 散歩して た形 散歩した 时态、语气表格此处只给出简体形部分，敬体形参看本链接 时态 语气 表达 一般现在时 肯定式 散歩する 一般现在时 否定式 散歩しない（ない形） 一般过去时 肯定式 散歩した（た形） 一般过去时 否定式 散歩しなかった（ない形，按イ形容词变化而成的过去式） カ変動詞カ変動詞只有一个，就是：来（き）ます，来且几乎每种变形都有一个读音，需要牢记。 变形方式 敬体形来（き）ます 连用形来（き） 简体形来（く）る 可能形来（こ）られ，再加ます/る。新词变形与一段活用动词相同。 使役态来（こ）させ，再加ます/る。新词变形与一段活用动词相同。 被动态来（こ）られ，再加ます/る。新词变形与一段活用动词相同。 使役被动态来（こ）させられ，再加ます/る。新词变形与一段活用动词相同。 假定形来（く）れば 命令形来（こ）い 意志形来（こ）よう ない形来（こ）ない 动词て形来（き）て 动词た形来（き）た 变形表格 敬体形 きます 连用形 き 简体形 くる 可能形 こられる 使役态 こさせる 被动态 こられる 使役被动态 こさせられる 假定形 くれば 命令形 こい 意志形 こよう ない形 こない て形 きて た形 きた 时态、语气表格此处只给出简体形部分，敬体形参看本链接 时态 语气 表达 一般现在时 肯定式 くる 一般现在时 否定式 こない（ない形） 一般过去时 肯定式 きた（た形） 一般过去时 否定式 こなかった（ない形，按イ形容词变化而成的过去式）]]></content>
      <categories>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>日语教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语入门向基本文法]]></title>
    <url>%2FJapanese%2Fkihonbunpou%2F</url>
    <content type="text"><![CDATA[日语入门向基本文法 词性名词太简单，此处只说明疑问词。 何翻译为：什么单字读作なに。在句子中时，根据以下规则有变： “何”后面的助词是が、ま、か行的助词时，读なに “何”后面的助词是な、だ、た行的助词时，读なん 不符合1、2时，读なに 誰（だれ） 翻译为：谁 何時（なんじ）翻译为：什么时候一般指精确到时分秒程度的时间 何処（どこ）翻译为：哪里 いつ翻译为：什么时候一般指精确到年月日程度的时间 助词 は常用于提示主语复合句中主句主语用は做助词时读wa が常用于提示主语复合句中从句主语用が を常用于有动词的句子中，形式为【宾语（名词）】を【动词】表示对【宾语】进行【动词】所表示的动作做助词时读o へ常用于有移动目标的句子中，形式为【目的地】へ【（表示移动的）动词】表示向着【目的地】进行【动词】所表示的动作此处【（表示移动的）动词】一般需要是能表示”从A到B”这样的感觉的动词做助词时读e の常用于表示从属关系，形式为【名词1】の【名词2】表示【名词2】是属于【名词1】的类别的一般有两种用法： 生徒会長（せいとかいちょう）の彼（かれ）译作”身为学生会长的他”此时，表示”他”属于”学生会长”这个类别，具有”学生会长”这个属性 彼のもの译作”他的东西”此时，表示”东西”属于”他”这个类别，即为”属于他的东西”此时，の译作”的” と常用于： 连接两个名词，形式为【名词1】や【名词2】此时连接而成的这个短语可以作为某个句子中的主语组分或宾语组分等翻译为：和 在特定语法中充当连接成分，如：小句 + と思（おも）います此时不译 や常用于连接两个名词，形式为【名词1】や【名词2】连接而成的这个短语可以作为某个句子中的主语组分或宾语组分等此时翻译为：或 も常用于替代は或が前接名词此时翻译为：也 に并不基本，以后提到再学习 で并不基本，以后提到再学习 语气词语气词一般放在句尾。常见语气词如下： よ～哟有以下作用： 表示主张、叮嘱、或引起对方注意。例：あなたが行かなくても、私は行くよ。 表示怀疑，责难的语气。例：なぜ、ぼくに教えてくれなかったんだよ。 表示命令，请求，接在动词和动词活用形助动词的命令形后面，或接在表示禁止和命令的な后面，一般是男性用语。例：遅くなるから、早く行けよ。 表示劝诱，恳求，接在助动词“う，よう”后面。例：さあ、遅れないように早く行こうよ。 ね～呢有以下作用： 表示轻微的感叹。例：やあ、ずいぶんきれいな部屋だね。 いいお天気だね。 表示轻微的主张或叮嘱的心情。例：あの人はきっと成功すると思いますね。 征求同意，或希望对方确认，促使对方回答。例：もう一度行きましょうね。 表示疑问，责问。男性用语。例：私にはよく読めないが、ここになんと書いてあるね。 よね是「よ」和「ね」的复合性终助词。有以下作用： 要求对方同意自己的观点 表明自己同意对方的观点 わ主要是女性使用，语调偏高，男性也有用的，但要降调。有以下作用： 表示强调，用来调整或加强语气。例：私はこれが好きだわ。 あそこに田中さんがいるわ。用わよ、わね的形式，前者强调自己的主张，后者希望别人赞成或证实自己的看法。例：今度の旅行には、私も行くわよ。 あの花、本当にきれいだわね。 表示惊奇，感叹的语气。例：まあ、きれいだわ。 雨がまた降り出しましたわ。 の主要是女性和儿童使用。 表示断定，语气较亲密。读降调。例：とてもいやなの。 今おなかがいっぱいなので、何も食べたくないの。 表示叮嘱的语气，常用のね的形式。例：きっと引き受けてくれるのね。 明日は必ず来てくれるのね。待ってますよ。 表示命令，语气较强，发音要重。例：ご飯は黙って食べるの。 表示质问，疑问。读升调。例：きれいな着物を着て、どこへ行くの。 ぞ一般由男性使用，表示一种强调和肯定的判断，有一种大男子主义的语气。 な表示说话人再次确认自己的感情等。一般是男性使用。 ぜ用于说话人单方面向听话人传达语句的内容。想要改变听话人对某事情认识的意图并不强。一般是男性使用。 さ表示说话人并非对所作的判断负责，而是作为理所当然的事情或暂且的判断表示提示。一般是男性使用。 かな是「か」和「な」的复合性终助词，后面一般接「思う」之类的动词。一般是男性使用。 かしらかな的女性版。 动词五段活用动词/一类动词五段活用，指因为该动词的动词原形结尾有五种情况，所以有五种变形 き ぎ ち、り、い び、み、に し无特殊说明的情况下，符合上述形态的动词都是五段活用动词 一段活用动词/二类动词与五段活用相对，一段活用，指该动词不论动词原形结尾是什么形态，都只有一种变形无特殊说明的情况下，不是五段活用动词或サ変动词、カ変动词的动词，就是一段活用动词 サ変动词、カ変动词/三类动词 サ変动词无特殊说明的情况下，符合”名词+します”的动词就是サ変动词因为这类动词的变形集中在对后面的”します”进行变形，而不管怎么变，这一部分的第一个假名都是さ行的，所以称之为サ変动词 カ変动词只有一个单词，就是来（き）ます因为这个单词的几种变形中，汉字”来”虽然读音不尽相同，但都属于か行，所以称之为カ変动词 形容词イ形容词无特殊说明的情况下，以い结尾的形容词就是イ形容词 ナ形容词/形容动词无特殊说明的情况下，不以い结尾的形容词就是ナ形容词因为该类形容词在使用时通常要加上な，所以称之为ナ形容词 副词一般副词主要有三种： 天生就是副词，如ごろごろ：无所事事 イ形容词中，结尾的い变为く ナ形容词+に 敬体形、简体形敬体形一般陈述句 时态 语气 表达 一般现在时 肯定式 です 一般现在时 否定式 ではありません（此处は读wa） 一般过去时 肯定式 でした 一般过去时 否定式 ではありませんでした 一般动词句 时态 语气 表达 一般现在时 肯定式 ます 一般现在时 否定式 ません 一般过去时 肯定式 ました 一般过去时 否定式 ませんでした 一般形容词句イ形容词与一般陈述句相同 ナ形容词与一般陈述句相同 简体形一般陈述句 时态 语气 表达 一般现在时 肯定式 だ 一般现在时 否定式 ではない（此处は读wa） 一般现在时 否定式 じゃない（ではない的口语化） 一般过去时 肯定式 だった 一般过去时 否定式 ではなかった 一般过去时 否定式 じゃなかった 一般动词句参看本链接 一般形容词句イ形容词イ形容词的变形体现在对于单词结尾的い的变形 时态 语气 表达 一般现在时 肯定式 ～い 一般现在时 否定式 ～くない 一般过去时 肯定式 ～かった 一般过去时 否定式 ～くなかった ナ形容词与一般陈述句相同 句型一般陈述句 【名词1】は【名词2】です。【名词1】是【名词2】其中【名词1】是已知的，【名词2】是新引入的。示例：それはリンゴです。那是苹果。（先看到那里有个物件，然后才认出是苹果） 【名词1】が【名词2】です。【名词1】是【名词2】其中【名词2】是已知的，【名词1】是新引入的。示例：それがリンゴです。那是苹果。（先知道有苹果这么一个东西，然后四下张望，看到一个物件） です的变形默认的です表达一般现在时，有以下变形。对于每个变形，若无特殊说明，使用时直接替换です即可。 一般疑问句直接在小句后加か即可，结尾用句号。也可直接问号，但此时有惊叹的效果，故而一般不用。示例：それはリンゴですか。那是苹果吗？ 有疑问词的句子，发问时只能使用以下句式。【疑问词】が【名词】ですか不能用は 一般存在句 有主观意识的存在【名词】が【地点】にいます。示例：猫がそこにいます地点成分在句子中可以提前，如：そこに猫がいます 没有主观意识的存在【名词】が【地点】にあります。示例：花がそこにあります地点成分在句子中可以提前，如：そこに花があります 区别有生命的存在，不一定有主观意识。如动物有意识，植物没有。没有生命的存在，则一定没有意识。 います和あります的变形います和あります均为动词。います的简体形为いる，其它变形与一段活用动词相同。あります的简体形为ある，其它变形与五段活用动词相同。 一般动词句【主语】は【宾语】を【动词】ます表示【主语】对【宾语】做出了【动词】所表示的动作。 一般形容词句イ形容词 【名词】は【イ形容词】です表示【名词】是【イ形容词】的。示例：彼女は美しいです她是美丽的 【名词】が【イ形容词】です表示【名词】是【イ形容词】的。此处的【イ形容词】是【名词】的固有属性。示例：太陽が丸いです太阳是圆的 ナ形容词 【名词】は【ナ形容词】です表示【名词】是【ナ形容词】的。示例：その山は有名です那座山是有名的 【名词】が【ナ形容词】です表示【名词】是【ナ形容词】的。此处的【ナ形容词】是【名词】的固有属性。示例：その花がきれいです那朵花是漂亮的 惯用句以下句子中，小括号表示对读音的注释。若无小括号，则按一般规则处理。 句子 意思 备注 こんにちは(wa) 你好 常用于白天 こんばんは(wa) 晚上好 おはようございます 早上好 おはよう 早上好 是上一句的缩写 ありがとうございます 谢谢 ありがとう 谢谢 是上一句的缩写 すみません 对不起 较正式 すいません 对不起 是上一句的口语形式 ごめんなさい 对不起 较随意，常用于熟人 ごめん 对不起 是上一句的缩写 申(もう)し訳(わけ)ございません 对不起 最为郑重的说法 更多句子待更新…]]></content>
      <categories>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>日语教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉明码]]></title>
    <url>%2Fencoding%2FHammingCode%2F</url>
    <content type="text"><![CDATA[汉明码编码方式详解 确定位数已知有n位信息码，k位校验码，则在汉明码的构造规则中，应满足：2^k&gt;=n+k+1其中k位校验码应至少有n+k种状态，用来表达n+k位的错误，还有1位用来表示整个代码正确无误。故通常有下表。 n k（最小） 1 2 2~4 3 5~11 4 12~26 5 27~57 6 58~120 7 … … 构造序列设n+k位序列每一位编号分别为1,2,3,…,n+k，k位汉明码分别为C1、C2、C4、…、C2^(k-1)，则对于任意i(1&lt;=i&lt;=k)，C2^(i-1)应放在序列中第i号位置上。示例：现有n=4的信息码，由上表可得k=3，则n+k位序列编号为1~7，k位汉明码编号为C1、C2、C4。同时，设信息码的4位分别为b4、b3、b2、b1，则有下表序列。 二进制序号 1 2 3 4 5 6 7 名称 C1 C2 b4 C4 b3 b2 b1 以此类推。此时，对于任意i(1&lt;=i&lt;=k)，C2^(i-1)负责检测的范围为[i+m*i*2，i*2-1+m*i*2]，m&gt;=0且m为整数以上表为例，则有：C1负责检测1,3,5,7位C2负责检测2,3,6,7位C4负责检测4,5,6,7位 奇偶校验设C2^(i-1)负责检测t位，若为偶校验，则这t位相加，所得结果应为偶数，即二进制为最后一位为0；若为奇校验，则这t位相加，所得结果应为奇数，即二进制位最后一位为1。以上表为例，则有：第1,3,5,7位相加为偶数，C1在第1位，所以C1=(第3位+第5位+第7位)的和取二进制最后一位，简写为C1=3位 + 5位 + 7位，即C1=b4 + b3 + b1第2,3,6,7位相加为偶数，C2在第2位，所以C2=3位 + 6位 + 7位，即C2=b4 + b2 + b1第4,5,6,7位相加为偶数，C4在第4位，所以C4=5位 + 6位 + 7位，即C4=b3 + b2 + b1 若设信息码为0101，采用偶校验，则C1=0+1+1=0C2=0+0+1=1C4=1+0+1=0所以信息码0101对应的汉明码为0100101 纠错过程前面说到，对于任意i(1&lt;=i&lt;=k)，C2^(i-1)负责检测的范围为[i+m*i*2，i*2-1+m*i*2]，m&gt;=0且m为整数。则收信一方只需要按该规则重新计算即可。于是，设对于任意i(1&lt;=i&lt;=k)，已知C2^(i-1)负责检测t位，则有P2^(i-1)=∑这t位（包括C2^(i-1)所在位）。接上例，则有：P4=4位 + 5位 + 6位 + 7位P2=2位 + 3位 + 6位 + 7位P1=1位 + 3位 + 5位 + 7位若全0，则表示信息完全正确 若此时设收到的码字为0100111，则通过计算，得：P4=0+1+1+1=1P2=1+0+1+1=1P1=0+0+1+1=0说明C1负责的分组没错，C2和C4负责的分组有错。经检查发现，只有计算结果110对应第110位（也就是第6位）有错。此时计算机会直接修改第110位，于是完成纠错。 又若正确码字为0100101，收到码字为1100101，则通过计算，得：P4=0+1+0+1=0P2=1+0+0+1=0P1=1+0+1+1=1此时P4P2P1=001，所以第1位出错，应该修改第1位。但因为第1位是C1所在地，是校验位，对信息码没有影响，故一般不纠正此处错误。 以上，就是汉明码的工作过程。]]></content>
      <categories>
        <category>encoding</category>
      </categories>
      <tags>
        <tag>汉明码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语入门向基本单词]]></title>
    <url>%2FJapanese%2Fkihontango%2F</url>
    <content type="text"><![CDATA[日语入门向基本单词 人称我 单词 通常适用范围 私（わたし） 共通 俺（おれ） 男性 僕（ぼく） 男性 吾輩（わがはい） 文人/咒术师等等 あたし 女性 うち 女性 没有绝对的情况，想用什么其实都可以，只不过别人可能觉得你有点奇怪 你 单词 通常适用范围 君（きみ） 对同辈、晚辈 貴方（あなた） 对陌生人，或女人称呼丈夫 お前（まえ） 对同辈、晚辈。比较不礼貌 貴様（きさま） 一般用于斥责 ～さん 「～」处填入对方姓名，共通 ～くん 「～」处填入对方姓名，男性 ～ちゃん 「～」处填入对方姓名，女性 他/她/它 单词 通常适用范围 彼（かれ） 男性 彼女（かのじょ） 女性 あの～ 「～」处填入「它」的种类 ～们一般用「～たち」或者「～ら」表示。以下为示例。 中文 日文 我们 私たち 你们 君たち 他们 彼たち 那些猫 あの猫たち 方位 单词 通常适用范围 ここ 这里（离说话人更近） そこ 那里（离听话人更近） あそこ 那里（离双方都远） こちら ここ的较为尊敬的说法 そちら そこ的较为尊敬的说法 あちら あそこ的较为尊敬的说法 こっち こちら的口语形式 そっち そちら的口语形式 あっち あちら的口语形式 中（なか） 中间 前（まえ） 前面 後（うし）ろ 后面 上（うえ） 上面 下（した） 下面 左（ひだり） 左边 右（みぎ） 右边 内（うち） 里边 外（そと） 外边 数字 单词 读音 0 れい/ぜろ 1 いち 2 に 3 さん 4 し/よん 5 ご 6 ろく 7 しち/なな 8 はち 9 きゅう/く 10 じゅう 11 じゅういち 20 にじゅう 40 しじゅう 70 しちじゅう 90 きゅうじゅう 100 ひゃく 200 にひゃく 300 さんびゃく 400 よんひゃく 600 ろっぴゃく 700 ななひゃく 800 はっぴゃく 1000 いちせん 10000 いちまん 一億 いちおく 数～ すう～ 何～ なん～ 「数～」的示例：数年（すうねん），几年。与英语 some years 相同。 「何～」的示例：何年（なんねん），几年。与英语 what year 相同。 没提及的可以按照规律推算，比如11是10的读音和1的读音拼起来，那么12就是10和2拼起来，变成じゅうに。其中7做个位时，读しち或者なな都可以，做高位时，读しち。4、9同理。拼接亦可用于多个不同等级数字间，如837=800+30+7，则读音为はっぴゃくさんじゅうしち 个数 单词 读音 意思 一つ ひとつ 一个 二つ ふたつ 两个 三つ みっつ 三个 四つ よっつ 四个 五つ いつつ 五个 六つ むっつ 六个 七つ ななつ 七个 八つ やっつ 八个 九つ ここのつ 九个 十つ とおつ 十个 何つ なんつ 几个 人数 单词 读音 意思 一人 ひとり 一个人 二人 ふたり 两个人 三人 さんにん 三个人 四人 よんにん 四个人 五人 ごにん 五个人 六人 ろくにん 六个人 七人 しちにん 七个人 八人 はちにん 八个人 九人 きゅうにん 九个人 十人 じゅうにん 十个人 何人 なんにん 几个人 时间时/分/秒 时直接数字+時（じ）即可示例：7時（しちじ）-&gt;7点 分 单词 读音 单词 读音 单词 读音 1分 いっぷん 2分 にふん 3分 さんぷん 4分 よんぷん 5分 ごふん 6分 ろっぷん 7分 ななふん 8分 はちふん/はっぷん 9分 きゅうふん 10分 じっぷん/じゅっぷん 秒除了下面几个特殊的以外，其余均为数字读法+秒（びょう） 单词 读音 4秒 よんびょう 7秒 ななびょう 9秒 きゅうびょう 一天的变化 单词 读音 意思 朝 あさ 早上 午前 ごぜん 早上（可用于与时分秒搭配） 昼 ひる 中午 午後 ごご 下午（可用于与时分秒搭配） 夕方 ゆうがた 傍晚 晩 ばん 晚上（稍早些） 夜 よる 夜晚（稍晚些） 星期 单词 读音 意思 月曜日 げつようび 周一 火曜日 かようび 周二 水曜日 すいようび 周三 木曜日 もくようび 周四 金曜日 きんようび 周五 土曜日 どようび 周六 日曜日 にちようび 周日 何曜日 なんようび 星期几 四季 单词 读音 意思 春 はる 春天 夏 なつ 夏天 秋 あき 秋天 冬 ふゆ 冬天 春季 しゅんき 春季 夏季 かき 夏季 秋季 しゅうき 秋季 冬季 とうき 冬季 年/月/日期 年直接数字+年（ねん）即可示例：7年（しちねん） 月直接数字+月（がつ）即可示例：7月（しちがつ）注：作为“几月”的一部分时，月读がつ；其他时候一般读げつ 单词 读音 单词 读音 单词 读音 单词 读音 1日 ついたち 2日 ふつか 3日 みっか 4日 よっか 5日 いつか 6日 むいか 7日 なのか 8日 ようか 9日 ここのか 10日 とおか 11日 じゅういちにち 12日 じゅうににち 13日 じゅうさんにち 14日 じゅうよっか 15日 じゅうごにち 16日 じゅうろくにち 17日 じゅうしちにち 18日 じゅうはちにち 19日 じゅうくにち 20日 はつか 21日 にじゅういちにち 22日 にじゅうににち 23日 にじゅうさんにち 24日 にじゅうよっか 25日 にじゅうごにち 26日 にじゅうろくにち 27日 にじゅうしちにち 28日 にじゅうはちにち 29日 にじゅうくにち 30日 さんじゅう 31日 さんじゅういちにち 何日 なんにち 时段对于年/时/分/秒，直接数字+間（かん）即可示例：7年間（しちねんかん）-&gt;7年对于月，用数字+月間（げつかん）即可对于日，用数字+日間（にちかん）即可 多久以前 单词 读音 意思 ～前 ～ぜん 前接时间，表示多长时间以前 ～後 ～ご 前接时间，表示多长时间以后 示例：三年前（さんねんぜん） 今天/本周/本月/本年 单词 读音 意思 一昨日 おととい 前天 昨日 きのう 昨天 今日 きょう 今天 明日 あした/あす 明天 明後日 あさって 后天 先々周 せんせんしゅう 上上周 先周 せんしゅう 上周 今周 こんしゅう 本周 来周 らいしゅう 下周 再来周 さらいしゅう 下下周 先々月 せんせんげつ 上上个月 先月 せんげつ 上个月 今月 こんげつ 本月 来月 らいげつ 下个月 再来月 さらいげつ 下下个月 前年 ぜんねん 前年 一昨年 おととし 前年 去年 きょねん 去年 昨年 さくねん 去年 今年 ことし 今年 来年 らいねん 明年 再来年 さらいねん 后年]]></content>
      <categories>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>日语教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五十音图]]></title>
    <url>%2FJapanese%2FFiftyTone%2F</url>
    <content type="text"><![CDATA[五十音图详解 五十音图基本图样 平假名 片假名 罗马音 平假名 片假名 罗马音 平假名 片假名 罗马音 平假名 片假名 罗马音 平假名 片假名 罗马音 あ行 あ ア a い イ i う ウ u え エ e お オ o か行 か カ ka き キ ki く ク ku け ケ ke こ コ ko た行 た タ ta ち チ chi つ ツ tsu て テ te と ト to さ行 さ サ sa し シ shi/si す ス su せ セ se そ ソ so は行 は ハ ha ひ ヒ hi ふ フ fu/hu へ ヘ he ほ ホ ho な行 な ナ na に ニ ni ぬ ヌ nu ね ネ ne の ノ no ま行 ま マ ma み ミ mi む ム mu め メ me も モ mo ら行 ら ラ ra り リ ri る ル ru れ レ re ろ ロ ro や行 や ヤ ya ゆ ユ yu よ ヨ yo わ行 わ ワ wa を ヲ wo ん行 ん ン n が行 が ガ ga ぎ ギ gi ぐ グ gu げ ゲ ge ご ゴ go だ行 だ ダ da ぢ ヂ di づ ヅ du で デ de ど ド do ざ行 ざ ザ za じ ジ ji/zi ず ズ zu ぜ ゼ ze ぞ ゾ zo ば行 ば バ ba び ビ bi ぶ ブ bu べ ベ be ぼ ボ bo ぱ行 ぱ パ pa ぴ ピ pi ぷ プ pu ぺ ペ pe ぽ ポ po 五十音图附加部分（拗音） 平假名 片假名 罗马音 平假名 片假名 罗马音 平假名 片假名 罗马音 か行 きゃ キャ kya きゅ キュ kyu きょ キョ kyo が行 ぎゃ ギャ gya ぎゅ ギュ gyu ぎょ ギョ gyo た行 ちゃ チャ cha ちゅ チュ chu ちょ チョ cho だ行 でゃ デャ dha でゅ デュ dhu でょ デョ dho さ行 しゃ シャ sha しゅ シュ shu しょ ショ sho ざ行 じゃ ジャ ja じゅ ジュ ju じょ ジョ jo は行 ひゃ ヒャ hya ひゅ ヒュ hyu ひょ ヒョ hyo ば行 びゃ ビャ bya びゅ ビュ byu びょ ビョ byo ぱ行 ぴゃ ピャ pya ぴゅ ピュ pyu ぴょ ピョ pyo な行 にゃ ニャ nya にゅ ニュ nyu にょ ニョ nyo ま行 みゃ ミャ mya みゅ ミュ myu みょ ミョ myo ら行 りゃ リャ rya りゅ リュ ryu りょ リョ ryo 促音/长音 促音（っ或ッ）示例：はっきり罗马音：ha kki ri意思：清楚、明朗要点： 写罗马音时，促音的标记与后一个音的第一个字母一致 读的时候，发音的位置要停半个字符的时间 唱歌的时候，有时候明显地停顿半个字符的话会显得很奇怪，此时促音的读音应该和前一个假名的最后一个字母一致 长音在一个平假名单词中，如果前一个音以i结尾且后一个是い，或以e结尾且后一个是え，或以o结尾且后一个是う，此时对于这些い、え、う，不单独发音，而是发长音在一个片假名单词中，如果出现一条横线，就意味着长音示例：誓（ちか）おう罗马音：chi ka o u意思：（主观上想要）起誓要点： 写罗马音时，长音的标记是自己原本的标记 读的时候，长音的发音与前一个假名的最后一个字母一致，且不停顿，相当于前一个假名发音时长增加一个字符的时间 相关软件下载以下软件至少适用于Windows环境五十音图（仅清音）日语五十音测试 说明读音 按谐音方法（全都读第一声）： 罗马音 对应谐音 a 啊 i 衣 u 呜 e 诶 o 哦 表格中标注的罗马音，若有斜杠分割的，说明这两个音都可以 书写请注意区分以下几个假名： 片假名tsu（ツ）和片假名shi（シ）ツ是从上向下的一撇，シ是从下往上 片假名so（ソ）和片假名n（ン）ソ是从上向下的一撇，ン是从下往上 平假名he（へ）和片假名he（ヘ）平假名的へ在书写时，向下的一划与水平方向夹角较小，片假名的较大 片假名ra（ラ）和片假名（ヲ） 变音在作助词时，以下平假名会发生变音： 假名 原罗马音 变音后罗马音 は ha wa へ he e を wo o 打字要点希望打出以下罗马音所对应的假名时，需要注意打字的方法 罗马音 对应平假名 对应片假名 打字变化 n ん ン nn ぁ ァ la/xa 变小的假名只要在原读音前面加上l或x就行，建议用x]]></content>
      <categories>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>日语教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[捕获并分析帧和IP报文]]></title>
    <url>%2Fnetwork-experiment%2Finterception%2F</url>
    <content type="text"><![CDATA[计算机网络实验3 实验目的 捕获并分析以太网的帧，获取目标与源网卡的MAC 地址 获取本机地址 获取远端MAC地址 实验环境 Windows 10 C# Visual Studio 2017 实验结果&emsp;测试时，设置为超过10000Bps就会报警 实验总结 全局初始化安装WinPcap和SharpPcap 查看网卡信息通过调用ipconfig.exe实现 适配器 计时动作 载入适配器列表 载入适配器信息 开始侦听 收包动作 成帧 成帧时修改流量统计 监视流量 暂停侦听 继续侦听 停止侦听 保存日志 退出程序 技术细节 计算流量的方法构建新结构体（mac + ip +mode）放进dictionary当key，各key累计收发包大小当value。新建线程，每隔1s遍历各来源的收发流量，超过1MB的，可以认为在这1s内平流量达到1MBps以上，故而给本机警告 遍历dictionary因为多线程同时在访问dictionary，所以会出现在一个线程遍历dictionary的时候，另一个线程正在新增dictionary的项。此时采用foreach遍历会报错，因为foreach要求正在遍历的对象不能有变化 有网络但侦听不到包体如果确认程序没错，那么可能是 选错网卡，要注意选一个有网络的网卡 当前的网络收发包类型不是ip and tcp，应该是filter的问题，关掉filter即可 BitConverter会反向获取。如，现有byte[] test={0x01,0x10,0x0f,0xff};二进制为00000001 00010000 00001111 11111111十进制为17829887此时进行uint ans=BitConverter.ToUInt32(test,0);会得到ans= 4279177217十六进制为ff0f1001二进制为11111111 00001111 00010000 00000001可见不能得到想要的结果，因为BitConverter会反向转换所给的byte数组所以应该先将要转换的数组反向，再使用BitConverter 参考链接SharpPcap]]></content>
      <categories>
        <category>network-experiment</category>
      </categories>
      <tags>
        <tag>计算机网络实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟RS-232接口双机互联编程]]></title>
    <url>%2Fnetwork-experiment%2FRS-232%2F</url>
    <content type="text"><![CDATA[计算机网络实验2 实验目的 实现两台计算机通过串口通信 实验环境 本机Windows10 虚拟机系统VirtualBox 虚拟机1 Windows7 虚拟机2 Windows7 C# Visual Studio 2017 实验结果启动应用，得到如图界面。因为每个空格都会在确定了前一个空格后变为可编辑，而且会给出相应的默认值，所以可以一直点击确定，直到所有设置都被确定设置完成后得到如图情况，此时点击“启动服务”正常启动服务后收到提示双机互联时应有如图态势 实验总结基于VirtualBox 配置两台虚拟机时，应选择相同的串口 端口模式选择“主机管道”，路径/地址格式为\\.\pipe\xxxx，其中xxxx可以任意填写，但要保证两台虚拟机一致 对于选项“连接至现有通道或套接字”，其中一台虚拟机不勾选，称为pc1，另一台勾选，称为pc2 启动时，应先启动pc1，再启动pc2，否则会报如下错误 软件层面通信前应确保两台虚拟机上的软件都已经成功启动服务，否则不能互联 配置属性 接收 发送 退出]]></content>
      <categories>
        <category>network-experiment</category>
      </categories>
      <tags>
        <tag>计算机网络实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日本語教程索引]]></title>
    <url>%2FJapanese%2FJapaneseMenu%2F</url>
    <content type="text"><![CDATA[只是想写一个日语教程，为了将来方便给云霄一中日语部教学。于是这里就当成目录吧。五十音图日语入门向基本单词]]></content>
      <categories>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>日语教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作网线]]></title>
    <url>%2Fnetwork-experiment%2Fmakereticle%2F</url>
    <content type="text"><![CDATA[计算机网络实验1 制作网线时应注意将线插到水晶头底部]]></content>
      <categories>
        <category>network-experiment</category>
      </categories>
      <tags>
        <tag>计算机网络实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统实验报告-实验1 oracle 11g的安装、配置和使用]]></title>
    <url>%2Fdatabase-experiment%2Fdb-ex1%2F</url>
    <content type="text"><![CDATA[只是一篇实验报告。 实验目的 掌握Oracle 11g Server的安装 掌握Oracle的监听与网络配置 掌握Oracle数据库的启动与关闭 掌握Oracle的交互式开发环境、工具及常用管理操作命令 实验内容/步骤 安装Oracle 11g（服务器版本） 理解安装过程中各选项的含义及作用 了解内置用户的登录和服务器预定义角色 安装完成后以OEM方式登录、管理数据库 创建以自己学号为账号的新用户(S+自己学号)。 对账号做相应授权。 使用网络配置工具进行网络配置 存在的问题及解决方案(列出遇到的问题及其解决办法，列出没有解决的问题) Windows10安装障碍（不满足最低配置）① 提取iso中所有文件② 记事本打开\stage\cvu\cvu_prereq.xml③ 修改如图字段，重点修改6.2以及Windows 10参考链接 Environment Variable: “PATH” 失败① 打开环境变量配置，选择PATH② 先备份PATH，之后删除一部分PATH项，直到不会报错③ 正常安装，结束后恢复原PATH列表参考链接 以OEM方式登录访问localhost:1158/em/console/logon/logon 创建新用户① 打开SQL Plus② 新建数据表空间，语句如下： 123create tablespace dbsp_2 datafile &apos;url\filename.dbf&apos;size 10mextent management local autoallocate; 其中单引号内链接自行指定，注意指定的文件夹应是已创建的，且新建的文件后缀名为.dbf③ 新建用户，语句如下 1create user username identified by password 其中username为用户名，by后面为密钥④ 授权，语句格式如下： 1grant connect,resource,dba to username; 可以是如下形式： 1grant [权限] to [用户名]; 参考链接 配置网络① 运行Net Configuration Assist② 选择“本地网络服务名配置”③ 选择“添加”④ 这一步要求输入你要访问的数据库的“全局数据库名”，“全局数据库名”在安装数据库时指定，默认为name.domain（即：数据库名+数据库域名），当然也可以根据自己喜好随意命名，可以通过select * from global_name;进行查询。*可以直接命名为myorcl⑤ 选择网络语数据库的通信协议，默认TCP即可⑥ 主机名填写127.0.0.1用以访问本地数据库，并选择“使用标准端口号1521”⑦ 选择“是，进行测试”⑧ 默认的测试使用Oracle的Scott用户，因为用户被锁或口令不对，一般情况都会测试不成功，这时候可以通过“更改登录”重新输入数据库的用户/口令来进行测试是否连接成功⑨ 网络服务名，即为该远程连接配置命名。默认即可。至此，如果不需要再配置其他的网络服务，则该网络服务名配置完毕。参考链接]]></content>
      <categories>
        <category>database-experiment</category>
      </categories>
      <tags>
        <tag>数据库系统实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈夫曼树]]></title>
    <url>%2FHuffmanTree%2FHuffmanTree%2F</url>
    <content type="text"><![CDATA[一棵裸的哈夫曼树，看点可能在于封装（嘛，反正是留档给自己看的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std;typedef char Type;typedef struct NODE&#123; Type data; int weight; NODE* Lchild; NODE* Rchild; NODE* Parent;&#125;NODE,*node;//树的结点 struct cmp&#123; Type data; int weight; node selfroot; friend bool operator &gt;(const cmp&amp; a,const cmp&amp; b) &#123; return a.weight&gt;b.weight; &#125;&#125;;//为了使用优先队列，必须重载大于号，而重载大于号不能针对指针，故有此类型 class HuffmanTree&#123; private: int n; node root; cmp temp[100]; map&lt;string,char&gt;m;//序列对字符的映射 void print(char x,string y) &#123; cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl; &#125; void cal(node T,string num) &#123; if(n==1) &#123; print(root-&gt;data,"0"); return; &#125; if(T-&gt;data=='#') &#123; cal(T-&gt;Lchild,num+"0"); cal(T-&gt;Rchild,num+"1"); return; &#125; print(T-&gt;data,num); m[num]=T-&gt;data; &#125; void destroy(node T) &#123; if(T-&gt;Lchild!=NULL) destroy(T-&gt;Lchild); if(T-&gt;Rchild!=NULL) destroy(T-&gt;Rchild); delete T; &#125; public: HuffmanTree() &#123; root=NULL; &#125; void init() &#123; cout&lt;&lt;"请输入字符个数n（n&lt;100）。接下来n行，每行输入一个字符及其权重。（输入的字符不可以是#）\n"; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;temp[i].data&gt;&gt;temp[i].weight; temp[i].selfroot=new NODE; node p=temp[i].selfroot; p-&gt;data=temp[i].data; p-&gt;weight=temp[i].weight; p-&gt;Lchild=p-&gt;Rchild=p-&gt;Parent=NULL; &#125; &#125; void build() &#123; priority_queue&lt;cmp,vector&lt;cmp&gt;,greater&lt;cmp&gt; &gt;q; for(int i=0;i&lt;n;i++) q.push(temp[i]); while(!q.empty()) &#123; cmp p1=q.top(); q.pop(); if(q.empty()) &#123; root=p1.selfroot; break; &#125; cmp p2=q.top(); q.pop(); cmp tmp; tmp.data='#'; tmp.weight=p1.weight+p2.weight; tmp.selfroot=new NODE; node kp=tmp.selfroot; kp-&gt;data=tmp.data; kp-&gt;weight=tmp.weight; kp-&gt;Parent=NULL; p1.selfroot-&gt;Parent=p2.selfroot-&gt;Parent=kp; if(p1.weight&lt;p2.weight) &#123; kp-&gt;Lchild=p1.selfroot; kp-&gt;Rchild=p2.selfroot; &#125; else &#123; kp-&gt;Rchild=p2.selfroot; kp-&gt;Lchild=p1.selfroot; &#125; q.push(tmp); &#125; &#125; void show() &#123; cout&lt;&lt;"所求出的对应编码表如下（不按顺序）：\n"; cal(root,""); cout&lt;&lt;endl; &#125; void solve() &#123; string str,ans=""; cout&lt;&lt;"请输入待解码的合法01序列\n"; cin&gt;&gt;str; int len=str.length(); for(int i=0;i&lt;len;i++) &#123; int cnt=1; string tmp=str.substr(i,1); map&lt;string,char&gt;::iterator it=m.find(tmp); while(it==m.end()) &#123; cnt++; if(i+cnt&gt;len) &#123; cout&lt;&lt;"输入序列不合法！\n"; return; &#125; tmp=str.substr(i,cnt); it=m.find(tmp); &#125; ans+=m[tmp]; i+=cnt-1; &#125; cout&lt;&lt;"解码后的序列为："&lt;&lt;ans&lt;&lt;endl&lt;&lt;endl; &#125; void del() &#123; destroy(root); cout&lt;&lt;"该哈夫曼树已经成功销毁！\n"; &#125;&#125;;int main()&#123; HuffmanTree ht; ht.init(); ht.build(); ht.show(); ht.solve(); ht.del(); return 0;&#125;]]></content>
      <categories>
        <category>HuffmanTree</category>
      </categories>
      <tags>
        <tag>HuffmanTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[职业测试结果-UX课程要求]]></title>
    <url>%2Fothers%2Fux%2F</url>
    <content type="text"><![CDATA[物流师ISTJISTJ人格类型被认为是数量最多的，大约占人口总数的13%。他们明显的正直，实际，奉献的优点使他们成为很多家庭以及拥护传统，规则，标准的组织的重要一员，比如律所，监管部门和军队。ISTJ类型的人愿意为自己的行为负责，为努力完成目标所做的事感到骄傲。ISTJ会毫不吝啬时间和精力来准确和耐心地完成每个任务。ISTJ不喜欢做假设，而是分析周围环境，根据事实来找到最实际的做法。ISTJ从不废话，当他们做了决定时，会把取得目标需要的所有信息传播给别人，期待他人立刻掌握情况马上行动。ISTJ不能容忍犹豫不决，在自己的决定受到不切实际，尤其是忽略事实的理论的挑战时会很快失去耐心。如果这些挑战变成了浪费时间的辩论，截止日期越近他们就会变得越发气愤。如果你尊重你的名誉，就结交那些优秀的人ISTJ说做就做，不惜一切完成任务，那些不同样说话算话的人使他们感到困惑。如果再加上懒惰和虚伪就最为ISTJ所不齿。因为这样，ISTJ通常更喜欢独自工作，或至少要建立明确的等级制度，使他们可以计划并完成目标而不用为别人的不可靠所扰。ISTJ有敏锐的建立在事实上的思维，与依靠别人相比更愿意自给自足。对别人的依赖在他们看来是弱点，他们对责任的热情，可靠，和正直的人格不允许他们落入这样的陷阱。正直的人格对ISTJ很重要，他们不论代价遵守已经建立的规则和准则，时刻报告自己的错误，实话实说，即使这样做有灾难性的后果。对ISTJ来说，诚信比感性思考重要得多，他们直截了当的方式可能让别人误解他们冷漠，机械化。这种类型的人很难对外表达自己的情绪和好感，但是说他们没感情甚至没人性会让他们很受伤。与不合适的人在一起还不如独自一人ISTJ的尽心尽力是很好的品质，使得他们能成就许多，但同时也是能被一些不严谨的人利用的弱点。ISTJ寻求安全和稳定，把平缓的运营看作自己的责任，他们可能发现同事和爱人把他们的责任转移给自己，因为自己总会接受。ISTJ趋向于保留自己的看法用事实说话，但要等观察得到的证据解释一切可能需要很长时间。ISTJ需要记得照顾自己，他们对稳定和高效顽固的尽心尽力可能使一些长期目标变得困难，因为别人会更加依赖他们，使ISTJ产生一些可能很多年都不会表现出来的情绪压力，在表现出来时通常为时已晚。如果他们能找到真正感激和赞扬他们的品质，享受他们的聪慧清晰和可靠的同事或配偶，ISTJ会发现他们使事情稳定的角色是很有满足感的，因为自己是一个完美运行的系统的一部分。]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU P1166 敌兵布阵 题解]]></title>
    <url>%2FAnswer%2Fhdu-p1166%2F</url>
    <content type="text"><![CDATA[HDU P1166 敌兵布阵 题解 Problem DescriptionC国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令 Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input1101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample OutputCase 1:63359 显然是线段树题，而且还是单点修改的……把luogu 3372的AC Code改一下就完事了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;ll ans[1000010],tag[1000010],a[1000010],n,m;inline ll ls(ll p)&#123; return p&lt;&lt;1;&#125;inline ll rs(ll p)&#123; return p&lt;&lt;1|1;&#125;inline void push_up(ll p)&#123; ans[p]=ans[ls(p)]+ans[rs(p)];&#125;void build(ll p,ll l,ll r)&#123; tag[p]=0; if(l==r) &#123; ans[p]=a[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; build(ls(p),l,mid); build(rs(p),mid+1,r); push_up(p);&#125;inline void f(ll p,ll l,ll r,ll k)&#123; ans[p]+=k*(r-l+1); tag[p]+=k;&#125;inline void push_down(ll p,ll l,ll r)&#123; ll mid=(l+r)&gt;&gt;1; f(ls(p),l,mid,tag[p]); f(rs(p),mid+1,r,tag[p]); tag[p]=0;&#125;void update(ll x,ll y,ll l,ll r,ll p,ll k)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; ans[p]+=k*(r-l+1); tag[p]+=k; return; &#125; push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(x,y,l,mid,ls(p),k); if(y&gt;mid) update(x,y,mid+1,r,rs(p),k); push_up(p);&#125;ll query(ll x,ll y,ll l,ll r,ll p)&#123; ll tmp=0,mid=(l+r)&gt;&gt;1; if(x&lt;=l&amp;&amp;r&lt;=y) return ans[p]; push_down(p,l,r); if(x&lt;=mid) tmp+=query(x,y,l,mid,ls(p)); if(y&gt;mid) tmp+=query(x,y,mid+1,r,rs(p)); return tmp;&#125;int main()&#123; int T; cin&gt;&gt;T; for(int CASE=1;CASE&lt;=T;CASE++)&#123; printf("Case %d:\n",CASE); ll x,y,k,t; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); build(1,1,n); string command; while(cin&gt;&gt;command) &#123; if(command=="End") break; if(command=="Add")&#123; scanf("%lld %lld",&amp;x,&amp;k); update(x,x,1,n,1,k);//在luogu P3372这里是对[x,y]区间修改，现在改成对[x,x]就是单点了（ &#125; else if(command=="Sub")&#123; scanf("%lld %lld",&amp;x,&amp;k); update(x,x,1,n,1,-k); &#125; else if(command=="Query")&#123; scanf("%lld %lld",&amp;x,&amp;y); printf("%lld\n",query(x,y,1,n,1)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序专题]]></title>
    <url>%2Fsort%2Fsort%2F</url>
    <content type="text"><![CDATA[排序专题基本题面：设有n个正整数，保证n不大于100且这n个数都不大于1000，对其进行从小到大的排序。 选择排序123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int main()&#123; int n,a[100]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++)//依次确定应该填在下标为i的位置的数 &#123; for(int j=i+1;j&lt;n;j++)//将下标i上保存的数依次与其后所有数字比较 &#123; if(a[i]&gt;a[j]) &#123; int temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125; 冒泡排序123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int main()&#123; int n,a[100]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++)//通过第i次交换，能确定下标为i的位置所应该填写的数 &#123; for(int j=n-1;j&gt;i;j--)//每次把最小的交换到最前面 &#123; if(a[j-1]&gt;a[j])//比较相邻两个 &#123; int temp=a[j-1]; a[j-1]=a[j]; a[j]=temp; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125; 桶排序桶排序有其缺点：1、必须全是整数（负数可以平移数轴）2、必须知道数字最大不超过多少3、所开数组不得超过题目的内存限制需要以上三点同时满足，否则不可以使用桶排序1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int main()&#123; int n,a[100]; int bucket[1000]=&#123;0&#125;;//用bucket[i]表示数字i出现的次数，初始化为0 //因为题目中说了都是正整数而且均小于1000，所以数组开到1000 cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) &#123; int number=a[i]; bucket[number]++;//每当数字i出现，就令其出现次数+1 &#125; for(int i=0;i&lt;1000;i++)//因为题目中说了都是正整数而且均小于1000，所以循环小于1000 &#123; if(bucket[i]!=0)//如果bucket[i]==0，则表示数字i没有出现过，就不需要输出了 &#123; for(int j=0;j&lt;bucket[i];j++) &#123; //因为数字出现了bucket[i]次，所以需要循环bucket[i]次 //否则会造成重复数字只会输出一个 cout&lt;&lt;i&lt;&lt;" "; &#125; &#125; &#125; return 0;&#125; sort函数sort函数默认是从小到大排序的。123456789101112131415#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n,a[100]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n); for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125; 如果要令sort函数实现从大到小排序，可以写作如下程序段。1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;bool cmp(int a,int b)&#123; if(a&gt;b) return true; else return false;&#125;int main()&#123; int n,a[100]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n,cmp); for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125; 其中cmp函数因为bool类型的特性，又可简写，变为如下程序段。12345678910111213141516171819#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;bool cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int n,a[100]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n,cmp); for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125; 还可以有不写cmp函数，而使用重载运算符的方法。此处不做介绍，详见C++语言-9-结构体。 堆排序堆排序需要使用优先队列，开始学习队列后才需要学习。优先队列默认是最大堆，也就是说最大的数在队首。要实现从小到大排序的话只能写作如下程序段。12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int main()&#123; int n; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; int t; cin&gt;&gt;t; q.push(t); &#125; for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;q.top()&lt;&lt;" "; q.pop(); &#125; return 0;&#125; 而若要用优先队列实现从大到小排序，只需写作如下程序段。12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int main()&#123; int n; priority_queue&lt;int&gt;q; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; int t; cin&gt;&gt;t; q.push(t); &#125; for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;q.top()&lt;&lt;" "; q.pop(); &#125; return 0;&#125; 快速排序快速排序是分治算法的入门题，开始学分治算法后才需要学习。123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;void kuai(int l,int r)//每次确定区间最中间的数字&#123; int i=l,j=r,mid=a[(l+r)/2]; while(i&lt;=j) &#123; while(a[i]&lt;mid) i++; while(a[j]&gt;mid) j--; if(i&lt;=j) &#123; int tmp=a[i]; a[i]=a[j]; a[j]=tmp; i++; j--; &#125; &#125; if(l&lt;j) kuai(l,j);//排序左区间 if(r&gt;i) kuai(i,r);//排序右区间&#125;int main()&#123; int n,a[100]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; kuai(0,n-1); for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125;]]></content>
      <categories>
        <category>sort</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路三大算法核心程序段]]></title>
    <url>%2FShortestPath%2FShortestPath%2F</url>
    <content type="text"><![CDATA[以下第1和第2均假设起点为1号点，终点为n号点。 Dijkstra等待重写 SPFA适用于单源最短路，可以处理负权边，不能处理负环。思路：从起点开始寻找起点能到达的结点，然后按次序将结点入队，每当入队时标记入队，每当出队取消标记，重复处理，直到队列为空。重点：和Dijkstra相比就是多了v数组用来保存结点是否在队列里，其结果导致同一个结点可以重复入队。而Dijkstra中所有结点都只能入队一次。1234567891011121314151617181920212223242526int e[1010][1010],ans[1010],v[1010],n;//取e[a][b]=w表示存在一条从a通向b的道路，道路长度为w，其值应该在main中已经处理好//取ans[i]表示从起点到结点i的距离为ans[i]//取v[i]表示结点i是否在队列中queue&lt;int&gt;q;void spfa()&#123; while(!q.empty()) q.pop();//清空队列 memset(v,0,sizeof(v));//初始化v数组 memset(ans,0,sizeof(ans));//初始化ans数组 q.push(1);//起点入队 v[1]=1;//起点标记为已经在队列中 while(!q.empty())//当队列非空时 &#123; int st=q.front();//取队头元素 q.pop();//弹出 v[st]=0;//标记队头元素为不在队列中 for(int i=1;i&lt;=n;i++)//枚举所有点 &#123; if(i==1) continue;//如果i是起点，跳过 int p=0;//取变量p来记录是否发生更优解的更新 if(e[st][i]&amp;&amp;(!ans[i]||ans[i]&gt;ans[st]+e[st][i])) ans[i]=ans[st]+e[st][i],p=1;//发生更优解的更新，p=1 if(p&amp;&amp;!v[i]) q.push(i),v[i]=1;//如果发生更优解的更新，且结点i未入队，则结点i入队，标记为已入队 &#125; &#125;&#125; Floyd适用于求所有结点间的最短路径。12345int d[100][100];//用d[i][j]表示从i到j的最短路径for(int k=0;k&lt;n;k++) for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);]]></content>
      <categories>
        <category>ShortestPath</category>
      </categories>
      <tags>
        <tag>ShortestPath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P1880 [NOI1995]石子合并 题解]]></title>
    <url>%2FAnswer%2Fluogu-p1880%2F</url>
    <content type="text"><![CDATA[Luogu P1880 [NOI1995]石子合并 题解请先掌握区间dp。 题目描述在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分. 输入输出格式输入格式数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数. 输出格式输出共2行,第1行为最小得分,第2行为最大得分. 输入输出样例输入样例#1：44 5 9 4 输出样例#1：4354 典型的环形dp题。思路见注释。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define INF (1&lt;&lt;30)#define maxn(a,b) (a&gt;b)?a:b#define minn(a,b) (a&lt;b)?a:bint a[110],f[110][110][2],n,ma,mi;//用f[i][j][0]表示合并从i到j的最小花费，f[i][j][1]表示合并从i到j的最大花费int sum(int i,int j)&#123; int ans=0; while(i&lt;=j) ans+=a[i++]; return ans;&#125;//计算合并从i到j（含i和j）的总费用void solve()&#123; for(int t=1;t&lt;n;t++) &#123; for(int i=0;i&lt;n-t;i++) &#123; int j=i+t; f[i][j][0]=INF; f[i][j][1]=-INF; int tmp=sum(i,j); for(int k=i;k&lt;j;k++) &#123; if(f[i][j][0]&gt;f[i][k][0]+f[k+1][j][0]+tmp) f[i][j][0]=f[i][k][0]+f[k+1][j][0]+tmp; if(f[i][j][1]&lt;f[i][k][1]+f[k+1][j][1]+tmp) f[i][j][1]=f[i][k][1]+f[k+1][j][1]+tmp; &#125; &#125; &#125; mi=minn(mi,f[0][n-1][0]); ma=maxn(ma,f[0][n-1][1]);&#125;int main()&#123; cin&gt;&gt;n; ma=-INF;mi=INF;//初始化最大值为极小值，最小值为极大值 memset(f,0,sizeof(f)); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); solve();//先按原顺序计算一遍 for(int i=1;i&lt;n;i++) &#123; memset(f,0,sizeof(f)); int tmp=a[0]; for(int j=0;j&lt;n-1;j++) a[j]=a[j+1]; a[n-1]=tmp;//第一个数移到最后，其余每个数向前移动一位 solve();//重算 //环形dp的重点在于变更原有顺序重算 &#125; cout&lt;&lt;mi&lt;&lt;endl&lt;&lt;ma; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>dp</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P3366 【模板】最小生成树 题解]]></title>
    <url>%2FAnswer%2Fluogu-p3366%2F</url>
    <content type="text"><![CDATA[Luogu P3366 【模板】最小生成树 题解 题目描述如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出orz 输入输出格式输入格式：第一行包含两个整数N、M，表示该图共有N个结点和M条无向边。（N&lt;=5000，M&lt;=200000）接下来M行每行包含三个整数Xi、Yi、Zi，表示有一条长度为Zi的无向边连接结点Xi、Yi 输出格式：输出包含一个数，即最小生成树的各边的长度之和；如果该图不连通则输出orz 输入输出样例输入样例#1：4 51 2 21 3 21 4 32 3 43 4 3 输出样例#1：7 说明时空限制：1000ms,128M数据规模：对于20%的数据：N&lt;=5，M&lt;=20对于40%的数据：N&lt;=50，M&lt;=2500对于70%的数据：N&lt;=500，M&lt;=10000对于100%的数据：N&lt;=5000，M&lt;=200000 最小生成树板子题，没什么好说的…… 算法说明：以下两个算法都基于贪心实现。kruskal算法采用并查集思想。步骤如下： 把每个点单独拆分，使得每个点的父亲都是它自己，即每个点单独成一个连通块。 每次取最短边，如果边两端的点处于同一个连通块，则pop掉，再取最短的边，直到边两端的点不处于同一个连通块为止。 合并两个点所在的连通块，并且ans+=两个点的距离。 重复2和3，共n-1遍。 prim算法采用遍历。步骤如下： 初始把1号点标记为已经使用过，并将与其相连的所有边加入队列。 每次取最短边，如果边的终点已使用过，则pop掉，再取最短的边，直到边的终点未使用过为止， 将边的终点标记为已经使用过，并且ans+=该边长度，再将与该边终点相连的所有边加入队列。 重复2和3，共n-1遍。*因为每次选择可用的新边时，该边起点都是已经使用过的（所以该边才有加入队列），所以只要判断该边终点即可。 代码：kruskal算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;struct edge&#123; int u,v,w;&#125;;int n,m,f[5010],v[5010];priority_queue&lt;edge,vector&lt;edge&gt;,greater&lt;edge&gt; &gt;q;bool operator &gt;(const edge &amp;a,const edge &amp;b)&#123; return a.w&gt;b.w;&#125;int find(int x)&#123; if(x==f[x]) return x; return f[x]=find(f[x]);&#125;inline void join(int x,int y)&#123; f[x]=y;&#125;long long kruskal()&#123; long long ans=0; for(int x=1;x&lt;n;x++) &#123; edge temp=q.top(); while(find(temp.u)==find(temp.v)) &#123; q.pop(); temp=q.top(); &#125; q.pop(); int tu=find(temp.u),tv=find(temp.v); join(tu,tv); ans+=temp.w; &#125; return ans;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) f[i]=i; while(m--) &#123; int x,y,z; scanf("%d %d %d",&amp;x,&amp;y,&amp;z); v[x]=v[y]=1; edge temp; temp.u=x; temp.v=y; temp.w=z; q.push(temp); &#125; for(int i=1;i&lt;=n;i++) if(!v[i])&#123; cout&lt;&lt;"orz"; return 0; &#125; cout&lt;&lt;kruskal(); return 0;&#125; prim算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct edge&#123; int v,w;&#125;;int n,m;bool v[5010]=&#123;false&#125;;vector&lt;edge&gt;G[5010];priority_queue&lt;edge,vector&lt;edge&gt;,greater&lt;edge&gt; &gt;q;bool operator &gt;(const edge &amp;a,const edge &amp;b)&#123; return a.w&gt;b.w;&#125;long long prim()&#123; long long ans=0; v[1]=1; for(vector&lt;edge&gt;::iterator i=G[1].begin();i!=G[1].end();i++) q.push(*i); int x=1; while(x++&lt;n)&#123; edge temp=q.top(); while(v[temp.v])&#123; q.pop(); temp=q.top(); &#125; ans+=temp.w; v[temp.v]=1; for(vector&lt;edge&gt;::iterator i=G[temp.v].begin();i!=G[temp.v].end();i++) q.push(*i); &#125; return ans;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++)&#123; int x,y,z; scanf("%d %d %d",&amp;x,&amp;y,&amp;z); edge temp; temp.v=y; temp.w=z; G[x].push_back(temp); temp.v=x; G[y].push_back(temp); &#125; for(int i=1;i&lt;=n;i++)&#123; if(G[i].empty())&#123; cout&lt;&lt;"orz"; return 0; &#125; &#125; cout&lt;&lt;prim(); return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年4月月赛 Day2 Violet 题解]]></title>
    <url>%2FAnswer%2Fyxyz201804-0203%2F</url>
    <content type="text"><![CDATA[2018年4月月赛 Day2 Violet 题解 题目背景少佐在哪！！别拦着我！！我要去找少佐！！ 自从那天的别离之后，Violet和少佐已经分别许久。就在Violet从昏迷中恢复意识的那一刻起，Violet一直在计划着去寻找少佐。现在，时机成熟了。 题目描述Violet只能确定少佐在n个城市中的某一个，却不知道具体在哪一个，而从疗养院所在地s去到任意一个城市，都需要经过若干城市之间的若干有向道路。这些道路错综复杂，Violet想尽快赶到。请你帮她算算到各个城市的最短时间吧。 输入输出格式输入格式第一行包含三个整数N、M、S，分别表示点的个数、有向边的个数、出发点的编号。接下来M行每行包含三个整数Fi、Gi、Wi，分别表示第i条有向边的出发点、目标点和长度。 输出格式一行，包含N个用空格分隔的整数，其中第i个整数表示从点S出发到点i的最短路径长度（若S=i则最短路径长度为0，若从点S无法到达点i，则最短路径长度为2147483647） 输入输出样例输入样例#1：4 6 11 2 22 3 22 4 11 3 53 4 31 4 4 输出样例#1：0 2 4 3 说明1&lt;=N&lt;=10000，1&lt;=M&lt;=500000 邻接表板子题……可类比Luogu P3371代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct edge&#123;int next,dis;&#125;; vector&lt;edge&gt; e[10010];int ans[10010];bool v[10010]=&#123;false&#125;;queue&lt;int&gt;q;inline void addedge(int f,int g,int w)&#123; edge x; x.next=g; x.dis=w; e[f].push_back(x);&#125;void spfa()&#123; while(!q.empty()) &#123; int t=q.front(); q.pop(); v[t]=false; for(vector&lt;edge&gt;::iterator i=e[t].begin();i!=e[t].end();i++) &#123; int tmp=ans[t]+i-&gt;dis,ttt=i-&gt;next; if(tmp&lt;ans[ttt]) &#123; ans[ttt]=tmp; if(!v[ttt]) &#123; q.push(ttt); v[ttt]=true; &#125; &#125; &#125; &#125;&#125;int main()&#123; int n,m,s; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=n;i++) ans[i]=2147483647; ans[s]=0; for(int i=0;i&lt;m;i++) &#123; int f,g,w; scanf("%d %d %d",&amp;f,&amp;g,&amp;w); addedge(f,g,w); &#125; q.push(s); v[s]=true; spfa(); for(int i=1;i&lt;=n;i++) printf("%d ",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年4月月赛 Day2 工作分配问题 题解]]></title>
    <url>%2FAnswer%2Fyxyz201804-0202%2F</url>
    <content type="text"><![CDATA[2018年4月月赛 Day2 工作分配问题 题解 题目描述设有 n 件工作分配给 n 个人。将工作 i 分配给第 j 个人所需的费用为c[i][j] 。试设计一个算法，为每一个人都分配 1 件不同的工作，并使总费用达到最小。 输入输出格式输入格式第一行有 1 个正整数 n 。接下来的 n 行，每行 n 个正整数，表示工作费用。 输出格式一行，包含一个正整数，为计算出的最小总费用。 输入输出样例输入样例#1：310 2 32 3 43 4 5 输出样例#1：9 说明对于100%的数据，1&lt;=n&lt;=20，1&lt;=c[i][j]&lt;=100。 1月月赛的原题。本题除了一月月赛中已经给出的dfs解，还可以有mcmf解。代码：dfs解：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;bool v[30]=&#123;false&#125;;long long ans=0;int c[30][30],n;void dfs(int x,int sum)&#123; if(x&gt;n) &#123; if(sum&lt;ans) ans=sum; return; &#125; if(ans&gt;sum) &#123; for(int i=1;i&lt;=n;i++) &#123; if(!v[i]) &#123; v[i]=true; dfs(x+1,sum+c[x][i]); v[i]=false; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;c[i][j]; ans+=c[i][j]; &#125; &#125; dfs(1,0); cout&lt;&lt;ans; return 0;&#125; 感谢cyy dalao支援的MCMF解。MCMF解：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using std::queue;using std::min;const int maxe = 2510;const int maxn = 55;const int inf = 0x3f3f3f3f;struct Edge&#123; int u,v,f,c; int next;&#125;e[maxe];int head[maxn];int ecnt;void _AddEdge(int u,int v,int f,int c) &#123; e[ecnt].u = u; e[ecnt].v = v; e[ecnt].f = f; e[ecnt].c = c; e[ecnt].next = head[u]; head[u] = ecnt; ecnt ++;&#125;void AddEdge(int u,int v,int f,int c) &#123; _AddEdge(u,v,f,c); _AddEdge(v,u,0,-c);&#125;bool inq[maxn];int dis[maxn];int pre[maxn];bool spfa(int s,int t) &#123; queue &lt;int&gt; q; memset(dis,0x3f,sizeof(dis)); memset(inq,false,sizeof(inq)); memset(pre,-1,sizeof(pre)); dis[s] = 0; inq[s] = true; q.push(s); while (!q.empty()) &#123; int cur = q.front(); q.pop(); inq[cur] = false; for (int i=head[cur];~i;i=e[i].next) &#123; if (e[i].f &gt; 0 &amp;&amp; dis[cur] + e[i].c &lt; dis[e[i].v]) &#123; dis[e[i].v] = dis[cur] + e[i].c; pre[e[i].v] = i; if (!inq[e[i].v]) &#123; q.push(e[i].v); inq[e[i].v] = true; &#125; &#125; &#125; &#125; return dis[t] != inf;&#125;void MCMF(int s,int t,int &amp;flow,int &amp;cost) &#123; flow = 0; cost = 0; while (spfa(s,t)) &#123; int curFlow = inf; for (int i=pre[t];~i;i=pre[e[i].u]) curFlow = min(curFlow,e[i].f); for (int i=pre[t];~i;i=pre[e[i].u]) &#123; e[ i ].f -= curFlow; e[i^1].f += curFlow; &#125; cost += curFlow * dis[t]; &#125;&#125;/*编号规则：源点：0汇点：1人：2*n任务：2*n+1*/int main() &#123; memset(head,-1,sizeof(head)); int n; scanf("%d",&amp;n); for (int i=1;i&lt;=n;i++) &#123; AddEdge( 0 ,2*i,1,0); AddEdge(2*i+1, 1 ,1,0); for (int j=1;j&lt;=n;j++) &#123; int t; scanf("%d",&amp;t); AddEdge(2*i,2*j+1,1,t); &#125; &#125; int f,c; MCMF(0,1,f,c); printf("%d\n",c); return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>MCMF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年4月月赛 Day2 携带 题解]]></title>
    <url>%2FAnswer%2Fyxyz201804-0201%2F</url>
    <content type="text"><![CDATA[2018年4月月赛 Day2 携带 题解 题目描述一般的九键手机的键盘是这样的： &nbsp; &nbsp; &nbsp; 1 2 abc 3 def 4 ghi 5 jkl 6 mno 7 pqrs 8 tuv 9 wxyz * 0 # 要按出英文字母就必须要按数字键多下。例如要按出x就得按9三下，第一下会出9，第二下会出w，而第三下会把w变成x。0键按两下会出一个空格。你的任务是读取一个句子，求出要在手机上打出这个句子至少需要按多少下键盘。 输入输出格式输入格式一行一个句子，只包含英文小写字母、数字、空格、星号(*)和井号(#)，且不超过200个字符。 输出格式一行一个整数，表示按键盘的总次数。 输入输出样例输入样例#1：i have a dream 输出样例#1：37 大模拟。可类比Luogu P1765代码：12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;cstring&gt;using namespace std;map&lt;char,int&gt;m;void set()&#123; m['*']=m['#']=1; for(char i='0';i&lt;='9';i++) m[i]=1; m['a']=m['d']=m['g']=m['j']=m['m']=m['p']=m['t']=m['w']=2; m['b']=m['e']=m['h']=m['k']=m['n']=m['q']=m['u']=m['x']=3; m['c']=m['f']=m['i']=m['l']=m['o']=m['r']=m['v']=m['y']=4; m['s']=m['z']=5; m[' ']=2;&#125;int main()&#123; set(); string s; getline(cin,s); int ans=0,len=s.length(); for(int i=0;i&lt;len;i++) ans+=m[s[i]]; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年4月月赛 Day1 游艇 题解]]></title>
    <url>%2FAnswer%2Fyxyz201804-0103%2F</url>
    <content type="text"><![CDATA[2018年4月月赛 Day1 游艇 题解 题目描述长江游艇俱乐部在长江上设置了n 个游艇出租站1，2，…，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1&lt;=i&lt;=j&lt;=n。试设计一个算法，计算出从任意游艇出租站i到任意游艇出租站j所需的最少租金。保证i严格小于j。对于给定的游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1&lt;=i&lt;j&lt;=n。保证计算过程中任何时刻数值都不超过10^6 输入输出格式输入格式第1 行中有1 个正整数n，表示有n个游艇出租站。 接下来的n-1 行,第i行第j个元素表示从i号游艇出租站到j号游艇出租站(1&lt;=i&lt;j&lt;=n)的租金价格r。 输出格式共n-1行，第i行输出i-1个数，每行第j个数表示从i号游艇出租站出发到达第j号游艇出租站的最少租金。 输入输出样例输入样例#1：35 157 输出样例#1：5 127 说明1&lt;=n&lt;=200 Floyd板子题……代码：12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,d[210][210];void floyd()&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=k;i++) for(int j=k+1;j&lt;=n;j++) if(d[i][j]&gt;d[i][k]+d[k][j]) d[i][j]=d[i][k]+d[k][j];&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;n;i++) for(int j=i+1;j&lt;=n;j++) scanf("%d",&amp;d[i][j]); floyd(); for(int i=1;i&lt;n;i++) &#123; for(int j=i+1;j&lt;=n;j++) cout&lt;&lt;d[i][j]&lt;&lt;" "; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年4月月赛 Day1 亲属关系 题解]]></title>
    <url>%2FAnswer%2Fyxyz201804-0102%2F</url>
    <content type="text"><![CDATA[2018年4月月赛 Day1 亲属关系 题解 题目描述若某个家族人员过于庞大，要判断两个是否是亲属，确实还很不容易，现在给出某个亲属关系图，求任意给出的两个人是否具有亲属关系。 规定：x和y是亲属，y和z是亲属，那么x和z也是亲属。如果x,y是亲属，那么x的亲属都是y的亲属，y的亲属也都是x的亲属。 输入输出格式输入格式第一行：三个整数n,m,p，分别表示有n个人，m个亲属关系，询问p对亲属关系。以下m行：每行两个数Mi，Mj，1&lt;=Mi，Mj&lt;=N，表示Mi和Mj具有亲属关系。接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲属关系。 输出格式P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲属关系。 输入输出样例输入样例#1：6 5 31 21 53 45 21 31 42 35 6 输出样例#1：YesYesNo 说明1&lt;=n,m,p&lt;=5000。 并查集板子题……可类比Luogu P3367代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int p,n,m,q,d[10100];int find(int x)&#123; int r=x; while(d[r]!=r) r=d[r]; int i=x,j; while(i!=r) &#123; j=d[i]; d[i]=r; i=j; &#125; return r;&#125;int join(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy) d[fx]=fy; return 0;&#125;int main()&#123; for(int i=1;i&lt;10100;i++) d[i]=i; scanf("%d%d%d",&amp;n,&amp;m,&amp;p); while(m--) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); join(x,y); &#125; for(int i=1;i&lt;=n;i++) find(i); while(p--) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); if(d[x]==d[y]) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年4月月赛 Day1 哥德巴赫猜想 题解]]></title>
    <url>%2FAnswer%2Fyxyz201804-0101%2F</url>
    <content type="text"><![CDATA[2018年4月月赛 Day1 哥德巴赫猜想 题解 题目背景要想证明哥德巴赫猜想，首先需要知道足够大的素数。求一下试试吧！ 题目描述如题，给定一个范围N，你需要处理M个某数字是否为质数的询问（每个数字均在范围[1,N]内） 输入输出格式输入格式第一行包含两个正整数N、M，分别表示查询的范围和查询的个数。接下来M行每行包含一个不小于1且不大于N的整数，即询问该数是否为质数。 输出格式输出包含M行，每行为Yes或No，即依次为每一个询问的结果。 输入输出样例输入样例#1：100 52349197 输出样例#1：YesYesNoNoYes 说明1&lt;=N&lt;=10000000，1&lt;=M&lt;=100000样例说明：N=100，说明接下来的询问数均属于[1,100]。所以2、3、97为质数，4、91非质数。故依次输出Yes、Yes、No、No、Yes。 筛法求素数的板子题，没什么说的。可类比Luogu P3383代码：12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;bool ans[10000010]=&#123;false&#125;;int n,m,x,t;void set()&#123; cin&gt;&gt;n&gt;&gt;m; t=n&gt;&gt;1; ans[1]=true; for(int i=2;i&lt;=t;i++) &#123; if(ans[i]) continue; for(int j=i&lt;&lt;1;j&lt;=n;j+=i) ans[j]=true; &#125;&#125;void solve()&#123; while(m--) &#123; cin&gt;&gt;x; if(ans[x]) cout&lt;&lt;"No\n"; else cout&lt;&lt;"Yes\n"; &#125;&#125;int main()&#123; set(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P3367 【模板】并查集 题解]]></title>
    <url>%2FAnswer%2Fluogu-p3367%2F</url>
    <content type="text"><![CDATA[Luogu P3367 【模板】并查集 题解 题目描述如题，现在有一个并查集，你需要完成合并和查询操作。 输入输出格式输入格式：第一行包含两个整数N、M，表示共有N个元素和M个操作。接下来M行，每行包含三个整数Zi、Xi、Yi当Zi=1时，将Xi与Yi所在的集合合并当Zi=2时，输出Xi与Yi是否在同一集合内，是的话输出Y；否则话输出N 输出格式：如上，对于每一个Zi=2的操作，都有一行输出，每行包含一个大写字母，为Y或者N 输入输出样例输入样例#1：4 72 1 21 1 22 1 21 3 42 1 41 2 32 1 4 输出样例#1：NYNY 说明时空限制：1000ms,128M数据规模：对于30%的数据，N&lt;=10，M&lt;=20；对于70%的数据，N&lt;=100，M&lt;=1000；对于100%的数据，N&lt;=10000，M&lt;=200000。 从100%数据的范围来看，显然不可能暴搜。所以为解决此题，我们采用基于树的数据结构——并查集。基本并查集应该提供两个操作：查询（最大祖先）操作和合并操作。详情见代码注释。代码：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,m,f[10010];int find(int x)&#123; if(x==f[x]) return x;//边界 return f[x]=find(f[x]);//递归查找结点x的最大祖先y，同时通过路径压缩令x与y之间的所有结点，最大祖先都置为y&#125;inline void join(int x,int y)&#123; f[x]=y;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) f[i]=i;//初始化令所有结点的最大祖先都是自己 while(m--) &#123; int x,y,z,tx,ty; scanf("%d %d %d",&amp;z,&amp;x,&amp;y); ty=find(y);//寻找y的最大祖先ty tx=find(x);//寻找x的最大祖先tx if(z==1) join(tx,ty);//现在tx是ty家里的人了 else &#123; if(tx==ty) printf("Y\n");//如果是同一家的 else printf("N\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>并查集</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20180417 Python学习随录]]></title>
    <url>%2Fpython%2Fpython-20180417%2F</url>
    <content type="text"><![CDATA[学习随录系列基本原理Python使用缩进来示意作用域，效果同C++的函数大括号Python不需要定义变量，任何合理的、未有重复的变量名均可直接使用，使用过程中也可以更改其类型。任意变量默认类型为字符串。 I/O123s=input().split(' ')#Python中一次均读取整行#本代码中，split括号中的内容为一个空格，表示s以空格为界断开成为一个列表 12print(s)#自带回车 语句选择结构123456if A1: 代码块1)elif A2: (代码块2)else: (代码块3) 同理C++参考：123456if(A1)&#123;(代码块1)&#125;else if(A2)&#123;(代码块2)&#125;else&#123;(代码块3)&#125; 循环结构12345678910111213for x in range(1,5): (代码块)#范围为[1,5)也就是[1,4]#当range写成range(5)的时候范围为[0,5)#默认自加1while x&lt;n: (代码块)#若把x强制类型转换为int类型，写法如下# int(x)#调用int()函数把x转换为int类型#转换为其它类型，有同理操作 成分len(x)函数，可以求x字符串的长度，或x元组/列表…等等的元素数量，等等元组(tuple) 使用小括号声明，指向成员地址不可变。可以使用数组下标访问其中元素s=(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)此时s[0]=’1’，输出时也会自带一对单引号*声明一个元素的元组时，应加上逗号，以区别(1)的数学意义。此时输出也会自动输出逗号*无成员函数s=(&#39;1&#39;,)列表(list) 使用中括号声明，指向成员地址可变。可理解为C++中的数组。可以使用数组下标访问其中元素s=\[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;\]*与元组相比，单个元素不需强调*带有成员函数x.append(y)、x.pop(z)、x.insert(u,v)和x.sort()，其中y是元素，z、u是下标，v是元素。z置空时默认为弹出列表尾部元素u置空时默认为在列表尾部插入元素v字典(dict) 使用大括号声明，声明方法为：s={A1:B1,A2:B2,A3:B3}此时s[A1]=B1，即自定义数组下标及其元素，使用方法同C++的map*具有list所有成员函数*还具有s.get(A1,x)，若在字典s中存在以A1为下标的组合，则返回其对应值B1，否则返回x，当只写s.get(A1)，即忽略x时，x自动设为None。Python不会输出None集合(set) 使用小括号和中括号声明s1=set(\[&#39;1&#39;,&#39;2&#39;\])s2=set(\[&#39;2&#39;,&#39;3&#39;\])*自动筛除重复元素*自带并集、交集操作s1 &amp; s2返回’1’,’2’,’3’s1 | s2返回’2’*成员函数s.add(x)，将x添加进集合s中。*成员函数s.remove(x)，将集合s中的x删除。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P3373 【模板】线段树 2 题解]]></title>
    <url>%2FAnswer%2Fluogu-p3373%2F</url>
    <content type="text"><![CDATA[阅读本篇题解之前，请先完成Luogu P3372。 题目描述如题，已知一个数列，你需要进行下面三种操作： 将某区间每一个数乘上x 将某区间每一个数加上x 求出某区间每一个数的和输入输出格式输入格式：第一行包含三个整数N、M、P，分别表示该数列数字的个数、操作的总个数和模数。第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。接下来M行每行包含3或4个整数，表示一个操作，具体如下：操作1： 格式：1 x y k 含义：将区间[x,y]内每个数乘上k操作2： 格式：2 x y k 含义：将区间[x,y]内每个数加上k操作3： 格式：3 x y 含义：输出区间[x,y]内每个数的和对P取模所得的结果 输出格式：输出包含若干行整数，即为所有操作3的结果。输入输出样例输入样例#1：5 5 381 5 4 2 32 1 4 13 2 51 2 4 22 3 5 53 1 4 输出样例#1：172 说明时空限制：1000ms,128M数据规模：对于30%的数据：N&lt;=8，M&lt;=10对于70%的数据：N&lt;=1000，M&lt;=10000对于100%的数据：N&lt;=100000，M&lt;=100000（数据已经过加强^_^）样例说明：故输出应为17、2（40 mod 38=2） 对比P3372，本题的提升在于，多了对乘法的要求（大家都看见了啊喂）。不过，这一看起来小小的要求，真的要实现的时候，才发现真的难写。果然加了这一条就从P3372的绿题变成蓝题了。在P3372中，区间修改仅要求了加法，因而每次下放lazy标记的时候只需要暴力下放，也就是ans[p]+和tag[p]+。然鹅，在本题中因为多了乘法，lazy标记在下放时就出现了一个问题：先下放加法lazy标记(addtag)还是乘法lazy标记(multag)？答案就是先下放multag，再下放addtag。为什么呢？因为在四则运算中，加法优先级较低，乘法较高，故乘法会影响加法，在下放multag的时候不仅要ans[p]+，还要addtag[p]+，还要multag[p]+（三个p均为同一子结点）。这样，之后在下放addtag的时候才能加出正常数值。还有就是，时刻注意取模。附代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;ll ans[1000010],addtag[1000010],multag[1000010],a[1000010],n,m,ppp;inline ll ls(ll p)&#123; return p&lt;&lt;1;&#125;//同P3372inline ll rs(ll p)&#123; return p&lt;&lt;1|1;&#125;//同P3372inline void push_up(ll p)&#123; ans[p]=(ans[ls(p)]+ans[rs(p)])%ppp;&#125;//注意取模void build(ll p,ll l,ll r)&#123; multag[p]=1;//乘法tag应为1，若为0则造成一旦发生乘法，数值即刻归零 addtag[p]=0;//其余同P3372 if(l==r) &#123; ans[p]=a[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; build(ls(p),l,mid); build(rs(p),mid+1,r); push_up(p);&#125;inline void f(ll p,ll l,ll r,ll addv,ll mulv)&#123; ans[p]=(ans[p]*mulv)%ppp; addtag[p]=(addtag[p]*mulv)%ppp; multag[p]=(multag[p]*mulv)%ppp;//先下放multag ans[p]=(ans[p]+addv*(r-l+1))%ppp; addtag[p]=(addtag[p]+addv)%ppp;//再下放addtag&#125;inline void push_down(ll p,ll l,ll r)&#123; ll mid=(l+r)&gt;&gt;1; f(ls(p),l,mid,addtag[p],multag[p]); f(rs(p),mid+1,r,addtag[p],multag[p]); addtag[p]=0; multag[p]=1;&#125;void add(ll x,ll y,ll l,ll r,ll p,ll k)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; ans[p]=(ans[p]+k*(r-l+1))%ppp; addtag[p]=(addtag[p]+k)%ppp; return; &#125; if(multag[p]!=1||addtag[p]) push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(x&lt;=mid) add(x,y,l,mid,ls(p),k); if(y&gt;mid) add(x,y,mid+1,r,rs(p),k); push_up(p);&#125;void mul(ll x,ll y,ll l,ll r,ll p,ll k)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; ans[p]=(ans[p]*k)%ppp; addtag[p]=(addtag[p]*k)%ppp; multag[p]=(multag[p]*k)%ppp; return; &#125; if(multag[p]!=1||addtag[p]) push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(x&lt;=mid) mul(x,y,l,mid,ls(p),k); if(y&gt;mid) mul(x,y,mid+1,r,rs(p),k); push_up(p);&#125;ll query(ll x,ll y,ll l,ll r,ll p)&#123; ll tmp=0,mid=(l+r)&gt;&gt;1; if(x&lt;=l&amp;&amp;r&lt;=y) return ans[p]%ppp; if(multag[p]!=1||addtag[p]) push_down(p,l,r); if(x&lt;=mid) tmp+=query(x,y,l,mid,ls(p)); if(y&gt;mid) tmp+=query(x,y,mid+1,r,rs(p)); return tmp%ppp;&#125;int main()&#123; ll x,y,t,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;ppp; for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); build(1,1,n); while(m--) &#123; scanf("%lld",&amp;t); switch(t) &#123; case 1: &#123; scanf("%lld %lld %lld",&amp;x,&amp;y,&amp;k); mul(x,y,1,n,1,k); break; &#125; case 2: &#123; scanf("%lld %lld %lld",&amp;x,&amp;y,&amp;k); add(x,y,1,n,1,k); break; &#125; case 3: &#123; scanf("%lld %lld",&amp;x,&amp;y); printf("%lld\n",query(x,y,1,n,1)); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树(Segment Tree)]]></title>
    <url>%2FSegmentTree%2FSegmentTree%2F</url>
    <content type="text"><![CDATA[阅读本文基础知识：二分思想，二叉树，位运算。本文适用于解决Luogu P3372代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;ll ans[1000010],tag[1000010],a[1000010],n,m;//ans为各节点保存值，tag为各节点的lazy标记，a为各节点初始值inline ll ls(ll p)&#123; return p&lt;&lt;1;//求左儿子的编号&#125;inline ll rs(ll p)&#123; return p&lt;&lt;1|1;//求右儿子的编号&#125;inline void push_up(ll p)&#123; ans[p]=ans[ls(p)]+ans[rs(p)];//更新p的保存值为p的左儿子保存值加上p的右儿子保存值&#125;void build(ll p,ll l,ll r)&#123; tag[p]=0;//初始化lazy标记 if(l==r)//递归边界 &#123; ans[p]=a[l];//初始化p的保存值 return; &#125; ll mid=(l+r)&gt;&gt;1; build(ls(p),l,mid);//构建左子树 build(rs(p),mid+1,r);//构建右子树 push_up(p);//求和，作为p的保存值&#125;inline void f(ll p,ll l,ll r,ll k)&#123; ans[p]+=k*(r-l+1);//更新p的保存值为原值加上该区间长度乘以变化量 tag[p]+=k;//更新lazy标记&#125;inline void push_down(ll p,ll l,ll r)&#123; ll mid=(l+r)&gt;&gt;1; f(ls(p),l,mid,tag[p]); f(rs(p),mid+1,r,tag[p]); tag[p]=0;//重置lazy标记&#125;void update(ll x,ll y,ll l,ll r,ll p,ll k)&#123; if(x&lt;=l&amp;&amp;r&lt;=y)//递归边界 &#123; ans[p]+=k*(r-l+1);//更新p的保存值为原值加上该区间长度乘以变化量 tag[p]+=k;//更新lazy标记 return; &#125; push_down(p,l,r);//下放lazy标记 ll mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(x,y,l,mid,ls(p),k);//如果所求区间左端点小于当前区间中点，则所求区间与当前区间的左半区间仍然有重叠，需要更新左子树 if(y&gt;mid) update(x,y,mid+1,r,rs(p),k);//若...（参照左子树说明），更新右子树 push_up(p);//求和&#125;ll query(ll x,ll y,ll l,ll r,ll p)&#123; ll tmp=0,mid=(l+r)&gt;&gt;1; if(x&lt;=l&amp;&amp;r&lt;=y) return ans[p];//递归边界 push_down(p,l,r);//下放lazy标记 if(x&lt;=mid) tmp+=query(x,y,l,mid,ls(p));//若...（参照update里的说明），对左子树求和 if(y&gt;mid) tmp+=query(x,y,mid+1,r,rs(p));//同上，对右子树求和 return tmp;&#125;int main()&#123; ll x,y,k,t; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); build(1,1,n);//建树 while(m--) &#123; scanf("%lld",&amp;t); switch(t) &#123; case 1: &#123; scanf("%lld %lld %lld",&amp;x,&amp;y,&amp;k); update(x,y,1,n,1,k);//更新 break; &#125; case 2: &#123; scanf("%lld %lld",&amp;x,&amp;y); printf("%lld\n",query(x,y,1,n,1));//求值 break; &#125; &#125; &#125; return 0;&#125; 对于递归边界的说明： l==r我们在build函数中，用[l,r]表示一段区间，显然l==r时该区间内只有一个元素，故可以直接返回。所以此处以l==r作为递归边界。 x&lt;=l&amp;&amp;r&lt;=y在此种情况中，[x,y]表示所求区间，[l,r]表示当前通过递归来到的区间。若满足x&lt;=l&amp;&amp;r&lt;=y，则表示[l,r]完全包含于[x,y]内部，此时不论如何二分递归[l,r]，子区间都是完全包含于[x,y]内部的，故可以直接返回。所以此处以x&lt;=l&amp;&amp;r&lt;=y作为递归边界。 给萌新看的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;long long ans[1000010],tag[1000010],a[1000010],n,m;long long ls(long long p)&#123; return p*2;&#125;long long rs(long long p)&#123; return p*2+1;&#125;void push_up(long long p)&#123; ans[p]=ans[ls(p)]+ans[rs(p)];&#125;void build(long long p,long long l,long long r)&#123; tag[p]=0; if(l==r) &#123; ans[p]=a[l]; return; &#125; long long mid=(l+r)/2; build(ls(p),l,mid); build(rs(p),mid+1,r); push_up(p);&#125;void f(long long p,long long l,long long r,long long k)&#123; ans[p]+=k*(r-l+1); tag[p]+=k;&#125;void push_down(long long p,long long l,long long r)&#123; long long mid=(l+r)/2; f(ls(p),l,mid,tag[p]); f(rs(p),mid+1,r,tag[p]); tag[p]=0;&#125;void update(long long x,long long y,long long l,long long r,long long p,long long k)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; ans[p]+=k*(r-l+1); tag[p]+=k; return; &#125; push_down(p,l,r); long long mid=(l+r)/2; if(x&lt;=mid) update(x,y,l,mid,ls(p),k); if(y&gt;mid) update(x,y,mid+1,r,rs(p),k); push_up(p);&#125;long long query(long long x,long long y,long long l,long long r,long long p)&#123; long long tmp=0,mid=(l+r)/2; if(x&lt;=l&amp;&amp;r&lt;=y) return ans[p]; push_down(p,l,r); if(x&lt;=mid) tmp+=query(x,y,l,mid,ls(p)); if(y&gt;mid) tmp+=query(x,y,mid+1,r,rs(p)); return tmp;&#125;int main()&#123; long long x,y,k,t; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); build(1,1,n); while(m--) &#123; scanf("%lld",&amp;t); switch(t) &#123; case 1: &#123; scanf("%lld %lld %lld",&amp;x,&amp;y,&amp;k); update(x,y,1,n,1,k); break; &#125; case 2: &#123; scanf("%lld %lld",&amp;x,&amp;y); printf("%lld\n",query(x,y,1,n,1)); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>SegmentTree</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年2/3月月赛 Day2 愤怒的瓦里安 题解]]></title>
    <url>%2FAnswer%2Fyxyz201802-0203%2F</url>
    <content type="text"><![CDATA[2018年2/3月月赛 Day2 愤怒的瓦里安 题解 题目描述传奇国王，暴风城主瓦里安·乌瑞恩的儿子安度因又跑到酒馆里和人打牌，还用的是十分肮脏的套牌（脏牧去死啦）。瓦里安听了十分愤怒，掰了筷子就杀了过去。安度因十分慌张，连忙找一起打牌的萨尔帮忙。充满绿色能量的萨尔答应帮安度因破坏一条道路来帮他开溜。但是智商为0的安度因并不知道到底能拖延多长时间。好吧，你写个程序帮他算算咯。（已知萨尔的智商很高，破坏的道路能最大程度上拖延瓦里安的到来） 输入输出格式输入格式第一行有两个用空格隔开的数n和m，分别表示道路节点的数量以及道路的数量。道路节点用数字1至n标识，瓦里安的出发地暴风城在节点1，安度因打牌的酒馆在节点n。接下来的m行中每行包含三个用空格隔开的数u，v和w。这些数字表示在节点u和节点v中间有一条道路，并且花费w的时间通过。 输出格式输出瓦里安到达酒馆所需要的最短时间。 输入输出样例输入样例#1：10 141 2 71 9 107 9 17 3 132 3 22 4 152 8 65 9 74 8 38 5 16 8 35 6 206 10 55 10 60 输出样例#1：74 说明对于100%的数据，1&lt;=n&lt;=1000，1&lt;=m&lt;=n*(n-1)/2，1&lt;=u,v&lt;=n，1&lt;=w&lt;=1000。对于本样例，原本走1-&gt;2-&gt;8-&gt;6-&gt;10为最短路，时间为21。但萨尔破坏了6-&gt;10的路径，使得最短路变为了1-&gt;2-&gt;8-&gt;5-&gt;10，时间变为74。可以证明破坏其它道路时所得到的最短路径长度均小于本方案。 通过题意可初步分析为最短路问题的变种，且有明确的起点和终点，又数据较大，故必然使用广搜。分析题意后可知，可以枚举所有边，逐一删除，再寻找最短路。但边数巨大，逐一枚举必然超时，故采用优化方法：先计算不删边的最短路，并记录该路径，之后枚举该路径上每条边，进行逐一删除，计算，恢复的过程，取最短路最大值即可。此处不证明该算法的正确性。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int e[1010][1010]=&#123;0&#125;,ans[1010]=&#123;0&#125;,v[1010]=&#123;0&#125;,f[1010]=&#123;0&#125;,maxn=0,n,m;queue&lt;int&gt;q;void bfs()&#123; while(!q.empty()) q.pop(); memset(v,0,sizeof(v)); memset(ans,0,sizeof(ans)); v[1]=1; q.push(1); while(!q.empty()) &#123; int st=q.front(); q.pop(); v[st]=0; for(int i=2;i&lt;=n;i++) &#123; int p=0; if(e[st][i]&amp;&amp;(!ans[i]||ans[i]&gt;ans[st]+e[st][i])) ans[i]=ans[st]+e[st][i],p=1; if(p&amp;&amp;!v[i]) q.push(i),v[i]=1; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); scanf("%d",&amp;e[a][b]); e[b][a]=e[a][b]; &#125; v[1]=1; q.push(1); while(!q.empty()) &#123; int st=q.front(); q.pop(); v[st]=0; for(int i=2;i&lt;=n;i++) &#123; int p=0; if(e[st][i]&amp;&amp;(!ans[i]||ans[i]&gt;ans[st]+e[st][i])) ans[i]=ans[st]+e[st][i],p=1,f[i]=st; if(p&amp;&amp;!v[i]) q.push(i),v[i]=1; &#125; &#125; int t=n,tmp,temp; while(t!=1) &#123; tmp=f[t]; temp=e[t][tmp]; e[t][tmp]=e[tmp][t]=0; bfs(); e[t][tmp]=e[tmp][t]=temp; if(ans[n]&gt;maxn) maxn=ans[n]; t=f[t]; &#125; cout&lt;&lt;maxn; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年2/3月月赛 Day2 石化 题解]]></title>
    <url>%2FAnswer%2Fyxyz201802-0202%2F</url>
    <content type="text"><![CDATA[2018年2/3月月赛 Day2 石化 题解 题目背景漫长战斗终于分出胜负了。“喂，我可没听说非拼成这样才赢得了。”七道亡国级禁咒，十一把开刃到自毁程度的帕西瓦尔系列，甚至青年本身没资格动用的勇者剑技最终奥义都已经强行祭出。假如这样还不能将其灭绝，也无计可施了。「真是惊天动地啊。身为无力的凡人之躯，却能独自使出此等力量吗？实在可怕。不过，看来要发挥那样的力量，实在不可能毫无代价。」“啪”的一声，青年脚踝前面的部分已经变成粗糙的石块了。又是好几声脆响重叠在一起，灰色面积开始沿着他的身体往上蔓延扩散，到了膝盖，到了腿，到了腰，还在继续往上。 题目描述威廉即将在t个单位时间内完全石化，现在他对往事无限怀念，希望尽可能多的想起重要的人。威廉有n个重要的人，而每个单位时间里他同时只能想一个人。在此时此刻，回想第i个重要的人有关的事情都要消耗p[i]的时间，且只有时间p[i]完全经过才算确实回想起这个人。威廉该按什么顺序回想，才能尽可能多的回顾和重要的人经历的事情呢？ 输入输出格式输入格式第一行，包含两个正整数t,n。接下来n行，每行包含一个字符串和一个正整数p[i]。其中字符串表示第i个重要的人的姓名。 输出格式输出按最佳回想顺序能想起的人数。 输入输出样例输入样例#1：5 3Ri-ria 3Naiguranto 5Arumaria 2 输出样例#1：2 输入样例#2：10 5Chtholly 2Nephren 5Ithea 3Rhantolk 6Lakhesh 4 输出样例#2：3 说明每个字符串均不超过50个字符。对于100%的数据，1&lt;=t&lt;=10000000,1&lt;=n&lt;=500000,1&lt;=p[i]&lt;=1000。 通过题目中描述，可知姓名是无用参数，不需保存处理；且仅有时间一种属性，可定性为dp的特例：贪心。当然用dp做也可以得出正解。贪心做法：sort之后从小到大开始算。dp做法：同背包问题。代码：123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;char s[50];int a[500000],sum=0;int main()&#123; int t,n,i,j; scanf("%d%d",&amp;t,&amp;n); for(i=0;i&lt;n;i++) scanf("%s %d",s,&amp;a[i]); sort(a,a+n); for(i=0;i&lt;n;i++) &#123; t-=a[i]; if(t&lt;0) &#123; if(!i) printf("0"); break; &#125; sum++; &#125; if(i) printf("%d",sum); return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>背包dp</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年2/3月月赛 Day2 被7整除 题解]]></title>
    <url>%2FAnswer%2Fyxyz201802-0201%2F</url>
    <content type="text"><![CDATA[2018年2/3月月赛 Day2 被7整除 题解 题目描述输出从1~n有多少个整数满足2^n-n^2能被7整除。 输入输出格式输入格式一行，包含一个整数n。 输出格式一行，包含一个整数x，表示从1~n有x个整数满足2^n-n^2能被7整除。 输入输出样例输入样例#1：2 输出样例#1：1 输入样例#2：4 输出样例#2：2 说明对于100%的数据，1&lt;=n&lt;=1000000。 定性为数论题。通过打表可发现有周期为21的规律。只能打表自行找规律，没有别种办法。找不出规律也可暴力，不过会超时。代码：12345678910111213#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define ll long longint main()&#123; int num[30]=&#123;0,0,1,1,2,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,6&#125;; int n; cin&gt;&gt;n; int k=n/21,q=n%21; cout&lt;&lt;k*6+num[q]; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年2/3月月赛 Day1 胜利大逃亡 题解]]></title>
    <url>%2FAnswer%2Fyxyz201802-0103%2F</url>
    <content type="text"><![CDATA[原题，不再赘述。详见本链接]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年2/3月月赛 Day1 疯狂的机器人 题解]]></title>
    <url>%2FAnswer%2Fyxyz201802-0102%2F</url>
    <content type="text"><![CDATA[2018年2/3月月赛 Day1 疯狂的机器人 题解 题目描述MH：“前几个月给一个机器人写了段代码，发现它只能往两个方向走，不能回退，而且还是随机的，真是无语…”CL：“我看你也够随机的，最后那家伙竟然疯了一样，在上下左右四个方向乱走了，可真是吓死我了”MH：“是啊是啊。我记下了它当时的所在的地图，希望能找到它最远可能从哪里来的”还是机智的你，知道这个机器人最远可能从哪里来的吗？ 输入输出格式输入格式第一行两个正整数n,m，表示机器人所在地图的规模。第2行到第n+1行，每行m个数字，分别是0,1,-1三种之一。其中，0表示可以行走的路，1表示墙壁，-1表示机器人所在的坐标。 输出格式一行，包含一个数字。若能有最远可到达的地方，输出该距离，否则输出0。 输入输出样例输入样例#1：4 51 0 0 0 10 1 0 1 01 1 0 1 00 -1 0 0 0 输出样例#1：5 输入样例#2：4 51 0 0 0 10 1 0 1 01 1 0 1 00 0 1 -1 0 输出样例#2：3 说明对于100%的数据，1&lt;=n,m&lt;=50。 定性为搜索题，搜索所有点中到起点走最短路仍最远的地方，也就是求起点到所有点的最短距离的最大值。此处采用dfs。使用bfs的话需要有明确的终点，而本题没有固定终点，因此不适合bfs。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,m,final=0,d[60][60],ans[60][60]=&#123;0&#125;,stx,sty;void dfs(int x,int y)&#123; for(int i=x-1;i&lt;=x+1;i++) &#123; if(i&lt;0||i&gt;=n) continue; for(int j=y-1;j&lt;=y+1;j++) &#123; if(j&lt;0||j&gt;=m) continue; if(i==stx&amp;&amp;j==sty) continue; if(i==x&amp;&amp;y==j) continue; if(i!=x&amp;&amp;y!=j) continue; if(d[i][j]) continue; int &amp;t=ans[i][j]; if(!t||(t&amp;&amp;t&gt;ans[x][y]+1)) &#123; t=ans[x][y]+1; dfs(i,j); &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;d[i][j]; if(d[i][j]==-1) &#123; stx=i; sty=j; &#125; &#125; &#125; dfs(stx,sty); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(final&lt;ans[i][j]) final=ans[i][j]; cout&lt;&lt;final; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年2/3月月赛 Day1 行军（改） 题解]]></title>
    <url>%2FAnswer%2Fyxyz201802-0101%2F</url>
    <content type="text"><![CDATA[2018年2/3月月赛 Day1 行军（改） 题解 题目背景再过十几天，人类远征军就要出发去讨伐星神(visitor)了。正规勇者莉莉娅·阿斯普雷伊及一众准勇者们正在为行军问题而焦头烂额。“这么多的粮草，还有那么远的路，这该怎么办啊？”莉莉娅抱怨道。你能帮帮莉莉娅吗？ 题目描述从皇都到达星神居住地，这之间有无数座城市和无数条道路，将会消耗很多时间。而为了保证军士们的生活，需要带上足够的粮草。皇都共有n堆粮草可供选择，每堆粮草有重量p，体积q和价值w，而为了便于行军，莉莉娅只能选择不超过u重量且不超过v体积的粮草带走。 输入输出格式输入格式第一行，包含三个正整数，分别为粮草数量n,最大载重量u,最大体积v。接下来n行，每行包含三个正整数p[i]、q[i]和w[i]。第i+1行的p[i]表示第i堆粮草的重量，q[i]表示第i堆粮草的体积，w[i]表示第i堆粮草的价值。 输出格式一行，输出能载的粮草的最大价值。 输入输出样例输入样例#1：6 10 101 1 12 3 13 2 12 5 15 2 14 3 1 输出样例#1：4 输入样例#2：10 16 242 9 45 6 53 7 36 2 97 6 57 5 63 3 81 4 19 5 99 7 6 输出样例#2：26 说明1&lt;=n&lt;=1000,1&lt;=u&lt;=1000,1&lt;=v&lt;=1000所有数据不大于maxint 非常简单的一个二维约束的背包问题。解题方法详见这里数据较大，最好scanf输入。代码：123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,u,v;int p[1010],q[1010],w[1010],f[1010][1010]=&#123;0&#125;;int main()&#123; int i,j,k; cin&gt;&gt;n&gt;&gt;u&gt;&gt;v; for(i=1;i&lt;=n;i++) scanf("%d%d%d",&amp;p[i],&amp;q[i],&amp;w[i]); for(i=1;i&lt;=n;i++) &#123; for(j=u;j&gt;=p[i];j--) &#123; for(k=v;k&gt;=q[i];k--) &#123; int temp=f[j-p[i]][k-q[i]]+w[i]; if(f[j][k]&lt;temp) f[j][k]=temp; &#125; &#125; &#125; cout&lt;&lt;f[u][v]; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>背包dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题专项]]></title>
    <url>%2Fknapsack-dp%2Fknapsack%2F</url>
    <content type="text"><![CDATA[背包问题专项 01背包问题每种物品只能拿一个的问题称为01背包问题。对于一维约束的情况，先正向枚举数量，再反向枚举约束条件。核心代码：1234for(int i=1;i&lt;=n;i++) for(int j=m;j&gt;=v[i];j--) if(!ans[j]||ans[j]&gt;ans[j-v[i]]+w[i]) ans[j]=ans[j-v[i]]+w[i]; 上述代码中设n为数量，m为最大重量，v[i]为第i个物品重量，w[i]为第i个物品价值。对于二维约束的情况，只需要改用二维数组，并再加一个for即可。核心代码：12345for(int i=1;i&lt;=n;i++) for(int j=m;j&gt;=v[i];j--) for(int k=u;k&gt;=p[i];k--) if(!ans[j][k]||ans[j][k]&gt;ans[j-v[i]][k-p[i]]+w[i]) ans[j][k]=ans[j-v[i]][k-p[i]]+w[i]; 上述代码中设n为数量，m为最大重量，u为最大体积，v[i]为第i个物品重量，p[i]为第i个物品体积，w[i]为第i个物品价值。对于更多维约束条件，可参照二维约束外推。 完全背包问题每种物品可以拿无限个的问题称为完全背包问题。对于一维约束的情况，先正向枚举数量，再正向枚举约束条件。（01背包是反向枚举约束条件）核心代码：1234for(int i=1;i&lt;=n;i++) for(int j=v[i];j&lt;=m;j++) if(!ans[j]||ans[j]&gt;ans[j-v[i]]+w[i]) ans[j]=ans[j-v[i]]+w[i]; 上述代码中设n为数量，m为最大重量，v[i]为第i个物品重量，w[i]为第i个物品价值。对于二维约束的情况，只需要改用二维数组，并再加一个for即可。核心代码：12345for(int i=1;i&lt;=n;i++) for(int j=v[i];j&lt;=m;j++) for(int k=p[i];k&lt;=u;k++) if(!ans[j][k]||ans[j][k]&gt;ans[j-v[i]][k-p[i]]+w[i]) ans[j][k]=ans[j-v[i]][k-p[i]]+w[i]; 上述代码中设n为数量，m为最大重量，u为最大体积，v[i]为第i个物品重量，p[i]为第i个物品体积，w[i]为第i个物品价值。对于更多维约束条件，可参照二维约束外推。 多重背包问题01背包问题是每种物品只能拿一个，完全背包问题是每种物品可以拿无限个，而多重背包就是每种物品可以取一个或多个，但绝对是有限个，不可能无限取。解决此类问题，只需把每种物品拆成单个即可。如第i种物品有j个，单个重量为v[i]，价值为w[i]，那就可以拆分成j的单个重量为v[i]，价值为w[i]的物品。拆单之后，即可使用01背包问题的解法来解决。 混合三种背包问题顾名思义，混合三种背包问题就是以上三种的混合。每种物品既可能只有1个，又可能有多个，还可能有无数个。对于该类问题，先按多重背包问题的解法，将有多个的物品全部拆单，使得混合三种背包问题简化为01背包和完全背包的混合；再正向枚举每件物品，按每件物品所属性质不同而决定采用正向枚举约束条件还是反向。核心代码：12345678910111213for(int i=1;i&lt;=n;i++) if(f[i]==1) &#123; for(int j=m;j&gt;=v[i];j--) if(!ans[j]||ans[j]&gt;ans[j-v[i]]+w[i]) ans[j]=ans[j-v[i]]+w[i]; &#125; else &#123; for(int j=v[i];j&lt;=m;j++) if(!ans[j]||ans[j]&gt;ans[j-v[i]]+w[i]) ans[j]=ans[j-v[i]]+w[i]; &#125; 上述代码中设n为数量，m为最大重量，v[i]为第i个物品重量，w[i]为第i个物品价值，f[i]=1表示第i个物品属于01背包，否则属于完全背包。对于二维约束的情况，只需要改用二维数组，并再加一个for即可。核心代码：123456789101112131415for(int i=1;i&lt;=n;i++) if(f[i]==1) &#123; for(int j=m;j&gt;=v[i];j--) for(int k=u;k&gt;=p[i];k--) if(!ans[j][k]||ans[j][k]&gt;ans[j-v[i]][k-p[i]]+w[i]) ans[j][k]=ans[j-v[i]][k-p[i]]+w[i]; &#125; else &#123; for(int j=v[i];j&lt;=m;j++) for(int k=p[i];k&lt;=u;k++) if(!ans[j][k]||ans[j][k]&gt;ans[j-v[i]][k-p[i]]+w[i]) ans[j][k]=ans[j-v[i]][k-p[i]]+w[i]; &#125; 上述代码中设n为数量，m为最大重量，u为最大体积，v[i]为第i个物品重量，p[i]为第i个物品体积，w[i]为第i个物品价值，f[i]=1表示第i个物品属于01背包，否则属于完全背包。对于更多维约束条件，可参照二维约束外推。]]></content>
      <categories>
        <category>knapsack-dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>knapsack-dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P1126 机器人搬重物 题解]]></title>
    <url>%2FAnswer%2Fluogu-p1126%2F</url>
    <content type="text"><![CDATA[Luogu P1126 机器人搬重物 题解 题目描述机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径1.6米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个N*M的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：向前移动1步（Creep）；向前移动2步（Walk）；向前移动3步（Run）；向左转（Left）；向右转（Right）。每个指令所需要的时间为1秒。请你计算一下机器人完成任务所需的最少时间。 输入输出格式输入格式输入的第一行为两个正整数N,M（N,M&lt;=50），下面N行是储藏室的构造，0表示无障碍，1表示有障碍，数字之间用一个空格隔开。接着一行有四个整数和一个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东E，南S，西W，北N），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。 输出格式一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出-1。 输入输出样例输入样例#1：9 100 0 0 0 0 0 1 0 0 00 0 0 0 0 0 0 0 1 00 0 0 1 0 0 0 0 0 00 0 1 0 0 0 0 0 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 1 0 0 0 00 0 0 1 1 0 0 0 0 00 0 0 0 0 0 0 0 0 01 0 0 0 0 0 0 0 1 07 2 2 7 S 输出样例#1：12 本题思路不难，无非就是广搜的一步变成123步或者转向而已，麻烦的是对地图的理解……本人写的时候卡了2小时在地图的处理，然后才A掉。还有坑点，就是起点可能和终点重合，需要特判。对地图的理解：一开始我采用了化格子为点的做法，先弄个可行点地图再搞，然而WA了，只好换。后来我用的就是AC的做法，在图上制造虚空点，每个点四周的4个格子都得是0才能通过，只要有一个是1就过不了。附代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;struct node&#123; int x,y,face; friend bool operator ==(const node a,const node b) &#123; if(a.x!=b.x) return false; if(a.y!=b.y) return false; if(a.face!=b.face) return false; return true; &#125;&#125;st,di,fx[4];queue&lt;node&gt;q;char dire;int n,m,ans[60][60]=&#123;0&#125;;bool d[60][60]=&#123;false&#125;,v[60][60][4]=&#123;false&#125;;void spfa()&#123; int &amp;sum=ans[di.x][di.y]; q.push(st); v[st.x][st.y][st.face]=true; while(!q.empty()) &#123; node t=q.front(); q.pop(); v[t.x][t.y][t.face]=false; for(int i=0;i&lt;4;i++) &#123; int ti; node tmp=t; tmp.face=i; if(tmp.face+t.face==3) ti=2; else if(tmp.face==t.face) ti=0; else ti=1; ti++; for(int j=0;j&lt;3;j++) &#123; tmp.x+=fx[i].x; tmp.y+=fx[i].y; if(tmp.x&lt;1||tmp.y&lt;1||tmp.x&gt;=n||tmp.y&gt;=m) break; if(d[tmp.x][tmp.y]||d[tmp.x-1][tmp.y]||d[tmp.x][tmp.y-1]||d[tmp.x-1][tmp.y-1]) break; if(tmp.x==st.x&amp;&amp;tmp.y==st.y) continue; int temp=ans[t.x][t.y]+ti; if(sum&amp;&amp;temp&gt;=sum) break; if(!ans[tmp.x][tmp.y]||temp&lt;ans[tmp.x][tmp.y]) &#123; ans[tmp.x][tmp.y]=temp; if(!v[tmp.x][tmp.y][tmp.face]) &#123; v[tmp.x][tmp.y][tmp.face]=true; q.push(tmp); &#125; &#125; &#125; &#125; &#125;&#125;void set()&#123; fx[0].x=-1,fx[0].y=0; fx[1].x=0,fx[1].y=-1; fx[2].x=0,fx[2].y=1; fx[3].x=1,fx[3].y=0; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf("%d",&amp;d[i][j]); cin&gt;&gt;st.x&gt;&gt;st.y&gt;&gt;di.x&gt;&gt;di.y&gt;&gt;dire; if(dire=='N') dire=0; else if(dire=='W') dire=1; else if(dire=='E') dire=2; else if(dire=='S') dire=3; di.face=st.face=dire;&#125;int main()&#123; set(); if(st==di) &#123; cout&lt;&lt;0; return 0; &#125; spfa(); if(ans[di.x][di.y]) cout&lt;&lt;ans[di.x][di.y]; else cout&lt;&lt;-1; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ノーゲームノーライフ ゼロ 观影体验]]></title>
    <url>%2Fothers%2F20180311%2F</url>
    <content type="text"><![CDATA[「向遗志起誓」 啊啊，怎么说呢，算是从寒假开始就想看了吧。但是拖到这周周二才把动画本编补完，小说也堪堪起步。本来昨天就打算腾出2小时的时间来看的，但是林林总总事情不少（详见上一篇文章），于是便拖到了今天。再加上我妹这两天体调不佳，于是便与她一起，下午用2小时（她没看过本编要我慢慢解释）的时间看完了该剧场版。唉，最后和她抱在一起痛哭，真是看得难过啊，导致我花了很大精神才安顿好她，自己回来后也心情不佳。那么，以下有剧透，未看过的各位请慎重往下看。这是未看过小说，仅看过动画本编的人，的视角。 故事开始便是男主利库（人类）被毁了家乡，然后与女主休比（机凯种）远距离相看见。这该是最初的相遇了，也与后面女主自称是毁了男主家乡的罪魁祸首相呼应。之后开始解释本片视角，原来是唯一神特图在向兽人种的伊纲陈述这个故事，这个发生在6000年前，悠久大战终结之时的故事。叙述的开篇，利库等3人遇到了地精种的特殊设备，在记录过程中却有危险来临，不得不命令一人去死。回据点后，该死去的人是一个萝莉的父亲，利库遭到了萝莉的怨恨发言，回屋后自己也是很难过，在为自己的无能而发怒。之后，利库在探险过程中偶然来到森精种旧都（就是被吉普莉尔一个天击毁掉的地方），在这里发生了男女主第一次正式相遇。结果刚一相遇就爆发了重大糟糕台词啊2333，有兴趣的请自行观看，太糟糕了不便透露。然后休比申请对局（结果当然输了），于是被利库带回人类据点。然后又是一堆污的事情……不对，是休比向利库陈述了自己的目的——了解「心」。接下来有一起洗澡，呸，是利库给休比擦澡。期间利库的姐姐进了房间，发现了一根休比遗留的头发，扯不断。此时姐姐应该已经发现休比是机凯种了。三个字，瞬间一年后。利库和休比一同前往相遇的地方，在那里却遭遇了森精种研发的「虚空第零加护」，休比被打中，之后却复制了该招式接近10%的威力打破了关上的门成功和利库一起逃出。然后就是卿卿我我的狗粮，期间利库也渐渐打开内心。回据点之后利库开始和休比研究地图，企图搞点大新闻。好景不长，在地精种对龙精种的攻击中，人类受到了波及。结果利库还趁机套路了一把他姐姐，真是这种时候还有这种闲心啊2333利库把首领大位交给姐姐后，开始和其他人谋划「幽灵」行动，引导上位种族休战，并引导其在指定地点开战，计划利用32个『典开』「通行规制」把能量引导到贯穿星球，然后利库取得「星杯」来结束这场悠久之战。宣布完此事，本片开始最后一段不虐的狗粮——利库向休比求婚了！求婚了！！！然后利库向兽人种透露了地精种拥有「水爆」的事情，又去森精种那里下棋，故意输掉讨取情报。但为了不被森精种发现自己是人类，用了很多「黑灰」来掩盖自己的精灵回廊气息，让森精种的克莱布误以为自己是上位种族，不敢贸然动武。顺利讨取情报后，利库却因黑灰在身上过久而被侵染严重，不得不截肢了。在临时营地里利库过于劳累晕倒了，醒来后休比依旧劝他休息，一来二去利库就睡了。这是利库和休比的永别。高虐开始。休比为了节约时间，一个人去设置『典开』「通行规制」，结果只设置了一个（目前共24个）就被吉普莉尔发现了，打了起来，休比不敌，开始申请和连接体同步数据，却一直被驳回，隔了好一会才被接受了。于是休比开大，立志坚持251秒到同步结束。最终还是被吉普莉尔打爆了，在最后关头同步完成，休比被「天击」秒了。这段别看我简单描述过去了，其实是因为太虐了！！！简直就是吉普莉尔掉粉时间啊！！！高虐！！！因为休比挂了，利库也十分难受，要自杀的时候，机凯种中连接体的一员来到利库面前，声明剩余8个不可能设置完成，请求修正策略。利库做出了决定。机凯种在僵持之处模仿天翼种使用「天击」诱发各方全弹发射，并成功引导能量偏移。机凯种使用第十一连接体全员4807体承接了这股能量，并将其同步给利库所在的『真典』「弑星者」，成功贯穿星球，使得星杯显现，利库的身体却因消耗过度了，被星杯周围的黑灰所侵蚀，不能靠近。绝望之下利库只得祈祷，人生第一次，也是最后的祈祷，祈祷游戏之神能现身取得星杯。最终的最终，游戏之神因为利库的信仰而成形，取得星杯，成为唯一神，重塑世界。这段也是巨虐啊！啊，到此为止了，真是让我和我妹都哭惨了。向全体机凯种致以最高的敬意。 以下是部分个人感想吧。利库和休比，怎么看都是空白的前世啊。（虽然作者说不是不过不瞎都能看出来吧）想看动画第二季啊，也想补小说，但是作业还没写完，还是省省吧2333好，到此为止吧。 「向盟约起誓」]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20180310 随录]]></title>
    <url>%2Fdiary%2F20180310%2F</url>
    <content type="text"><![CDATA[今日早上8点起床了。哎呀，前一天是真的累，结果还折腾到快1点，所以早上不得不睡到8点再起来了。然后日常，吃完饭后就去公寓305准备面试了。结果到场才不到8点40分，只有lyh在场，又等了很久才等到游神等。9点就开始面试了。我还是第一个啊2333被问了基础、时间安排，甚至还有梦想之类的xs然后9点5分就出来了，发生了一点小意外——居然碰到了自主招生的时候同组的同学，不仅面试同组体测也同组的xsj同学。他现在在信科。机缘巧合之下居然在之前就加好了qq。他还高呼“原来cgp就是你啊”。缘分啊缘分。之后回寝室，居然忘记充电了，结果60多的电到中午2点多点就没电了哭哭。10点多和wise相约一起去前一天和同年几位约好的芙蓉湖小广场，结果发现哇游客真的多，周六周日恐怖如斯。之后等几位，陈总没空来，一盆基本上踩点，之后是琛，再是弘哥。然后说人太多了，于是先去吃饭。出了西村校门，来到富万邦，然后决定吃杨国福。但是好像没什么东西能吃啊，还不如云霄的，随便点点21块就完了。然后去未开放的南校门（不同于大南校门），但是没地方摆手机，于是又前往化院校门，进去一看是上弦场的一边（另一边靠白城）。真是打开了新世界的大门。然后在上弦场的中轴线录像，录了一会，聊了会天，wise就去做家教了。剩下的我们就去经院咖啡厅休息，我还点了卡布奇诺，15块啊。不过总算明白经院咖啡厅怎么识别同学和游客了——只能校园卡支付，不支持其它方式。啊，3点多就各自散了，4点刚过的时候到了寝室，然后休息，一不小心就5点半多了，去二期吃晚饭，紫菜汤好料啊，还有辣包菜。晚上就休闲了，也没什么大事，摸了。]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P1388 算式 题解]]></title>
    <url>%2FAnswer%2Fluogu-p1388%2F</url>
    <content type="text"><![CDATA[Luogu P1388 算式 题解 题目描述给出N个数字，不改变它们的相对位置，在中间加入K个乘号和N-K-1个加号，（括号随便加）使最终结果尽量大。因为乘号和加号一共就是N-1个了，所以恰好每两个相邻数字之间都有一个符号。例如：N=5, K=2，5个数字分别为1、2、3、4、5，可以加成：1*2*(3+4+5)=241*(2+3)*(4+5)=45(1*2+3)*(4+5)=45…… 输入输出格式输入格式输入文件共有二行，第一行为两个有空格隔开的整数，表示N和K，其中(2&lt;=N&lt;=15, 0&lt;=K&lt;=N-1)。第二行为 N个用空格隔开的数字（每个数字在0到9之间）。 输出格式输出文件仅一行包含一个整数，表示要求的最大的结果最后的结果&lt;=maxlongint 输入输出样例输入样例#1：5 21 2 3 4 5 输出样例#1：120 如果可以改变顺序，一个最大堆就解决了。奈何不能改变相对顺序，于是采用dp。用ans[i][j]表示在前i个数的序列中插入j个乘号的最优解。由于乘号和加号数量之和为n-1，所以当乘号数量确定后，加号数量也唯一确定。之后可以发现，因为不能改变顺序，所以在前i个数中插入乘号后，剩下的连续序列必然相加。故有状态转移方程：1ans[i][j]=max(ans[i][j],ans[t][j-1]*(a[i]-a[t])) 其中t表示前i个数中某个小于i的位置，ans[t][j-1]表示在前i个数构成的序列中的一段由前t个数构成的子序列里插入j-1个乘号的最优解。附代码1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int n,k,a[20],ans[20][20]=&#123;0&#125;; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; if(i-1) a[i]+=a[i-1]; ans[i][0]=a[i]; &#125; for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;=min(k,i-1);j++) for(int t=j;t&lt;i;t++) ans[i][j]=max(ans[i][j],ans[t][j-1]*(a[i]-a[t])); cout&lt;&lt;ans[n][k]; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>dp</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P2085 最小函数值 题解]]></title>
    <url>%2FAnswer%2Fluogu-p2085%2F</url>
    <content type="text"><![CDATA[Luogu P2085 最小函数值 题解 题目描述有n个函数，分别为F1,F2,…,Fn。定义Fi(x)=Ai*x^2+Bi*x+Ci (x∈N*)。给定这些Ai、Bi和Ci，请求出所有函数的所有函数值中最小的m个（如有重复的要输出多个）。 输入输出格式输入格式第一行输入两个正整数n和m。以下n行每行三个正整数，其中第i行的三个数分别位Ai、Bi和Ci。Ai&lt;=10，Bi&lt;=100，Ci&lt;=10 000。 输出格式输出将这n个函数所有可以生成的函数值排序后的前m个元素。这m个数应该输出到一行，用空格隔开。 输入输出样例输入样例#1：3 104 5 33 4 51 7 1 输出样例#1：9 12 12 19 25 29 31 44 45 54 说明数据规模：n,m&lt;=10000 方案1：暴力枚举。数据小了能过，但是肯定会T几个点。方案2：采用最小堆。 保存每个函数的fi(1)值为sum，num为fi(x)中的i，step为fi(x)中的x。全部入队。 每次取队首元素，保存为t，然后pop()。 输出t.sum（此时已经是最小），t.step++（自变量+1），t.sum=a[t.num]t.stept.step+b[t.num]*t.step+c[t.num];（求值），push(t); 重复，直到执行了m次。 值得注意的是，此处采用了自定义类型，但普通优先队列并不支持自定义类型，只支持基本类型。此时需要重载运算符。1friend bool operator&lt;(const rbq u,const rbq o)&#123;return u.sum&gt;o.sum;&#125; 附代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;struct rbq&#123; int num,sum,step; friend bool operator&lt;(const rbq u,const rbq o)&#123;return u.sum&gt;o.sum;&#125;&#125;t;priority_queue&lt;rbq&gt;q;int n,m,a[10010],b[10010],c[10010];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; scanf("%d %d %d",&amp;a[i],&amp;b[i],&amp;c[i]); t.num=i;t.sum=a[i]+b[i]+c[i];t.step=1; q.push(t); &#125; while(m--) &#123; t=q.top(); q.pop(); cout&lt;&lt;t.sum&lt;&lt;" "; t.step++; t.sum=a[t.num]*t.step*t.step+b[t.num]*t.step+c[t.num]; q.push(t); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU P1253 胜利大逃亡 题解]]></title>
    <url>%2FAnswer%2Fhdu-p1253%2F</url>
    <content type="text"><![CDATA[HDU P1253 胜利大逃亡 题解卡常数神题 Problem DescriptionIgnatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会.魔王住在一个城堡里,城堡是一个A*B*C的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个.现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1. Input输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表城堡的大小和魔王回来的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块……),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.(如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫)特别注意:本题的测试数据非常大,请使用scanf输入,我不能保证使用cin能不超时.在本OJ上请使用Visual C++提交. Output对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1. Sample Input13 3 4 200 1 1 10 0 1 10 1 1 11 1 1 11 0 0 10 1 1 10 0 0 00 1 1 00 1 1 0 Sample Output11 从50*50*50的范围来看，显然dfs是不现实的，故采用bfs。那既然都用bfs了，当然是祭出spfa大法。本题最大坑点在于，要么高度耦合，要么要内联，总之就是常数要优化到极致，不然就T，果断T。说明已附在code里。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;queue&lt;int&gt;qa,qb,qc;bool d[60][60][60],v[60][60][60];int ans[60][60][60],k,a,b,c,t;//50*50*50，故开60*60*60 inline void add(int aa,int bb,int cc)&#123; qa.push(aa); qb.push(bb); qc.push(cc);//入队 v[aa][bb][cc]=true;//标记已用 &#125;inline void cut(int aa,int bb,int cc)&#123; qa.pop(); qb.pop(); qc.pop();//出队 v[aa][bb][cc]=false;//取消标记 &#125;inline bool check(int aa,int bb,int cc,int sum)&#123; if(!aa&amp;&amp;!bb&amp;&amp;!cc) return false;//1、不是起点 if(aa&lt;0||bb&lt;0||cc&lt;0) return false;//2、不能向下越界 if(aa&gt;=a||bb&gt;=b||cc&gt;=c) return false;//3、不能向上越界 if(v[aa][bb][cc]) return false;//4、不能是已经使用过的点 if(d[aa][bb][cc]) return false;//5、不能是墙 int tmp=ans[aa][bb][cc]; if(tmp&amp;&amp;sum&gt;=tmp) return false;//6、目前计算所得值必须比已有最优解更优，否则走人 return true;//都通过了，合格了 &#125;inline void direct(int aa,int bb,int cc,int sum)&#123; if(!check(aa,bb,cc,sum)) return;//如果不可行，不再计算 ans[aa][bb][cc]=sum;//更新值 if(!(aa==a-1&amp;&amp;bb==b-1&amp;&amp;cc==c-1)) add(aa,bb,cc);//如果被更新点不是终点，入队 &#125;void spfa()&#123; while(!qa.empty())//当队列非空 &#123; int ta=qa.front(),tb=qb.front(),tc=qc.front();//取值 cut(ta,tb,tc);//出队 int sum=ans[ta][tb][tc]+1;//计算当前最优解 direct(ta-1,tb,tc,sum); direct(ta+1,tb,tc,sum); direct(ta,tb-1,tc,sum); direct(ta,tb+1,tc,sum); direct(ta,tb,tc-1,sum); direct(ta,tb,tc+1,sum);//判断6个方向 &#125;&#125;int main()&#123; freopen("in.txt","r",stdin);//文件读入，节省调试时输入的时间 scanf("%d",&amp;k);//输入数据组数 while(k--)//循环k次 &#123; memset(v,0,sizeof(v));//初始化标记数组 memset(d,0,sizeof(d));//初始化地图 memset(ans,0,sizeof(ans));//初始化答案数组 scanf("%d %d %d %d",&amp;a,&amp;b,&amp;c,&amp;t);//输入 for(int i=0;i&lt;a;i++) for(int j=0;j&lt;b;j++) for(int z=0;z&lt;c;z++) scanf("%d",&amp;d[i][j][z]);//输入 add(0,0,0);//将起点入队 spfa();//搜索 int answer=ans[a-1][b-1][c-1];//取终点答案，直接访问三维数组耗时太长，故新建一个变量用于保存 if(!answer||answer&gt;t) printf("-1\n");//如果答案还是初始值，或答案大于规定时间，则无法 else printf("%d\n",answer);//输出可行答案 &#125; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>SPFA</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20180304 随录]]></title>
    <url>%2Fdiary%2F20180304%2F</url>
    <content type="text"><![CDATA[啊，又是回校的日子了。周末做了什么？似乎也没做什么，无非是打打隔膜，氪氪金，不得已时候写写作业，睡个好觉，如是而已。下周就acm面试了，不能回家。还好妹妹也开学了，也算有个照应（虽然远了点）。该做什么呢？写个爬七天的爬虫，写个爬本网站、提供更新信息的爬虫，好好准备六级，好好学习数学。该是这样了吧。]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20180303 随录]]></title>
    <url>%2Fdiary%2F20180303%2F</url>
    <content type="text"><![CDATA[啊，好想学习啊。其实还是想打4y。不过总是要认真学习吧？2333]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[狗年元宵随录]]></title>
    <url>%2Fothers%2F20180302%2F</url>
    <content type="text"><![CDATA[啊，这是狗年的第一次发文吧。也是，我天天摸鱼，哪来的时间刷题写题解之类的啊2333开学的第一周要过去了，今天周五，也是元宵节，正好应该回去过节了。差点买不到票啊……不过还好用转车之法多花点钱还能回去，不然就独在异乡为异客了2333 周五，没发生什么大事。最大的感受，可能就是设计心理学真好玩，软件竞赛渣渣，略略略。上学期的排名昨天也出了，顺位92%，绝了啊，不过卓越毕竟还是看专业和数学，问题不大（艾尔基本也都99了，活动也打完了，我也该休息一下，留给妹妹玩吧。啊啊，好像也没什么说的了。诸君，学习吧。我也去写大物和微积分了。]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20180211 随录]]></title>
    <url>%2Fdiary%2F20180211%2F</url>
    <content type="text"><![CDATA[cbs 超越 5/5 5/2098 约一半dw 超越 5/5 0/2097 约一半交织together 约50s伟明家走了一圈kf家走了一圈]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年1月月赛 工作分配问题 题解]]></title>
    <url>%2FAnswer%2Fyxyz201801-04%2F</url>
    <content type="text"><![CDATA[2018年1月月赛 工作分配问题 题解 题目描述设有 n 件工作分配给 n 个人。将工作 i 分配给第 j 个人所需的费用为c[i][j] 。试设计一个算法，为每一个人都分配 1 件不同的工作，并使总费用达到最小。 输入输出格式输入格式第一行有 1 个正整数 n 。接下来的 n 行，每行 n 个正整数，表示工作费用。 输出格式一行，包含一个正整数，为计算出的最小总费用。 输入输出样例输入样例#1：310 2 32 3 43 4 5 输出样例#1：9 说明对于100%的数据，1&lt;=n&lt;=20，1&lt;=c[i][j]&lt;=100。 分析数据，发现最大数据为所有c[i][j]的和。而格子数最大只有n*n=400，每个c[i][j]最大只有100，故最大数据不大于40000，可以采用int类型。本题也有网络流解法，但网络流解法思维难度过大，不予讨论。采用dfs解决本问题。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;bool v[30]=&#123;false&#125;;long long ans=0;int c[30][30],n;void dfs(int x,int sum)&#123; if(x&gt;n) &#123; if(sum&lt;ans) ans=sum; return; &#125; if(ans&gt;sum) &#123; for(int i=1;i&lt;=n;i++) &#123; if(!v[i]) &#123; v[i]=true; dfs(x+1,sum+c[x][i]); v[i]=false; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;c[i][j]; ans+=c[i][j]; &#125; &#125; dfs(1,0); cout&lt;&lt;ans; return 0;&#125; 采用ans先存储所有c[i][j]的和，这里也可以将ans初始化为一个远大于40000的值。用v数组保存工作分配情况，v[i]=true表示第i件工作已经被分配，v[i]=false表示第i件工作未被分配。用dfs函数来执行深搜。dfs函数带有两个参量，其中x表示现在正在被分配工作的人的编号，sum表示目前总花费。当x&gt;n时表示人已经被枚举完了，此时判断sum是否小于已有答案ans，若是，则表示产生了更优解，更新ans的值。如果数据简单的话，到这里就可以过了。但本题数据较为复杂，需要剪枝。不论当前枚举到第几个人，只要当前sum&gt;=ans，就表示最终的sum不会比ans小，不会产生更优的解答。所以当且仅当ans&gt;sum的时候继续递归。]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年1月月赛 子数整数 题解]]></title>
    <url>%2FAnswer%2Fyxyz201801-03%2F</url>
    <content type="text"><![CDATA[2018年1月月赛 子数整数 题解 题目背景zc趁着大家都在hanoi，偷偷跑来研究五位数了！ 题目描述对于一个五位数a1a2a3a4a5，可将其拆分为三个子数：sub1=a1a2a3sub2=a2a3a4sub3=a3a4a5例如，五位数20207可以拆分成sub1=202sub2=020（=20）sub3=207现在给定一个正整数K，要求你编程求出10000到30000之间所有满足下述条件的五位数，条件是这些五位数的三个子数sub1，sub2，sub3都可被K整除。 输入输出格式输入格式一行，包含一个正整数K。 输出格式输出的每一行为一个满足条件的五位数，要求从小到大输出。不得重复输出或遗漏。如果无解，则输出”No”。 输入输出样例输入样例#1：15 输出样例#1：22555255552855530000 说明对于100%的数据，1&lt;=k&lt;=1000。 枚举10000~30000之间的所有整数，并将其拆分成三块，逐块判断即可。 代码：12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; bool p=true; int k; cin&gt;&gt;k; for(int i=10000;i&lt;=30000;i++) &#123; int s1=i/100,s2=i/10%1000,s3=i%1000; if(s1%k) &#123; i+=99; continue; &#125; if(s2%k) &#123; i+=9; continue; &#125; if(s3%k) continue; cout&lt;&lt;i&lt;&lt;endl; p=false; &#125; if(p) cout&lt;&lt;"No"; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年1月月赛 复仇的汉诺塔 题解]]></title>
    <url>%2FAnswer%2Fyxyz201801-02%2F</url>
    <content type="text"><![CDATA[2018年1月月赛 复仇的汉诺塔 题解 题目背景汉诺塔觉得自己不被mh和cl尊重，决定发动复仇！它把mh和cl困在了古印度圣庙中，并告诉wy，如果不能输出最少搬动的方案，那mh和cl就再也出不来了！ 题目描述题目的要求是输出最少搬动方案。 输入输出格式输入格式一行，包含一个整数n，即为盘子数n，n为正整数，且最大值为10 输出格式若干行。每一行格式如下：Step i:X -&gt; Y其中，i为第i步，从1开始计算。X，Y为A、B、C中某一个值。 输入输出样例输入样例#1：1 输出样例#1：Step 1:A -&gt; C 说明对于100%的数据，1&lt;=n&lt;=20。 裸的递归，没什么好说的。 代码：12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int sum=1;void move(char x,char y)&#123;printf("Step %d:%c -&gt; %c\n",sum++,x,y);&#125;void hanoi(int n,char from,char temp,char destination)&#123; if(n==1) move(from,destination); else &#123; hanoi(n-1,from,destination,temp); move(from,destination); hanoi(n-1,temp,from,destination); &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; hanoi(n,'A','B','C'); return 0;&#125; 在上述代码中，我们在hanoi函数里定义了剩余盘子数量n，起始盘子位置from，中转盘子位置temp，目标盘子位置destination。在每一步移动中，都可以分成两部分，一部分是最下面的那个盘子，一部分是剩下的盘子。每一步都可以看成先将剩下的盘子全部移动到其中转位置，再将最下面的盘子移动到其目标位置。每当发生最下面的盘子被移动到其目标位置时就输出。递归操作即可。]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年1月月赛 打卡的汉诺塔 题解]]></title>
    <url>%2FAnswer%2Fyxyz201801-01%2F</url>
    <content type="text"><![CDATA[2018年1月月赛 打卡的汉诺塔 题解 题目背景比赛总是需要打卡题~~ 题目描述mh和cl最近玩起了汉诺塔。相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。现有n个盘子，有A、B、C三个柱子。mh认为汉诺塔有最优解，而cl认为没有，这可怎么办呢？请你帮忙算算吧。 输入输出格式输入格式一行，包含一个正整数n，表示A柱子上有的盘子数量。 输出格式一行，包含一个整数，表示最少需要的步数。 输入输出样例输入样例#1：2 输出样例#1：3 说明对于60%的数据，1&lt;=n&lt;=32。对于100%的数据，1&lt;=n&lt;=64。样例说明：按A-&gt;B，A-&gt;C，B-&gt;C的方式即可三步完成。 通过手推n=1,2,3,4的情况，可以发现ans=pow(2,n)-1，故答案最大为2^64-1。观察数据范围，发现n&lt;=64。因为int范围-2^31~2^31-1long long范围-2^63~2^63-1unsigned long long范围0~2^64-1所以选用unsigned long long。但又因为pow函数返回值为double类型，浮点数类型在数字很大时会发生浮点误差，因此用pow只能80分。故采用循环。 代码：123456789101112#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; unsigned long long ans=1,n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) ans*=2; ans--; cout&lt;&lt;ans; return 0;&#125; 在上述代码中，我们发现，极端情况时ans=2^64，超过unsigned long long的0~2^64-1的范围，发生向上溢出（上溢），此时变为(2^64)-1-(2^64-1)=0。之后又发生ans–，ans本该变为-1，但因为超过unsigned long long的0~2^64-1的范围，发生向下溢出（下溢），此时变为(-1)+1+(2^64-1)=2^64-1，即是答案。]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>云霄一中月赛</tag>
        <tag>题解</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P1001 A+B Problem Python 题解]]></title>
    <url>%2FAnswer%2Fluogu-p1001%2F</url>
    <content type="text"><![CDATA[A+B没什么好说的……直接上Code12a,b=(int(x) for x in input().split(' '))print (a+b)]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>python</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017へのさよなら]]></title>
    <url>%2Fdiary%2Fend-of-2017%2F</url>
    <content type="text"><![CDATA[2017也算是过去了，聊表感想。 PART1不知不觉2017已经过去了。实话实说，2017年，真是对我来说人生中重要的一年。经历了严酷的高三总复习，参加了大大小小的模拟考试（省质检一竟然还漏题了，笑），直到高考，直到来到XMU，直到……也算是命中注定吧，为了冲XMU经院，放着自招20分不用，报了普通本一批，第一志愿经院，第二志愿软院。但是在FJ，经院收到597分，而我才考了596，因而还是来了软院。若是我当时多考一分，现在又如何呢？ PART2除了正式的学业之外，我还参加了一些可做可不做的事。 云一OI培训 云一日语部 N3考试 等等但是结果？ NOIP2017无人通过初赛 集训学员学习热情忽高忽低 日语部成员竟然因为一个人退部了就热情降到冰点 N3考试尚无结果又有什么事情成功了呢？只是我的一厢情愿吗？ PART3在XMU软院，似乎借着FJTG2=的基础，大有风生水起之势。但lyh，YJQAQ，hiijar，都能在专业水平方面甩我若干条街。我能做些什么？怕是只有学习。即使是学习，也面临我长期以来的问题：听不下课。小学时期，我发现课不难，上课写作业的话回家可以有更多时间玩。于是一发不可收拾，直到高中毕业我都贯彻落实这一点。这直接造成我现在只有在上课时候才能写作业，也只有写作业才能保证清醒，否则我一旦认真听课，立刻睡着。长期以来的习惯，如今被婊了。我曾经也试过改，然后就睡着了，根深蒂固。但是我能怎么办呢？我就想上课睡觉吗？我就不想改吗？ PART412.30去了上海，在浦东赶星尘宝宝的演唱会，然后去松江找同学玩。从松江到外滩，真的蛮久的，用时好像在2小时？结果见到了重度污染的东方明珠，还因为地铁要封站而匆匆赶回。次日早上兜兜转转，虽然中午开心地聚餐了，但是飞机险些来不及，唉，虹桥居然提前20分钟截停，还是高崎15分钟截停好。只有照片，留下了一点回忆。 PART5想起一句名言？也许不算名言。“未来永远在手中，手中抓不住的是过去”。似乎没什么事情的2017，已经抓不住了。 那么，再见。]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本站建站指导]]></title>
    <url>%2Fothers%2FMyWebsiteGuide%2F</url>
    <content type="text"><![CDATA[本站建站指导 安装 注册github账号，并新建一个github仓库（Repositories） 下载node.js。https://nodejs.org/en/download/ 安装git。https://git-for-windows.github.io/ 鼠标右键安装node.js的地方，进入nodemudule文件夹，选择Git Bash，使用以下命令安装hexo npm install hexo-cli -g npm install hexo-deployer-git –save 创建放置博客文件的文件夹：hexo文件夹，如E:\hexo。最好不在中文目录下。注意：以后进行hexo操作都要进入到此文件夹中；对于git操作，若无特殊说明，则也进入到此文件夹中（在此文件夹中启动Git Bash） 进入E:\hexo文件夹，鼠标右键选择“Git Bash”,执行以下命令，初始化hexo，这时候会在该文件夹中创建网站所需要的文件 hexo init npm install hexo g此时已经可以在本地访问。在Git Bash中输入命令：hexo s访问127.0.0.1:4000或localhost:4000即可看到网页预览。 布置到github上。 启动Git Bash，输入以下命令： git config --global user.name &quot;your name&quot; git config --global user.email your_email@youremail.com其中每条命令的最后一个参数修改为自己的数据 输入命令：ssh-keygen -t rsa -C ringoer@qq.com此时会生成ssh密钥。命令中邮件地址替换为自己的。 输入命令：cat ~/.ssh/id_rsa.pub此时会在控制台显示一串密钥，复制下来。 打开github，打开settings，选择SSH and GPG keys，选择New SSH key。title随便写，key的文本则填写刚才复制出来的密钥，然后add key。 输入命令：ssh -T git@github.com上述命令不可修改 打开hexo文件夹中的_config.yml，修改文档末尾的deploy，示例如下：其中蓝色部分应替换成自己的链接。链接来源参考自己github仓库的链接（如图）：注意：hexo的配置文件中任何:后面都是带一个空格的。 绑定自己的域名 在/hexo/source文件夹中新建一个CNAME文件，然后里面添加自己的网站域名。可以在github的setting中查看是否发布成功。 到自己的域名解析中添加CNAME值，解析到username.github.io.(注意最后面有点) 个性化 下载主题。此处我选用next主题，Pisces主题风格（默认为Muse）。修改/themes/next下的配置文件中的schemes字段。取消需要的主题风格前的井字号，然后在之前的主题风格前加入井字号即可。之后配置网站信息，如图。 底部信息。修改/themes/next下的配置文件中的footer字段。 文章缩略。修改/themes/next下的配置文件中的auto_excerpt字段。enable改成true即可。也可以手动在每篇文章中添加&lt;!--more--&gt;字段，在该字段后的部分会被隐藏。 修改导航栏。修改/themes/next下的配置文件中的menu字段。想要什么选项，就去掉其之前的井字号，或自己新加入一个。||后面是该项所用的图标 菜单项图标。在 http://www.fontawesome.com.cn/icons-ui/ 中选择。取用时要去掉前缀fa-。修改/themes/next下的配置文件中的menu字段。 取消页面动画。修改/themes/next下的配置文件中的motion字段。 enable: false即可 设置头像。修改/themes/next下的配置文件中的avatar字段。须确认有/source/images文件夹（如没有则应新建），后在其中添加图片，如图写入路径即可。该路径也可以是来自网络的图片路径。 设置社交媒体。修改/themes/next下的配置文件中的social字段。icons_only默认为false，会显示各个图标的名字。若为true则仅有图标。 顶部加载进度条。修改/themes/next下的配置文件中的pace字段。 文章结尾标识。分为以下三个步骤。 打开\themes\next\layout_macro文件夹，新建文件passage-end-tag.swig，向其中写入以下片段。 12345 &lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------It&apos;s the end.&lt;i class=&quot;fa fa-life-ring&quot;&gt;&lt;/i&gt;Thanks for your read.-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 打开\themes\next\layout_macro\post.swig文件，进行如图操作。插入的文本如下： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; 在/themes/next下的配置文件中加入以下字段。 123 # 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 添加外链网易云音乐。分为以下两个步骤。 访问网页版网易云，找到合适的歌曲/歌单，生成分享外链，复制html代码。 找到合适的位置插入这段代码。本博客插入在\source\about\index.md中图片的后面（如图）。 本地可视化编辑文章。启动git bash，执行以下命令。npm i hexo-admin –save之后执行hexo s时，访问 localhost:4000/admin 即可进入文章后台。此处文章编辑使用markdown。 文章置顶。把需要置顶的文章的发布时间改到200年之后（233333333）。 修改菜单中的选项名称。打开\themes\next\language\zh-Hans.yml，找到menu字段，进行如图配置。 迁移 拷贝原有hexo文件夹至新电脑 重新配置git和node.js 安装hexo 1npm install hexo-cli -g 进入hexo文件夹，执行以下指令 1234npm installnpm install hexo-deployer-git --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save 重新配置SSH密钥 正常使用 参考链接https://blog.csdn.net/qq_27754983/article/details/76143478https://www.jianshu.com/p/21c94eb7bcd1https://www.jianshu.com/p/393d067dba8dhttps://www.jianshu.com/p/9f0e90cc32c2https://blog.csdn.net/eternity1118_/article/details/71194395?ref=myread]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>建站指导</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P2308 添加括号 题解及心得]]></title>
    <url>%2FAnswer%2Fluogu-p2308%2F</url>
    <content type="text"><![CDATA[Luogu P2308 添加括号 题解及心得 题目背景给定一个正整数序列a(1)，a(2)，…，a(n),(1&lt;=n&lt;=20)不改变序列中每个元素在序列中的位置，把它们相加，并用括号记每次加法所得的和，称为中间和。例如:给出序列是4，1，2，3。第一种添括号方法:((4+1)+(2+3))=((5)+(5))=(10)有三个中间和是5，5，10，它们之和为:5+5+10=20第二种添括号方法(4+((1+2)+3))=(4+((3)+3))=(4+(6))=(10)中间和是3，6，10，它们之和为19。 题目描述现在要添上n-1对括号，加法运算依括号顺序进行，得到n-1个中间和，求出使中间和之和最小的添括号方法。 输入输出格式输入格式共两行。 第一行，为整数n。(1&lt; =n&lt; =20) 第二行，为a(1),a(2),…,a(n)这n个正整数，每个数字不超过100。 输出格式输出3行。 第一行，为添加括号的方法。 第二行，为最终的中间和之和。 第三行，为n-1个中间和，按照从里到外，从左到右的顺序输出。 输入输出样例输入样例#1：44 1 2 3 输出样例#1：(4+((1+2)+3))193 6 10 显然加括号过程是依赖最小中间和的，而最小中间和势必从一个区间中得出，故不难看出这是一个区间dp。不难得出状态转移方程：1f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+sum[j]-sum[i-1]) 解题思路： 先区间dp，逆向枚举i，正向枚举j，阶段k=i,k&lt;j。由于括号添加时要尽可能靠左，所以当新值&lt;=f[i][j]时即发生更新。//求最小值时i逆序j正序，最大值时都正序 1234567891011for(i=n-1;i;i--)&#123; for(j=i+1;j&lt;=n;j++) &#123; for(k=i;k&lt;j;k++) &#123; int t=f[i][k]+f[k+1][j]+sum[j]-sum[i-1]; if(t&lt;=f[i][j]) f[i][j]=t,g[i][j]=k; &#125; &#125;&#125; 为了能解决第二问和第三问，令g[i][j]=k保存从下标i~j之间断点k的位置。 对于第二问，递归查找每个点左边有多少个左括号，右边有多少个右括号，然后输出。 12345678910111213141516void search(int x,int y)&#123; if(x==y) return; l[x]++; r[y]++; search(x,g[x][y]); search(g[x][y]+1,y);&#125;for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;l[i];j++) printf("("); printf("%d",a[i]); if(r[i]==0&amp;&amp;i&lt;n) printf("+"); for(j=0;j&lt;r[i];j++) printf(")"); if(r[i]&gt;0&amp;&amp;i&lt;n) printf("+");&#125; 对于第三问，递归求每个中间和，然后输出。 1234567void dfs(int x,int y)&#123; if(x==y) return; dfs(x,g[x][y]); dfs(g[x][y]+1,y); ans[top++]=sum[y]-sum[x-1];&#125; 心得：虽然大部分区间dp是在最外层枚举阶段，但是偶尔也要像这题这样最内层枚举阶段吧。//还有可能是我没想到最外层枚举阶段的做法（小声）。总之，終わり！&lt;附送全篇代码&gt;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#include&lt;stdbool.h&gt;#define maxn(a,b) (a&gt;b)?a:b#define minn(a,b) (a&lt;b)?a:b#define maxnn(a,b,c) (a&gt;b&amp;&amp;a&gt;c)?a:((b&gt;a&amp;&amp;b&gt;c)?b:c)#define ll long longint a[30]=&#123;0&#125;,f[30][30],g[30][30],sum[30]=&#123;0&#125;,l[30],r[30],ans[30],top;void search(int x,int y)&#123; if(x==y) return; l[x]++; r[y]++; search(x,g[x][y]); search(g[x][y]+1,y);&#125;void dfs(int x,int y)&#123; if(x==y) return; dfs(x,g[x][y]); dfs(g[x][y]+1,y); ans[top++]=sum[y]-sum[x-1];&#125;int main()&#123; int n,i,j,k; while(scanf("%d",&amp;n)!=EOF) &#123; top=0; memset(ans,0,sizeof(ans)); memset(sum,0,sizeof(sum)); memset(a,0,sizeof(a)); memset(l,0,sizeof(l)); memset(r,0,sizeof(r)); memset(g,0,sizeof(g)); memset(f,1,sizeof(f)); for(i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); f[i][i]=0; &#125; for(i=1;i&lt;=n;i++) sum[i]=a[i]+sum[i-1]; for(i=n-1;i;i--) &#123; for(j=i+1;j&lt;=n;j++) &#123; for(k=i;k&lt;j;k++) &#123; int t=f[i][k]+f[k+1][j]+sum[j]-sum[i-1]; if(t&lt;=f[i][j]) f[i][j]=t,g[i][j]=k; &#125; &#125; &#125; search(1,n); for(i=1;i&lt;=n;i++) &#123; for(j=0;j&lt;l[i];j++) printf("("); printf("%d",a[i]); if(r[i]==0&amp;&amp;i&lt;n) printf("+"); for(j=0;j&lt;r[i];j++) printf(")"); if(r[i]&gt;0&amp;&amp;i&lt;n) printf("+"); &#125; printf("\n%d\n",f[1][n]); dfs(1,n); for(i=0;i&lt;top;i++) &#123; if(i&lt;top-1) printf("%d ",ans[i]); else printf("%d",ans[i]); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Answer</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>dp</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语言-11-竞赛相关的其余操作及编程时应有的良好习惯]]></title>
    <url>%2Fcpp%2Fcpp-11%2F</url>
    <content type="text"><![CDATA[待更新缩进高内聚，低耦合freopeninline]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语言-10-指针]]></title>
    <url>%2Fcpp%2Fcpp-10%2F</url>
    <content type="text"><![CDATA[待更新地址（分配地址，取地址符号，取值符号）(*p)++*p++结构体指针（->）链表]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语言-9-结构体与运算符重载]]></title>
    <url>%2Fcpp%2Fcpp-9%2F</url>
    <content type="text"><![CDATA[本章学习结构体与运算符重载。在各路题目中，我们有时候会看到，一个主体有很多个属性。比如你是一个学生，你可以被拆分为以下属性的集合体： 姓名 性别 年龄 年级 班级…… 而且，其余的学生也都是跟你一样有这些属性。那么，我们现在假设一个年级有1000人，难道我们要针对每个属性都开一个1000单位的数组吗？这时候我们就可以使用结构体，把这些属性整合，产生一个新的类型。比如上文中的属性，我们就可以整合为一个student类型。写法如下：123456789101112struct student//struct是必须的，不可更改；后面的student则可以自定义&#123; string name;//用一个名为name的字符串保存姓名 char sex;//假设我们用M和W来表示Man和Woman，那么可以用一个字符型来保存 int age; int grade; int class;//分别用三个int类型变量来保存年龄，年级和班级 void show() &#123; cout&lt;&lt;name&lt;&lt;” ”&lt;&lt;sex&lt;&lt;” ”&lt;&lt;age&lt;&lt;” ”&lt;&lt;grade&lt;&lt;” “&lt;&lt;class&lt;&lt;endl; &#125;//该函数可以输出5个变量&#125;;//注意这里有个分号，不要漏了 通过上文的代码段，我们就建立了一个结构体类型，类型名称为student。其下属有5个变量，我们称之为“成员变量”，又叫“成员表”；还有1个函数，我们称之为“成员函数”。这样，我们就可以总结一个格式：12345struct 类型名称&#123; 成员表 成员函数&#125;; 没有严格的顺序，但一般成员函数写在成员表之后，因为变量/数组等必须先定义才能调用。注意结构体的右大括号后必须有个分号，不要漏掉。 那么，我们如何使用结构体？ 结构体类型，俗称自定义类型。因此，可以效仿其它类型的定义方法。如上文中的student，此时就可以用作数据类型。如，我们称int a;为定义一个名为a的int类型变量。同样的，我们可以student a;来定义一个名为a的student类型变量。 因此，我们可以写出如下代码：12345678910111213#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student&#123; string name; int age;&#125;;int main()&#123; student a,b;//定义两个student类型的变量，分别名为a和b return 0;&#125; 定义student类型的变量也可以写在struct student的右大括号后分号前。写法如下：12345678910111213#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student&#123; string name; int age;&#125;a,b;//定义两个student类型的变量，分别名为a和bint main()&#123; return 0;&#125; 如果采取上述方法定义结构体变量，还可以不写结构体类型的类型名称。如下：12345678910111213#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct&#123; string name; int age;&#125;a,b;//定义两个student类型的变量，分别名为a和bint main()&#123; return 0;&#125; 此时该结构体类型是一次性类型，因为没有填写结构体类型名称，所以不可以被再次使用。 讲完了结构体类型变量的定义，现在我们来讲一下如何访问结构体变量的成员。 假设我们有如下结构体及变量定义：123456789struct student &#123; string name; int age; void show() &#123; cout&lt;&lt;name&lt;&lt;” ”&lt;&lt;age &lt;&lt;endl; &#125; &#125;a; 则我们可以通过“.”，就是跟小数点一样的那个点，来访问结构体变量的成员。示例：123456789101112131415161718#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; void show() &#123; cout&lt;&lt;name&lt;&lt;” ”&lt;&lt;age &lt;&lt;endl; &#125; &#125;a;int main()&#123; cin&gt;&gt;a.name&gt;&gt;a.age;//分别输入student类型变量a的成员变量name和age a.show();//调用student类型变量a的成员函数show return 0;&#125; 如上示例中，我们可以通过“.”来访问结构体变量的成员。此时“.”叫做“成员访问符”。访问到成员变量或成员数组或成员函数的时候，可以如同一般的变量/数组/函数一般使用。 对于结构体类型，我们还可以对其进行运算符重载。如，设有以下结构体类型及变量定义：1234struct complex//complex表示复数&#123; int a,b;//a表示实部，b表示虚部&#125;x,y,z; 关于复数 显然，我们不能直接使用+号来做到z=x+y;只能分别写z.a=x.a+y.a;和z.b=x.b+y.b;这样就显得很繁琐。那么，该如何才能用+号直接操作呢？我们可以在struct complex中进行对于+号的重载，格式如下：1234567891011struct complex//complex表示复数&#123; int a,b;//a表示实部，b表示虚部 friend complex operator +(const complex&amp; p,const complex&amp; q) &#123; complex ans; ans.a=p.a+q.a; ans.b=p.b+q.b; return ans; &#125;&#125;x,y,z; 这样就可以在程序的其余位置，对complex类型的变量使用+号直接操作了。同理，除加号外，“-”，“*”，“/”，“%”也可以采用这样的方式重载，格式为：1234friend 类型名 operator 符号(const 类型名&amp; a,const 类型名&amp; b)&#123; &#125; 以上，是对算术运算符的重载。 再设有以下结构体类型及变量定义：1234struct student&#123; double chinese,math;//用来表示语文成绩和数学成绩&#125;a,b; 这样虽然可以使用==和!=来判断a和b是否相等（所有成员变量的值完全相同与否），但不能直接使用大于号或小于号来判断a和b谁大谁小，因为它不知道要用哪个来判断。所以我们需要重载一下，告诉程序怎么处理。示例：123456789struct student&#123; double chinese,math;//用来表示语文成绩和数学成绩 friend bool operator &gt;(const student&amp; p,const student&amp; q) &#123; if(p.chinese!=q.chinese) return p.chinese&gt;q.chinese; return p.math&gt;q.math; &#125;&#125;a,b; 这样就可以使得大于号能判断a和b的大小（小于号还是不行）：在判断是否a&gt;b时，先判断a的语文成绩是否比b高，若是则a大；若语文成绩相等则判断数学成绩，若a数学成绩较高则a大；数学成绩也相等则a不比b大。同理，可以对其它逻辑符号进行重载，格式为：1234friend bool operator 符号(const 类型名&amp; a,const 类型名&amp; b)&#123; &#125; 以上，是对逻辑运算符的重载。 再设有以下结构体类型及变量定义：12345struct student &#123; string name; int age; &#125;a; 这样我们是不能使用cin和cout直接输入和输出的，需要重载流插入符合流输出符才行。示例：12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt; using namespace std;struct student &#123; string name; int age; friend istream&amp; operator &gt;&gt;(istream&amp; in,student&amp; x) &#123; in&gt;&gt;x.name&gt;&gt;x.age; return in; &#125;//对输入的重载，使得可以使用cin直接输入student类型的变量 friend ostream&amp; operator &lt;&lt;(ostream&amp; out,student&amp; x) &#123; out&lt;&lt;x.name&lt;&lt;" "&lt;&lt;x.age; return out; &#125;//对输出的重载，使得可以使用cout直接输出student类型的变量 //为了符合一般的使用习惯，endl一般不写在对&lt;&lt;的重载中&#125;a;int main()&#123; cin&gt;&gt;a; cout&lt;&lt;a&lt;&lt;endl; return 0;&#125; 以上便是对输入和输出的重载。格式为：对输入重载：12345friend istream&amp; operator &gt;&gt;(istream&amp; in,类型名&amp; x)&#123; in&gt;&gt;变量1&gt;&gt;变量2;//可以更多 return in;&#125; 对输出重载：12345friend ostream&amp; operator &lt;&lt;(ostream&amp; out,类型名&amp; x)&#123; out&lt;&lt;变量1&lt;&lt;” “&lt;&lt;变量2;//可以更多 return out;&#125; 以上，是对输入输出运算符的重载。 还可以对=,(),[],->四种运算符进行重载，但这已经严重超纲，有兴趣的同学可以自行百度一下。 第九章到此结束。]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语言-8-递归与递推]]></title>
    <url>%2Fcpp%2Fcpp-8%2F</url>
    <content type="text"><![CDATA[本章学习递归/递推相关知识。首先，请大家熟悉对于斐波那契数列第n项的定义。斐波那契数列接下来，我们将借助斐波那契数列来说明递归和递推。 递归在上一章中我们学习了自定义函数，知道可以在主函数中，或其它函数中调用自定义函数。但其实，不止不同函数之间可以相互调用，函数自己也可以调用自己。这个过程称之为递归。递归的示例程序如下：123456789101112131415#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int f(int x)&#123; if(x==1||x==2) return 1; else return f(x-1)+f(x-2);&#125;int main()&#123; int x; cin&gt;&gt;x; cout&lt;&lt;f(x); return 0;&#125; 可以看到，在函数f中又调用了函数f。函数f内部的运行可以解释为下述过程： 判断x是否与1相等或x是否与2相等，若是，则函数返回值为1 若1中的判断失败，则函数返回值为【参数为x-1的函数f的返回值】与【参数为x-2的函数f的返回值】之和。 如x=4，则调用过程如图所示：1234567 f(4) f(3) f(2)f(2) f(1) 11 1 也就是说，函数首先发现要计算f(4)，但此时x=4，不满足x与1相等或x与2相等，所以将f(4)展开为f(3)和f(2)，先计算f(3)和f(2)的值，再相加后，作为f(4)的返回值。接下来根据从左往右执行的规则，函数要计算f(3)。计算f(3)的过程仍然与上述过程类似，展开为f(2)和f(1)后求和。接下来求解由f(3)展开而得到的f(2)，发现符合x与2相等，因此f(2)返回1求解由f(3)展开而得的的f(1)也同理返回1，因此f(3)=1+1=2，返回2现在f(3)求解完成，再求解由f(4)展开的f(2)，得1，所以f(4)=f(3)+f(2)=2+1=3，因此f(4)最终返回值为3。需要注意的是，在使用递归的时候，我们一定要给函数一个边界，让它不会在无限的自调用中迷失。该边界称为递归边界，没有边界的递归将如无限循环一般，必然造成超时。以上就是斐波那契数列的递归过程。但是在实际运行的时候我们发现，当求解斐波那契数列的项数较高的时候会卡在运行中很久，造成超时（TLE）。为什么呢？从上文我们对f(4)的分析就可以看出，f(2)被计算了2次。由此可以推断，当求解f(10)甚至f(100)的时候，会产生大量重复的计算过程，无意义地消耗了时间。此时，我们采用递归求解便不再合理，应该换用递推。 递推在上文中，求斐波那契数列第n项，我们采用的是从f(n)开始，一层层向下展开。而根据斐波那契数列的特点，我们其实可以从第1项开始向上推，直到第n项。代码如下：1234567891011121314#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int x,f[1000]; cin&gt;&gt;x; f[1]=1; f[2]=1; for(int i=3;i&lt;=x;i++) f[i]=f[i-1]+f[i-2]; cout&lt;&lt;f[x]; return 0;&#125; 对于上述代码，求解f[4]的过程就变为如下描述： 已知x==1或x==2时，f[x]=1，所以初始化令f[1]=1,f[2]=1。 因为f[1]和f[2]都已经赋值，所以接下来从f[3]开始计算就可以。枚举f[3]~f[x]的每个单位，根据f[x]=f[x-1]+f[x-2]来求解。此处f[x]=f[x-1]+f[x-2]称为递推式。 求解完成，输出f[x]。可以发现，递推求解是需要数组配合的。与递归不同的是，递推是采用空间换时间的做法，将每次求出来的f[x]保存下来，避免了重复求解，大大节约了时间。以上，就是对递归和递推的基本描述。 第八章到此结束。 本章练习：T17548 斐波那契数列T17551 Pell数列P1028 数的计算P1036 选数P1217 [USACO1.5]回文质数 Prime PalindromesP1706 全排列问题]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语言-7-函数的自定义与函数的类型]]></title>
    <url>%2Fcpp%2Fcpp-7%2F</url>
    <content type="text"><![CDATA[本章学习函数相关知识。采用以下程序段进行说明：1234567891011121314#include&lt;iostream&gt;using namespace std;int f(double x)&#123; int a=x; return a;&#125;int main()&#123; double a; cin&gt;&gt;a; cout&lt;&lt;f(a); return 0;&#125; 样例输入1：1.1样例输出1：1样例输入2：0.9样例输出2：0 可以看出，我们在公共域（又称全局）里定义了两个函数，一个是int类型的f（自带一个参数，是double类型的x），另一个就是main。main就不多说了，毕竟int main()是强制要求，不能改动。但是这个f就很有意思了。首先，我们学到过在公共域直接int f的话表示定义一个int类型的名为f的变量，但现在为什么是个函数呢？那就是因为f后面的小括号了。那么就有以下定义及使用规范四点。 满足形如【数据类型 名称(参数列表)】的程序段，就是函数。 自定义函数的函数体只能写在公共域或自定义类型内。其中，当自定义函数的函数体写在公共域内时： 若自定义函数的函数体写在main函数之前，则可以不在main函数里写其定义语句，因为其函数体那边就已经定义了。 若自定义函数的函数体写在main函数之后，则必须在main函数里写其定义语句。总之就是必须满足先定义再使用。 只要是函数，就必须使用大括号来告诉程序哪些语句属于这个函数。 小括号里可以放空，也可以不放空，定义若干个参数。 前3点都是很好懂的，主要是这个第4点了。在文章开头的程序段中，我在f后面的空格里定义了一个double类型的x作为f的自带参数（当然也可以定义多个，中间用逗号隔开就行了），在main里定义了一个double类型的a，在f里int了一个a（根据变量的作用域，这个a属于不同的域，是不算重复的）。并且，在输入a之后，我让程序输出了f(a)的值。过程如下： cout检查到要输出f(a)。 按照填写的先后顺序访问填入f后面的括号中的变量所对应的值，并填入对应的位置（这个过程叫传递参数）。在本例中是访问main中a的值，填入f的括号中，使f的double类型的x等于main的double类型的a，并执行f。 进入f，定义一个属于f的int类型的a，使这个a等于x。 使f(x)返回a的值，并且此值重置为int类型。 返回main，输出f(a)此时的值。 关于第2点，举个例子。比如int f(int x,int y,int z)，那么main里如果定义了a，b，c三个变量的话，cout&lt;&lt;f(a,b,c);就是输出当f中的x等于main的a，f中的y等于main的b，f中的z等于main中的c时，f(x,y,z)返回的值。在上述过程中，第二步所提到的那些值里，在main中填入f函数括号内的，称为“实际参数”；而在传递到f函数，开始执行f函数时，f函数中的x称为“形式参数”。 回到本文的例子，在返回f(x)的值之前，程序中经历了以下3次的数据类型转换： 获得double类型的待传递参数的值，转换为被传递参数的double类型，并填入被传递参数。 获得double类型的f里的x的值，转换为int类型的值，并赋值给f里的a。 因为函数f返回f里a的值，所以获得int类型的f里的a的值，转换为int类型的值，并赋值给整个函数f，然后结束f。（如果你这时return 0的话，函数f一定就返回0，那输出也就是0了） 简而言之，在return某个值之前，每个自定义函数都和main一样，可以执行程序语句，不过main以外的其它自定义函数需要被某个正在执行的函数调用就是了。而一旦return某个值，函数就相当于变量，产生一个确定的值，但这个值是一次性的，下次函数再被调用时，依然要重新经过一遍语句的执行来得出一个新的结果。 以上就是函数的自定义了。那么，函数的类型又是什么呢？有的时候，你自定义一个函数，是为了让它执行一段语句，并不是为了让它返回一个值。这时，函数的类型可以都使用int，结尾都写return 0；也可以令函数的类型为void（英文翻译：虚空，此处用作“空类型”之意），结尾不写return 0;需要注意的是，void类型只能用于自定义函数，不可用于main函数，更不可用于一般变量/数组等等。且void类型的函数也可以强制退出，即，使用return;语句。此时return后不能写值，应该直接写分号，当void类型函数在执行中遇到return;时即结束。但是，更多的时候，你是为了让这个自定义函数返回一个值。这时候，函数的类型必须要与你要得到的值相同。如果你想让函数返回一个double类型的值，就必须定义函数为double类型，不可以是float类型，更别说int了。不过，函数后面的括号里的自带参量的类型，就没有特别要求，依你的需要而定。 那么，又是什么时候要使用自定义函数呢？这就涉及到编程时的一个重要思想：高内聚，低耦合。高内聚，就是相同或相似功能的语句块尽可能集中在一起。低耦合，就是功能差异较大的语句块尽可能不要集中在一起。那么，我们就需要用自定义函数，来表示一个功能。这个把功能实现为自定义函数的过程，叫做“封装”。这大概可以理解为，你手里有一件事情，这件事可以分解为几个不同的步骤，不同的步骤可以起到不同的效果（功能）。然后你把这几件事分配给另外的人（自定义函数），让他们替你去做。再结合上文的话，你要告诉他具体步骤怎么做，这就是他的函数体；还要告诉他应该用什么东西来做，这就是他的参数。大概就是这样了。 接下来，如何使用自定义函数呢？在之前的学习中，我们已经使用过诸如pow等数学函数。自定义函数也可以如同数学函数一般调用。如同本文开头的程序段，我们在主函数中输出语句处调用了自定义函数f。自然的，我们也可以在主函数其它区域调用自定义函数。这些地方都属于主函数的函数体。那么我们可以给出总结：可以在任意函数体内的任意合理位置调用任意函数（主函数除外）。比如，我们可以在自定义函数中输出helloworld，如下文代码：1234567891011#include&lt;iostream&gt;using namespace std;void pr()&#123; cout&lt;&lt;"helloworld"&lt;&lt;endl;&#125;int main()&#123; pr(); return 0;&#125; 在上述代码段中，我们定义了一个自定义函数pr。因为它不需要返回值，所以可以使用void类型；又因为它只是用来输出一个字符串常量，所以不需要参数，因此参数列表为空。如上，即是自定义函数的使用方法。 第七章到此结束。]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语言-6-变量和语句的作用域]]></title>
    <url>%2Fcpp%2Fcpp-6%2F</url>
    <content type="text"><![CDATA[本章学习作用域相关知识。采用以下程序段进行说明：1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int x=1;int main()&#123; int a=1; while(a&lt;10) &#123; int b=3; a++; while(b&lt;5) &#123; int c=2; if(c&gt;=4) break; b++; c+=b; &#125; &#125; return 0;&#125; 先说明一下，a++的效果等于a+=1等于a=a+1，不过a++的执行速度比a=a+1快就是了。同理c+=b是等于c=c+b的。我们可以看到，在本程序段中有4个变量，分别是x，a，b，c，定义的位置各不相同，甚至x是定义在int main()之外的。这是什么意思呢？原来，变量不是定义了之后就通用的，而是有所属范围的。定义在int main外的，不属于任何函数的x，是可以在本程序所有函数中调用的。它定义的位置叫做公共域。而定义在int main里的a，是属于main而不是公共域的。它在main结束时就会清空，不能再访问。也就是说，x可以在程序的任何函数中被访问和修改，而a只能在main里被访问和修改。但是b，c去哪了？我们可以看到，在进入第1个while之后，b才被定义，而c更是定义在第2个while里，且这两个while都属于main，第2个while又属于第1个while。所以，变量b只能在第1个while中被访问和修改，变量c只能在第2个while中被修改。又因为第2个while属于第1个while，所以它能访问和修改变量b，而两个while都属于main，所以能访问和修改变量a。但反过来，不在第1个while里的话，main和其它定义在公共域的函数是不能访问和修改变量b的。同理，不是在第2个while里的话，即使是第1个while里的其它语句，也不能访问和修改变量c。至此，我们能得到一个上下级关系：1234程序本体——main————while——————while 下级可以访问和修改上级中已经定义的变量，而上级不可以访问和修改定义在下级中的变量。根据这套理论，你能猜到第2个while里的break作用范围有多大了吗？就是只能跳出第2个while而已，对第1个while半毛钱影响都没有。continue也是一样的。但是return 0不能乱写，这是特例，所有int类型的函数，比如main，在碰到return 0时会直接结束这个函数自身，跳过下面的所有语句。基于这个特性，也可以用return 0来当程序断点，用来检测当编译成功却运行时错误时哪些语句有问题。当然，不止是return 0，事实上自定义函数和main，碰到return时，不管return是什么都会结束函数。只不过main要求一定要return 0罢了。 第六章到此结束。]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语言-5-字符型，字符数组与字符串]]></title>
    <url>%2Fcpp%2Fcpp-5%2F</url>
    <content type="text"><![CDATA[本章学习字符相关内容。让我们从介绍字符型（char）开始。 字符型字符型，顾名思义，就是可以保存字符的数据类型，与int、double等保存数字的略有区别。什么区别呢？ 表示上的区别比如我们要表示数字1，则int a=1;即可。而若要表示字符1，则需要char a=&#39;1&#39;;注意到字符1被单引号所围住。这就是表示字符的方法。若写char a=1;则会令a被赋值为一个与字符1毫无关系的符号。 使用上的区别首先声明三个概念：数字、数值、字符。毋庸置疑的是，在计算机内部，不论是数字还是字符，都是转化为数值进行处理的。显然，数字1的数值也是1，以此类推。但是字符1的数值就不是1了，而是49。为什么呢？可以查询一下ASCII码，此处不多解释。常见的字符与其数值：‘0’=48,’1’=49，以此类推‘A’=65,’B’=66，以此类推‘a’=97,’b’=98，以此类推但有时候我们还会经常看到’\n’,’\0’之类的。这些是什么呢？这些叫转义字符。其中，’\0’表示空字符，’\n’表示换行符。*printf(“\n”);与cout&lt;&lt;endl;一致。数值匹配如下：‘\0’=0‘\n’=10查看数值匹配的方法： cout&lt;&lt;int(‘0’);可以查看字符0的ascii码（数值） printf(“%d”,’0’);也可以实现1的效果 cout&lt;&lt;char(48);可以查看数值48对应的字符 printf(“%c”,48);也可以 以上，就是字符型的简单表示。接下来是字符数组。 字符数组在前几章中，我们已经学习了数组的相关知识。那么很显然，字符数组的声明应该满足下述格式：char str[100];本语句声明了一个名为str的char类型数组，有100个单位可供使用。我们知道，对于数组，其内部存储的时候是一个个值连续存储的。那么对于字符数组，因为字符型的值是字符，所以字符数组内部就是一个个字符连续存储的。如将“helloworld”保存在上述字符数组str内，则内部表示为’h’,’e’,’l’,’l’,’o’,’w’,’o’,’r’,’l’,’d’，如同一连串的字符，此时便可称之为字符串。对于字符数组的初始化，除了前述的对于数组的通用初始化方法，还可以使用双引号，也就是用字符串常量直接初始化。如： 采用通用方法：char str[100]={&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;w&#39;,&#39;o&#39;,&#39;r&#39;,&#39;l&#39;,&#39;d&#39;}; 采用双引号：char str[100]=&quot;helloworld&quot;; 注意到采用通用方法时，需要大括号，而采用字符串常量时不需要大括号。 上面我们为str数组开设了100个单位，并且注意到”helloworld”只有10个字符。那么我们可不可以只开10个单位呢？问题可以转化成，以下两种写法可不可行？ 采用通用方法：char str[10]={&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;w&#39;,&#39;o&#39;,&#39;r&#39;,&#39;l&#39;,&#39;d&#39;}; 采用双引号：char str[10]=&quot;helloworld&quot;; 答案是，两种都不可行。 在第一种中，虽然我们显式指定了str数组各个位上的值，但编译时其会在结尾补一个空字符’\0’，导致其最终有11个元素，超出了str数组10个元素的限制，引起访问错误。所以，在使用通用方法进行对字符数组的初始化时，应该预留足够的位置，至少应该是显示指定的字符数+1。 在第二种中，我们直接使用字符串常量来对字符数组进行初始化，依然会有第一种的问题，所以仍然需要多留一位。但要注意的是，第一种引发的是运行时的紊乱，而第二种引发的是编译错误，相比第一种更加容易发现。特殊的，可以采用这样的写法来对字符数组进行初始化：char str[]=&quot;helloworld&quot;;这样的写法可以不指定数组的长度，其内部会自动适配长度。但仅仅在对字符数组使用字符串常量进行初始化时可以不指定数组长度，其它类型/写法均不可以。 *仅在定义的时候可以用字符串常量对其进行赋值，在之后便不再可行，会引发编译错误。后续要操作的话只能按普通数组的方法。 对于二维数组，可以采用下述方法进行初始化：char a[][10]={&quot;hello&quot;,&quot;hi&quot;};第一维可以放空，若填写则不得少于字符串数量。第二维必填，不得少于最长的字符串长度+1。 一般不需要使用更多维的char数组。 在cstring头文件中，提供了下列函数来对字符数组进行操作。基本假设：设有char a[20]=&quot;hello&quot;,b[20]=&quot;hi&quot;; strcpy(目标，来源);此函数为复制函数，能将来源的字符串复制给目标。示例：strcpy(a,b);运行后a数组和b数组都将等于”hi”。 strcat(目标，来源);此函数为拼接函数，能将来源的字符串拼接到目标字符串后面。示例：strcat(a,b);运行后a数组将等于”hellohi”，b数组不变。 strlen(数组名称);此函数可以求出字符串长度（直到’\0’）。示例：strlen(a);求出来的值是”hello”的长度5。因为a数组内部有赋值的部分是’h’,’e’,’l’,’l’,’o’,’\0’，strlen会从下标0开始往后计算直到第一个’\0’之前。*若令a[2]=&#39;\0&#39;，则a数组内部有赋值的部分变为’h’,’e’,’\0’,’l’,’o’,’\0’，将导致strlen所求得的值变为2。*若令a[0]=&#39;\0&#39;，则a数组内部有赋值的部分变为’\0’,’e’,’l’,’l’,’o’,’\0’，将导致strlen所求得的值变为0。 strcmp(数组1名称，数组2名称);此函数可以按字典序比较数组1中的字符串1与数组2中的字符串2的大小。若字符串1大则返回正数，小则返回负数，一样大则返回0。*字典序的比较方法：设有char a[]=&quot;13&quot;,b[]=&quot;120&quot;;字典序是逐位比较的。先比较下标0的位置，发现字符串1和2的该位置都是’1’，则继续比较下标1的位置，发现字符串1的该位置是’3’而字符串2的该位置是’2’，因为’3’&gt;’2’，所以字符串1比字符串2大。再设有char a[]=&quot;12&quot;,b[]=&quot;120&quot;;先比较下标0的位置，发现字符串1和2的该位置都是’1’，则继续比较下标1的位置，发现字符串1和2的该位置都是’2’，则继续比较下标2的位置，发现字符串1的该位置是’\0’而字符串2的该位置是’0’，因为’\0’&lt;’0’，所以字符串1比字符串2小。 以上就是对于字符数组的相关描述。对字符串的了解有没有清晰一些呢？现在开始介绍string类型，也即字符串类型。 字符串类型使用string类型需要包含string头文件。 上面说到，一个一维字符数组可以表示一个字符串。那么对于string类型，该如何表示一个字符串呢？答案是一个变量即可。string在有string头文件的情况下可以如int等类型一般使用。示例：string str=&quot;helloworld&quot;;对于string类型，无需指定字符串长度，其内部会自动适配。且string类型可以在任意时候更改其赋值。如，可以在上述已有定义的情况下，令str=”hi”，则str会变成字符串”hi”。尽管我们上述声明的str仅仅是一个变量，不是数组，但因为它是string类型，所以我们也可以使用下标来访问它内部的字符。如在string str=”helloworld”的基础上，我们可以访问str[4]得到其第五个字符’o’，也可以令str[4]=’r’使得str变为”hellrworld”。 同样的，对于string类型，我们也可以使用数组。如string str[2]={&quot;hi&quot;,&quot;helloworld&quot;};可以通过str[i]来访问在str数组中下标为i的字符串，也可以通过str[i][j]来访问在str数组中下标为i的字符串的下标为j的位置。更多维数组同理。 在string头文件中，提供了下列成员函数来对string类型变量进行操作。基本假设：设有string a=&quot;hello&quot;,b=&quot;hi&quot;;（以下基于与上文中适用于字符数组的函数的对比） a=b;可以直接令a的值等于b的值，使用赋值符号即可。 a=a+b;可以直接令字符串a和字符串b拼接在一起产生一个新的字符串，然后再把这个新的字符串赋值给a。 length();可以求得字符串a的长度（求值方法与strlen一致）。 直接使用运算符进行比较。比较方法仍然是根据字典序（详见上文）。 以上，我们可以显而易见地发现，使用string类型比使用char数组更为方便。故实际使用时，若无特殊要求，一般建议使用string类型。 第五章到此结束。 本章练习：P1055 ISBN号码P1200 [USACO1.1]你的飞碟在这儿Your Ride Is HereP1308 统计单词数P1914 小书童——密码P1553 数字反转（升级版）]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语言-4-数组]]></title>
    <url>%2Fcpp%2Fcpp-4%2F</url>
    <content type="text"><![CDATA[本章学习数组的定义及使用方式。数组，实际上就是一段连续的存储区间，概念上就是一个变量（元素）的集合。以变量作为例子，每定义一个变量，就相当于为这个变量声明了一个存储空间，用来保存它的值。而当你声明了很多变量时，比如你声明了10个不同变量，那就在内存里占用了10个单位的存储空间。但是，如果你使用数组的话，声明长度为10的数组，也相当于占用了10个单位的存储空间，且是连续的，所以又叫存储区间。语句就是：类型 名称[长度];如：int a[10];其中数组名称的命名要求也与变量一致。设名称为a，长度为n，用一张表格来表示的话，就是下面这样。 a0 a1 a2 … a(n-2) a(n-1) 值1 值2 值3 … 值n-1 值n 这样的一张表格，就表示一个数组。有0~n-1一共n个元素，每个元素对应一个值，并且每个元素都可以完全像变量一样使用。也可以用一个0~n-1的整数坐标轴来表示，每个整数点上有一个值。效果就相当于你定义了a0，a1，a2，…，an-1一共n个变量。简单说，就是： 可以当做变量使用。 是一个有n个不同下标的元素的集合。 如上，这是一维数组。那么二维数组怎么表示呢？int a[n][m];这样就是定义了一个n*m个单位的二维数组。表格形式如下。 a 0 1 2 … m-2 m-1 0 … 1 … 2 … … … n-2 … n-1 … 每个元素属于某一行某一列，设i表示行，j表示列，则当i和j确定时，所对应的元素唯一确定。以此类推，还有三维数组，四维五维……不过常用的就是一维和二维了。 当一个数组定义后，我们可以通过“数组下标”来访问数组内的元素。所谓“数组下标”就是数组后中括号里填的东西。如，假设我们现在有一个定义：int a[100];则我们可以使用a[i]来访问a数组中下标为i的元素，i的范围为0-99。发现了吧？假设数组被定义的长度为n，则可以使用的下标范围就是0~n-1，这正是上文中之所以写a0,a1,…,an-1的原因。这不以编程人员的意志为转移。哪怕你不使用下标为0的位置，它还是在那里，你最大可使用下标还是n-1。所以，设有int a[100];则对于每一个a[i]，都可以像普通变量一样使用。a[i]可以参与运算，也可以在等式左边来接受一个值。如int b=a[1];表示定义一个int类型变量b，并令其等于a数组第二个元素的值。同样的，也可以写a[10]=100;表示令a数组的第十一个元素的值等于100。同理，对于二维数组，可以使用a[i][j]来访问a数组中第i行第j列的元素。两个维度的下标范围各自分离。如有int a[n][m];则在a数组中第一维下标范围为0~n-1，第二维的下标范围为0~m-1。二维数组的a[i][j]，就如同一维数组的a[i]，就如同普通变量，可以参与运算或在等式左边来接受一个值。更多维数组可以以此类推。 但是数组只是定义的话，依然也是如同定义的变量一样，初始是未赋值状态。已知我们可以int a=0;来定义一个int类型的变量a，并对其赋初始值0。那么我们想对数组也进行每个位都赋初始值，该怎么做呢？可以写成如下形式：int a[100]={0};如上语句声明了一个int类型的数组a，有100个单位，将其每个单位都赋值为初始值0。但要注意的是，如果想赋初始值1，这样写是不行的：int a[100]={1};这样将导致只有a[0]的值被初始化为1，其余位仍然都是0。我们称这个1为显式指定的初始值。当使用大括号初始化时，数组会按顺序分配所有显式指定的初始值，而对没有显式指定的其余位置均分配为0。例如，int a[100]={3,1,2,4};这样会按顺序令a[0]=3,a[1]=1,a[2]=2,a[3]=4，之后令其余位置均赋初始值为0。所以，如果想全部初始化为1，则要么手写n个1在大括号里，要么用循环令a[i]=1。而对于多维数组，我们则需要使用嵌套大括号。假设有int a[2][3];则可以以如下方式初始化：1int a[2][3]=&#123;&#123;3,4,5&#125;,&#123;1,2,3&#125;&#125;; 因为数组第一维的容量是2，所以在最外层大括号中嵌套两层大括号，表示分别对第一维的每一行的三列进行初始化。而因为数组第二维容量是3，所以在每个第二级大括号里写3个数。上述声明执行过后，会令a[0][0]=3,a[0][1]=4,a[0][2]=5,a[1][0]=1,a[1][1]=2,a[1][2]=3。但其实写成这样：int a[2][3]={3,4,5,1,2,3};结果也与上述写法相同，只是对于人类来说没有那么直观。为什么会一样呢？因为数组内部在分配顺序的时候，是从最后一维开始分配的，比如有三维数组a[2][2][2]，则顺序是a[0][0][0],a[0][0][1],a[0][1][0],a[0][1][1],a[1][0][0],a[1][0][1],a[1][1][0],a[1][1][1]。可见，顺序的规则是恒定不变的，需要的是程序员来调整初始化数值的顺序。需要注意的是，如果不采用嵌套大括号，则必然是按顺序初始化。而采用嵌套大括号的话，可以按需求针对不同维度进行初始化。示例如下：假设有二维数组:int a[4][4];则我可以写:1int a[4][4]=&#123;&#123;0,1,1&#125;,&#123;1,2&#125;,&#123;3,1,4,5&#125;,&#123;6&#125;&#125;; 进行初始化。初始化的结果为：1234a[0][0]=0,a[0][1]=1,a[0][2]=1a[1][0]=1,a[1][1]=2a[2][0]=3,a[2][1]=1,a[2][2]=4,a[2][3]=5a[3][0]=6 其余单位因为没有显式指定而均为0。 第四章到此结束。 本章练习：P1046 陶陶摘苹果P1427 小鱼的数字游戏P1428 小鱼比可爱P1567 统计天数P1047 校门外的树P2141 珠心算测验]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语言-3-循环语句及选择语句]]></title>
    <url>%2Fcpp%2Fcpp-3%2F</url>
    <content type="text"><![CDATA[本章学习循环结构和选择结构的基本用法。 循环语句while语句while语句实现”当型”循环，它的一般格式为：1234while (判断条件)&#123; 循环体&#125; 1、当判断条件成立时，循环执行大括号中语句。并且初始化部分和迭代部分是任选的。2、while语句首先检查判断条件，当条件满足时，才去执行循环中的语句。这是”当型”循环的特点。 do-while语句do-while语句实现”直到型”循环，它的一般格式为：1234do&#123; 循环体&#125;while (判断条件); 1、do-while语句首先执行循环体，然后检查判断条件，若成立，则循环执行大括号中的语句，直到判断条件不成立。2、与while语句不同的是，do-while语句的循环体至少执行一次，是”直到型”循环的特点。 for语句for语句也用来实现”当型”循环，它的一般格式为：1234for (初始化操作;判断条件;迭代部分)&#123; 循环体&#125; 1、for语句执行时，首先执行初始化操作，然后检查判断条件是否满足，如果满足，则执行循环体中的语句，最后执行迭代部分。完成一次循环后，重新判断终止条件。2、可以在for语句的初始化部分声明一个变量，它的作用域为一个for语句。3、for语句通常用来执行循环次数确定的情况(如对数组元素进行操作)，也可以根据循环结束条件执行循环次数不确定的情况。4、在初始化部分和迭代部分可以使用逗号语句，来进行多个动作。逗号语句是用逗号分隔的语句序列。例如：1234for(i=0,j=10;i&lt;j;i++,j--)&#123; 循环体&#125; 5、初始化、终止以及迭代部分都可以为空语句，且只要判断条件为空，就相当于一个无限循环，如：1234for(i=0;;i++)&#123; 循环体&#125; 循环语句的控制1、break跳出当前所在循环，忽略break以下的所有语句。2、continue直接执行下一次循环，忽略continue以下的所有语句。 条件语句if-else语句一般格式为：12345678if(判断条件)&#123; 语句1&#125;else&#123; 语句2&#125; 当判断条件成立时，执行语句1，否则执行语句2。 switch语句一般格式为：123456789101112switch(变量)&#123;case 值1: 语句1; break;case 值2: 语句2; break;default: 语句3; break;&#125; 当变量为值1时执行语句1，当为值2时执行语句2，当不为已给出的任何情况时执行default的语句3。case可以无限添加，不只限2个。需要注意的是，当你没有break时，会一直向下执行。如以下程序段，若变量为值1，则语句1,2,3都将被执行。12345678910switch(变量)&#123;case 值1: 语句1;case 值2: 语句2;default: 语句3; break;&#125; 逻辑判断符号小于：&lt; 大于：&gt; 等于：==（两个等号） 小于等于：&lt;= 大于等于：&gt;= 不等于：!=特别的，计算时用的等于只有一个等号，判断时才用两个等号。逻辑联结符号且：&amp;&amp; 或：||或的符号由两个竖线组成，竖线可以由回车上方的那个键打出。如：1234if(((x&gt;1||x&lt;-1)&amp;&amp;y&gt;2)||(x&lt;-9&amp;&amp;y&gt;0))&#123; sum=sum+1;&#125; 这样表示当满足以下两种情况之一时，sum的值+1。① x大于1且y大于2，或x小于-1且y大于2时。② x小于-9且y大于0时。特别的，使用if(条件1||条件2)的时候，如果条件1成立，则不会判断条件2是否成立，直接进入if的语句块。上述两种符号也属于运算符。使用逻辑符号时的要点*不可以写连等式，如：如果x大于0小于100，不可以写if(0&lt;x&lt;100)，必须拆开，写成if(0&lt;x&amp;&amp;x&lt;100)。其余逻辑符号同理。 第三章到此结束。 本章练习：选择语句：P1422 小玉家的电费P1085 不高兴的津津P1089 津津的储蓄计划P1909 买铅笔T16594 小明的四则运算 循环语句：P1008 三连击P1035 级数求和P1423 小玉在游泳P1424 小鱼的航程(改进版)P1980 计数问题T17068 有多少平方数T17072 是质数吗？T17073 什么？！n！T17071 四个数的2nd问题]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语言-2-数据类型与输入输出]]></title>
    <url>%2Fcpp%2Fcpp-2%2F</url>
    <content type="text"><![CDATA[本章将学习基本数据类型与输入输出的方法。首先，请大家先熟悉下面的计算指定的a+b的和并输出的代码。1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b; c=a+b; cout&lt;&lt;c; system("pause"); return 0;&#125; 样例输入：2 3样例输出：5在前一篇中讲过的部分就不再赘述，直接从第五行开始讲起。 第五行：int a,b,c;定义三个变量，分别叫做a,b,c，返回int类型（整型），句末要有分号。可以在定义里赋值，如int a=1,b=1,c=1;。int后面要有一个空格。 常用数据类型：short有符号（即表示有正负，下同）短整型，范围-32768~32767（-2^15~2^15-1），只支持整数。unsigned short无符号短整型，范围0~65535（2^16-1），只支持整数。int有符号整型，范围-2147483648~2147483647（-2^31~2^31-1），只支持整数。unsigned int无符号整型，范围0～4294967295（2^32-1），只支持整数。long long有符号长整型，范围-9223372036854775808~9223372036854775807（-2^63~2^63-1），只支持整数。unsigned long long无符号长整型，范围0~18446744073709551615（2^64-1），只支持整数。float单精度，支持小数，有效数字约8位，范围-3.40(10的38次方)~3.40(10的38次方)。double双精度，支持小数，有效数字约16位，范围-1.79(10的308次方)~1.79(10的308次方)。char有符号字符型，不支持字符串，范围-128~127。unsigned char无符号字符型，不支持字符串，范围0~255。string字符串，在第五章中有具体说明。bool布尔型，范围true或false，即非0或0。*当遇见有的程序只写一个unsigned时，默认是unsigned int。*在没有特殊强调时，整数类型一般用int，超过int的范围时可以使用long long或unsigned long long，别的一般不常用；浮点数类型一般用double，少用float。 标识符：上文中提到的变量，就是标识符的一种。对于所有的标识符，均需要满足如下名称要求： 只能是字母或下划线开头，严格区分大小写。 不可以包含数字或字母或下划线以外的其余符号。 不可以是系统正在使用的名称。如在linux系统中time是一个系统变量，则不可以使用time作为变量名称。 变量定义的写法： 定义一个int类型的变量a，写作int a; 定义一个long long类型的变量a，写作long long a; 定义一个float类型的变量a，写作float a; 定义一个double类型的变量a，写作double a; 定义一个char类型的变量a，写作char a; 定义一个string类型的变量a，写作string a; *string在编程环境中不会变色，但仍是可用类型。*要使用string类型，需要#include&lt;string&gt;。*string的具体用法在第五章中有具体说明。*定义里可以直接赋值，如int a=123;*定义里一句可以写多个变量，如int a,b,c;*如在定义时直接对变量赋值，需要对每个想赋值的变量都赋值。&ensp;如：int a,b=1;则a是未赋值变量，b被赋值为1&ensp;再如：int a=2,b=1;则a被赋值为2，b被赋值为1 第六行：cin&gt;&gt;a&gt;&gt;b;按顺序输入一个变量a和一个变量b。cin包含在iostream中。句末有分号。*每输入一个变量都需要写两个&gt;符号（该符号是半角大于号），箭头指向要输入的变量。*cin和cout会自动识别输入/输出的值的类型，无需特意说明。*若是使用cstdio头文件的话，需要写成scanf(“%d%d”,&amp;a,&amp;b);句末有分号，在变量前需加&amp;这个符号，相邻变量以逗号隔开。&quot;%d&quot;的意思是按整型来操作，有两个变量所以写两个%d。*scanf会比cin快一些，在输入量很大（大于10万个数据）时建议使用scanf。printf同理。 对于scanf和printf，其均满足以下写法：scanf(格式说明字符串,操作数);printf(格式说明字符串,操作数);其中，scanf和printf均可以只写格式说明字符串而不写操作数。当且仅当格式说明字符串中出现格式说明符（又叫占位符）时，才填写操作数。并且，scanf和cin一样，均会自动跳过回车，且在格式说明符不为%c和%s时均会跳过空格。 示例：仅格式说明字符串：scanf(&quot;a=b=&quot;);当输入是a=b=时可以正常执行printf(&quot;a=b=&quot;);输出字符串a=b=仅占位符：scanf(&quot;%d%d&quot;,&amp;a,&amp;b);当输入仅有两个数字时可以正常执行，按格式说明符%d来操作变量a和bprintf(&quot;%d&quot;,c);按格式说明符%d来操作变量c混用：scanf(&quot;a=%d,b=%d&quot;,&amp;a,&amp;b);当输入格式满足例如a=1,b=2时（就连逗号也不能漏掉），输入取得值1和2，分别赋值给a和bprintf(&quot;c=%d&quot;,c);将会原样输出c=，之后将变量c的值按格式说明符%d操作后，输出值 又如，本文开头的代码段可以转化为如下代码段，样例也可转化为对应样例：1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,c; scanf(“a=%d,b=%d”,&amp;a,&amp;b); c=a+b; printf(“c=%d”,c); system("pause"); return 0;&#125; 样例输入：a=2,b=3样例输出：c=5 注意到上文中，scanf的操作数前有加”&amp;”符号，而printf的操作数前没有。关于&amp;，将会在第十章中说明。 附，常见格式说明符：%d，表示按int类型处理%lld，表示按long long类型处理%ull，表示按unsigned long long类型处理%c，表示按char类型处理%s，表示按char数组来进行处理（关于数组，后续章节会讲到）%f，表示按float类型处理%lf，表示按double类型处理（因为double本质上是long float，所以其格式操作符取long float的缩写）上述格式操作符均会跳过空格和换行符。也就是说，在使用cin、或在scanf中使用上述格式操作符时，输入的不同值可以使用空格或换行符隔开。 关于格式操作符的特殊操作（以下仅1可以适用于scanf，其余均仅适用于printf）：1、按照指定宽度保留数字的方法：如对int类型保留4个数字的位宽，格式操作符可选用%4d*当数字的实际宽度大于要保留的位宽时，按照原宽度输出。所以若是%0d，就是按原宽度输出*当数字的实际宽度小于要保留的位宽时，将数字右对齐，并在左边补空格填充2、保留指定位数的小数（直接舍去，并不四舍五入）的方法：如对double类型保留两位小数，格式操作符可选用%0.2lf对其中0的说明，参加第1条；而小数点后的2，就表示保留两位小数此种情况下，0可以省略，如%0.2lf与%.2lf等效*内部操作是先计算保留小数，再计算保留位宽*对于小数，小数点也占一个位宽，所以如对于2.15使用格式说明符%4.1lf的话，会因为先计算保留1位小数而变为2.1，此时位宽为3。再因为保留4个位宽，而在2.1前补一个空格后输出3、可以使用0来代替空格进行填充（填充后需符合保留小数位数的要求，以及不能改变原数字大小）：如对于int类型数字100，使用格式操作符%4d，本来是在左边填充一个空格，如果改用格式操作符%04d的话，就会变成在左边填充一个0，这样执行printf(&quot;%04d&quot;,100);就会输出01004、可以使用-来实现左对齐如对于int类型数字100，使用格式操作符%-4d，就会在100右边填充一个空格后输出但如果使用格式操作符%-04d，并不会在右边填充一个0，因为这样会改变100原本的值，所以输出会是100和一个空格 综上，如果想对一个double类型的变量a，保留5位位宽，保留1位小数，用0填充空位，实现左对齐的话，可以写成：printf(&quot;%-05.1lf&quot;,a); 第七行：c=a+b;本句的执行过程是，先计算a+b的值，再赋值给c。本语句称之为赋值语句。赋值语句的等号左边必须是一个可以被赋值的对象。其中，对于+号，=号，我们均称之为运算符。常见运算符有：+,-,*,\，分别表示加减乘除=，表示赋值，先计算等式右边的值，再赋值给左边的对象%，表示取模，功能类似于取余数。如int a=100%7;最终c的值将等于100除以7的余数2+=，表示自加运算。如i+=2，表示i=i+2。其它的-=，*=，/=，%=同理++，表示自加1运算。如i++，表示i=i+1。三个或更多加号则不成立，只有两个+号的++可以表示自加运算。*特别的，++有前置和后置两种写法，如i++和++i，最终都会导致i=i+1。*当i++或++i单独存在时，它们并无区别。但当它们处于赋值语句中时，会引发差别。i++是先取得i的值，再自加；++i是先自加，再取得i的值。如，现在有int i=1,a;然后令a=i++，则先取得i的值1，赋值给a，然后i再自加，i变成2，所以执行完后a=1，i=2。相对的，如现在有int i=1,a;然后令a=++i，则i先自加，i变成2，再取得i的值2，赋值给a，所以执行完后a=,2，i=2。–与++同理。只有加减有这种写法，别的没有。 第二章到此结束。感谢PTW对本文的援助。 本章练习：P1001 A+B ProblemP1421 小玉买文具P1425 小鱼的游泳时间]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语言-1-入门篇]]></title>
    <url>%2Fcpp%2Fcpp-1%2F</url>
    <content type="text"><![CDATA[本章用以给新手入门。首先，请大家先熟悉下面的，输出一串字符”helloworld”的代码。12345678#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;”helloworld”&lt;&lt;endl; return 0;&#125;//这是一句注释 该代码编译运行后，显示的结果如下面这一行： helloworld现在开始逐行解释。1、#include&lt;iostream&gt;，这句的意思是程序中包含一个叫做iostream的头文件，格式是#include&lt;&gt;，头文件名称填在单书名号中。单书名号结尾不需要加分号。需要包含多个头文件时换行写即可。例：#include&lt;iostream&gt;#include&lt;cstdio&gt;也有用双引号的，如#include&quot;cstdio&quot;，虽然这样也可以，不过建议写单书名号。区别在于双引号的是查找自己编写的类库（头文件），而单书名号是查找编译环境自带的类库。常用头文件有：iostream，这个单词由in/out stream组成，是标准输入输出流。cstdio，这个单词由c++ standard in/out组成，是标准输入输出。cmath，这个单词由c++ math组成，是数学库。cstring，这个单词由c++ string组成，是与字符处理有关的头文件。string，这个单词本身就存在，翻译名为“字符串”，使用string类型时需要包含该头文件。algorithm，这个单词本身就存在，翻译名为“算法”，主要包含一些现成的函数。有时候也会见到如”stdio.h”的头文件，这是C语言的头文件，不用管。请大家按C++写法写头文件。2、using namespace std;这句话，称为“使用(using)命名空间(namespace)std”，其中namespace就是“姓名”和“空间”两个单词的组合，称为“命名空间”。而std是standard的缩写，表示“标准的”。这句话写在所有include之后，不可修改。这是硬性规定，不做赘述。句末要有分号。不论包含多少头文件，都只需写一次。3、int main()main()表示主函数，括号不可丢，句末无分号。前面的int表示main函数返回int类型。这句其实也是硬性规定。4、左大括号，与第8行的右大括号匹配，构成一个封闭区域，表示main函数的函数体。大括号是函数的界限，表示这一组大括号里面的所有内容都属于这个函数。括号是一一匹配的，不会重复匹配，且每个左大括号只会匹配到离自己最近的且未被匹配的右大括号。5、cout&lt;&lt;&quot;helloworld&quot;&lt;&lt;endl;输出一个句子并换行。表示输出的是”cout”，是c++ out的缩写。要使用cout，需要包含iostream头文件。这个“句子”的专业表述为“字符串”，因为每个句子实际上都是由一串字符构成的。输出时，在输出的内容中没有双引号。endl是end line的缩写，表示一个换行符。所谓的换行符，就是通常意义上的回车。在输出换行符后，字符串末尾将如同被按下一个回车，光标会来到下一行。*每输出一个变量都需要写两个单书名号，箭头指向cout。&ensp;如cout&lt;&lt;a&lt;&lt;b&lt;&lt;c;//按先后顺序输出三个变量a，b，c。*直接按此方法输出时三个变量会连在一起，如a=1，b=2，c=3时，输入为123，这时需要手动添加空格作为分隔符，代码更改为cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c;输出变更为1 2 3。*cout支持两种换行符，endl和”\n”，如cout&lt;&lt;endl;或cout&lt;&lt;&quot;\n&quot;;都可以做到换行。*endl中是小写的L，而不是数字1。 既然cout是输出，相对的，就有输入。表示输出的是”cin”，是c++ in的缩写。要使用cin，需要包含iostream头文件。cin的用法，将在下一篇章中说明。6、return 0;表示正常结束程序。主函数的最后必须有这一句话，句末有分号，写在主函数中时不可改动。不论写在主函数的何处，只要程序执行时遇到这句话，都将使得程序正常结束。7、右大括号，与第4行的左大括号匹配，构成一个封闭区域，表示main函数的函数体。大括号是函数的界限，表示这一组大括号里面的所有内容都属于这个函数。括号是一一匹配的，不会重复匹配，且每个右大括号只会匹配到离自己最近的且未被匹配的左大括号。8、两个除号，//，表示注释，程序将会忽视在//之后的这一行的所有内容如果需要多行注释，可以选择/*内容*/的方式，程序将会忽略/*和*/之间的所有内容。示例：这里还没被忽略//这句会被忽略 这句也没被忽略 1234/*我们这几行全都被忽略了*/ 以上，就是对于本篇开头的代码段的完整解释。至此，可以总结出一个C++程序的基本框架。写程序时可以先打好该框架，然后再继续填充。框架如下：1234567#include&lt;iostream&gt;using namespace std;int main()&#123; return 0;&#125; 到此，第一章结束！感谢PTW对本文的援助。]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fothers%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这篇文章是Hexo自带的文章，有兴趣的各位可以浏览。Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
</search>
