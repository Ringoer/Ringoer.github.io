<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ringo&#39;s Coding Life</title>
  
  <subtitle>OI to ACM</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-11T07:02:42.028Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ringoer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Welcome to No. 68 Floating Island</title>
    <link href="http://yoursite.com/uncategorized/mainpage/"/>
    <id>http://yoursite.com/uncategorized/mainpage/</id>
    <published>2332-12-31T16:00:00.000Z</published>
    <updated>2019-03-11T07:02:42.028Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"><b><font size="6">Are You Going To Scarborough Fair ?</font></b></p><br><img src="http://pic.ringoer.com/id63819688.png" alt="id=63819688" title="id=63819688"><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;b&gt;&lt;font size=&quot;6&quot;&gt;Are You Going To Scarborough Fair ?&lt;/font&gt;&lt;/b&gt;&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;http://pic.ringoer.com/id63819688
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue 响应式原理</title>
    <link href="http://yoursite.com/frontend/vue-reactivity/"/>
    <id>http://yoursite.com/frontend/vue-reactivity/</id>
    <published>2020-12-23T15:47:00.000Z</published>
    <updated>2020-12-23T14:58:03.205Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 最重要的部分，就是响应式原理了</p><a id="more"></a><hr><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">点我查看官方讲解</a></p><h1 id="data"><a href="#data" class="headerlink" title="data"></a>data</h1><p>众所周知，给 vue 实例设置数据一般是这么写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            n: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在改写一下上述代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rawData = &#123;</span><br><span class="line">    n: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> rawData</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(rawData)</span><br></pre></td></tr></table></figure><p>有什么不同呢？在第一个例子中你不能观测到 vue 对 data 返回的对象做了些什么，因为这个对象是个匿名对象</p><p>现在你发现，打印出来的 rawData 变了！它不再是个单纯的 <code>{n:0}</code>，而是变成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;__ob__: _e&#125;</span><br><span class="line">    n: (...)</span><br><span class="line">    __ob__: _e &#123;value: &#123;…&#125;, dep: oe, vmCount: 1&#125;</span><br><span class="line">    get n: ƒ ()</span><br><span class="line">    set n: ƒ (e)</span><br><span class="line">    __proto__: Object</span><br></pre></td></tr></table></figure><p>类似上述模样，n 不再是一个单纯的 0 —— 尽管你访问 rawData.n 的时候，还是可以取到 0</p><p>这是怎么回事呢？？</p><p>原来 vue 在通过 data 取得实例数据之后，立即对实例数据进行了包装，将实例对象内的所有值都通过 <code>Object.defineProperty</code> 转化为了一组 <code>getter/setter</code>，然后拦截其 set 事件，获取更新消息，及时刷新视图</p><h1 id="新增字段"><a href="#新增字段" class="headerlink" title="新增字段"></a>新增字段</h1><p>上面提到，当在视图中使用了 data 中的数据，且该数据已经设置了监听时，数据更新会触发视图更新</p><p>但是这个自动设置监听的事件，是发生在生命周期的 beforeCreate 到 created 阶段执行的，简称为初始化阶段完成了数据监听的设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123;a&#125;&#125;&#123;&#123;b&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a: <span class="string">'x'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.b = <span class="string">'b'</span></span><br></pre></td></tr></table></figure><p>如上代码，视图上只会显示字符串 x，字段 b 因为是后加入的字段，所以没有设置监听</p><p>那不是初始化阶段添加的数据，要怎么渲染呢</p><p>一般有两种办法</p><ol><li>预先设置占位符</li><li>使用 vue 提供的设置方法</li></ol><p>对于占位符法，非常简单，只需要先定义好 b 就行了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123;a&#125;&#125;&#123;&#123;b&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a: <span class="string">'x'</span>,</span><br><span class="line">            b: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.b = <span class="string">'b'</span></span><br></pre></td></tr></table></figure><p>这样就会刷新视图</p><p>但是一般不知道未来会有多少字段，所以一般用 vue 提供的设置方法 <code>Vue.set</code></p><p>定义如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.set( target, propertyName/index, value )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用例</span></span><br><span class="line">Vue.set(vm, <span class="string">'b'</span>, <span class="string">'233'</span>)  <span class="comment">// 令 vm.b = '233'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以设置到子对象</span></span><br><span class="line">Vue.set(vm.obj, <span class="string">'n'</span>, <span class="number">0</span>)  <span class="comment">// 令 vm.obj.n = 0</span></span><br></pre></td></tr></table></figure><p>第一个参数是要设置的目标，第二个是字段名，第三个是字段值</p><p>上例中为 vm 这个实例设置字段 b，并将其值设置为字符串 233</p><p>通过这种方法添加的字段，自动带有监听器，更新时可以触发视图刷新</p><p>当 vue 实例是具名实例（如 vm）时，也可以使用 <code>vm.$set</code> 来设置字段，使用方法同 <code>Vue.set</code>，因为 <code>vm.$set</code> 就是 <code>Vue.set</code> 的一个别名</p><h1 id="数组变异方法"><a href="#数组变异方法" class="headerlink" title="数组变异方法"></a>数组变异方法</h1><p>需要注意的是，虽然数组定义约等于对象定义，但是 <code>Vue.set</code> 或 <code>vm.$set</code> 不可以为数组内元素添加监听器</p><p>为了监听数组的变化，vue 提供了 7 个基于 Array 的变异方法</p><ul><li>push</li><li>pop</li><li>shift</li><li>unshift</li><li>splice</li><li>sort</li><li>reverse</li></ul><p>之所以称之为”变异方法”，是因为 vue 实际上是对原方法进行了代理，除了正常调用原方法外，还会额外将数组变化通知给 vue 示例，从而在通过以上 7 个方法操作数组的时候，视图也会更新</p><h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h1><p>刚才虽然说，不通过 <code>Vue.set</code> 添加的属性，是没有监听器，不能渲染到页面上的</p><p>但是还是有特例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123;a&#125;&#125;&#123;&#123;b&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a: <span class="string">'x'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.a = <span class="string">'a'</span></span><br><span class="line">vm.b = <span class="string">'b'</span></span><br></pre></td></tr></table></figure><p>本来 b 应该说是后加入且没有监听器的，所以 b 理论上不会出现在视图上</p><p>但实际情况是，字符串 a 和 b 都出现在了视图上，也就是说两句赋值都成功了</p><p>这是怎么回事呢</p><p>结合之前学习的 javascript 事件循环，原来 vue 会缓冲在一次操作中涉及的视图变化，在当前宏任务中不会渲染视图，而是在下一个事件循环开始前才渲染视图</p><p>所以此处发生的情况如下</p><ol><li><p>改变了 vm.a，且 vm.a 有设置监听器，所以 vue 收到通知，将在下一个事件循环开始前渲染视图</p></li><li><p>当前事件循环还没结束，又对 vm.b 进行了赋值，所以现在 vm 上也有了数据字段 b</p><p>此时 b 上虽然没有监听器，但是监听器的作用就是触发视图渲染，而视图渲染已经被 a 触发了，所以 b 是躺赢2333</p><p>当然，此处是先改变 a，如果后改变 a，效果也是一样的，只要触发渲染，就会出现 b</p></li><li><p>当前事件循环结束，渲染视图，b 搭上了便车</p></li></ol><p>所以，有时候会因为某些后添加的变量搭上了便车，而造成一种这个变量也设置了监听的错觉，会引发一些潜在的 bug</p><p>出于面试需要，了解这个搭便车就可以了，实际写码的时候建议使用 <code>Vue.set</code></p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 最重要的部分，就是响应式原理了&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 构造选项</title>
    <link href="http://yoursite.com/frontend/vue-options/"/>
    <id>http://yoursite.com/frontend/vue-options/</id>
    <published>2020-12-22T15:46:00.000Z</published>
    <updated>2020-12-23T14:57:58.505Z</updated>
    
    <content type="html"><![CDATA[<p>new Vue()传入的参数，都有哪些呢</p><a id="more"></a><hr><p>可以查看 <a href="https://cn.vuejs.org/v2/api/#data" target="_blank" rel="noopener">官方文档</a> 获取详细解释</p><p>常用的有以下组分</p><table><thead><tr><th>数据</th><th>DOM</th><th>生命周期钩子</th><th>资源</th><th>组合</th></tr></thead><tbody><tr><td>data</td><td>el</td><td>created / beforeCreate</td><td>components</td><td>mixins</td></tr><tr><td>props</td><td>template</td><td>mounted / …</td><td>directives</td><td>extends</td></tr><tr><td>computed</td><td></td><td>updated / …</td><td></td><td>provide / inject</td></tr><tr><td>methods</td><td></td><td>destroyed / …</td><td></td><td></td></tr><tr><td>watch</td><td></td><td>activated / deactivated</td><td></td></tr></tbody></table><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>写作一个对象或一个函数，指明所属的 vue 实例所具有的变量值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    n: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论是以上哪种，一旦设置，n 立刻就会被 getter/setter 所代理，且访问 vm.n 就可以访问到 data 中所设置的 n</p><p>其中，在 vue 组件的定义中，只接受函数形式</p><p>而且对象形式有如下 bug</p><p>假设有一个 vue 组件，其 data 写作对象形式 n: 0</p><p>在 app.vue 中，import 了上述组件，假设命名为 demo</p><p>当 app.vue 渲染了两个 demo 时，这两个组件使用的是同一个对 n 的引用</p><p>一旦其中一个 n 变化，另一个也会同步</p><p>综上，建议 data 恒使用函数形式</p><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>用于向子组件传入参数</p><p>设有子组件有如下 props</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'props-demo-simple'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'size'</span>, <span class="string">'myMessage'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>则父组件在通过 html template 渲染子组件时，可以为该子组件传入 size 或 myMessage 属性，子组件可以像使用 data 一样直接使用 size 或 myMessage</p><p>可以为子组件的参数设置配置，参考配置如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'props-demo-advanced'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 检测类型</span></span><br><span class="line">    height: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 检测类型 + 其他验证</span></span><br><span class="line">    age: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">0</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>计算属性，用于快速求出一个值</p><p>假设当前 vue 实例有以下组分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        n: <span class="number">0</span>,</span><br><span class="line">        m: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">    mulNandM()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.n*<span class="keyword">this</span>.m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 mulNandM 尽管看起来像个方法，但是其结果会被缓存，并在其依赖的变量上设置监听</p><p>当该计算属性再次被访问时会直接返回对应结果，除非其监听的变量发生了变化</p><p>在计算属性外部，可以直接像访问成员变量一样访问计算属性</p><p>！！！注意！！！</p><p>computed 等内容严重依赖 this 指针，所以尽量不要使用箭头函数，因为箭头函数没有自己的 this 指针</p><p>下同，只要依赖 this 指针的，都强烈建议不要使用箭头函数</p><h2 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h2><p>顾名思义，就是 vue 实例的成员方法</p><p>上例中的计算属性也可以写作 methods</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    mulNandM()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.n*<span class="keyword">this</span>.m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就必须加上括号，以方法形式调用，且不会缓存</p><p>一般用于执行复杂逻辑，简单的取值之类的建议使用计算属性</p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>监视属性，用于监视当前实例上的 data 的变化</p><p>例如，某 vue 实例有以下组分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        n: <span class="number">0</span>,</span><br><span class="line">        m: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line">    n(newval,oldval)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`n changed from <span class="subst">$&#123;oldval&#125;</span> to <span class="subst">$&#123;newval&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则当 n 变化的时候就会打印调试语句</p><p>更多用法请看官方文档</p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="el"><a href="#el" class="headerlink" title="el"></a>el</h2><p>用于指示当前 vue 实例在页面上的挂载目标</p><p>通常 el 可以</p><ol><li>接受一个字符串作为其值，该字符串是一个 CSS 选择器</li><li>接受一个 HTMLElement 实例作为其值</li></ol><p>也可以不指定该参数，而是通过 export default 暴露给父组件，让父组件决定自己所在的位置</p><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>提供一个字符串模板作为 Vue 实例的标识使用</p><p>模板将会<strong>替换</strong>挂载的元素，挂载元素的内容都将被忽略，除非模板的内容有分发插槽。</p><p>例如如下配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">233</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>但是在 vue 组件中，一般不在 script 部分指定该参数，而是在 HTML template 部分直接写 HTML 模板</p><h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><p>官方文档提供了下图作为标准的生命周期图示</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="vue 生命周期"></p><p>通过图片可以看出，所谓”钩子”，和 aop 编程中的”切点”概念相仿，都是指某个范围的切入口</p><p>此处即是两个过程交接之处，类似于绿皮火车相邻两节车厢之间是用钩子连接的</p><p>通过图示，可以发现 vue 实例挂载到页面是在 created 阶段后，beforeMount 阶段前完成的</p><p>此时判断 vue 实例有没有指示 el 选项</p><ul><li>若有 el 选项，则直接挂载并继续编译</li><li>若无，则暂停当前实例的编译，直到显式挂载到页面上后才会继续编译</li></ul><p>继续判断有没有 template 选项，此处将 template 选项和 HTML template 模板分别称为内部和外部 template</p><p>若有内部，则内部的优先级高，否则使用外部模板</p><p>若都没有，则报错</p><p>除此之外，update 的两个钩子也要注意，当且仅当发生了重新渲染的时候，也就是页面上内容要改变的时候，才会触发 update 相关的两个钩子</p><p>若仅修改数据而对页面没有影响，不会触发这两个钩子</p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><h2 id="components"><a href="#components" class="headerlink" title="components"></a>components</h2><p>可以通过 components 选项引入子组件</p><p>示例如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sideBar <span class="keyword">from</span> <span class="string">'./components/common/sidebar'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    sideBar</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此时可以在 template 中使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sideBar</span>&gt;</span><span class="tag">&lt;/<span class="name">sideBar</span>&gt;</span></span><br></pre></td></tr></table></figure><p>来引入子组件的 template 进行渲染</p><h2 id="directives"><a href="#directives" class="headerlink" title="directives"></a>directives</h2><p>用于自定义当前实例可用的模板指令</p><p>例子如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 focus 指令，之后可以在模板中使用 v-focus</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个指令都可以绑定专有的钩子函数，详见 <a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">文档</a></p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><h2 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h2><p>将待混入的对象混入到 vue 实例中，相同的属性会合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>) &#125;,</span><br><span class="line">  mixins: [mixin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上例，最终两个 created 阶段的 function 都会在 vm 实例的 created 阶段执行，输出 1和2</p><h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>与 mixins 类似，使得当前实例继承另一个实例的所有值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompA = &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在没有调用 `Vue.extend` 时候继承 CompA</span></span><br><span class="line"><span class="keyword">const</span> CompB = &#123;</span><br><span class="line">  extends: CompA,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例，CompA 的所有内容会在 CompB 内被展开</p><h2 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a>provide / inject</h2><p>由父组件提供（provide）一个对象或方法，并注入（inject）到子组件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    provide () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            reload: <span class="keyword">this</span>.reload</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            isRouterAlive: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        reload () &#123;</span><br><span class="line">            <span class="keyword">this</span>.isRouterAlive = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.isRouterAlive = <span class="literal">true</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，父组件提供了一个 reload 方法实现局部刷新</p><p>然后在子组件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    inject: [<span class="string">'reload'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就成功向子组件注入了 reload 方法，在子组件中也可以通过 this.reload() 来实现局部刷新了</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;new Vue()传入的参数，都有哪些呢&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 起步</title>
    <link href="http://yoursite.com/frontend/vue-start/"/>
    <id>http://yoursite.com/frontend/vue-start/</id>
    <published>2020-12-22T03:47:00.000Z</published>
    <updated>2020-12-22T14:04:24.096Z</updated>
    
    <content type="html"><![CDATA[<p>前端三大框架中相对最简单的 Vue 框架，该怎么上手呢</p><a id="more"></a><hr><p>Vue 这么大名头，就不赘述什么了2333</p><p>直接上 <a href="https://cn.vuejs.org/index.html" target="_blank" rel="noopener">官方文档</a></p><p>因为作者是中国人，所以中文文档很有参考价值，就直接贴中文文档了（</p><h1 id="快速创建-vue-项目"><a href="#快速创建-vue-项目" class="headerlink" title="快速创建 vue 项目"></a>快速创建 vue 项目</h1><p>点击官方文档首页上的 起步，可以来到介绍</p><p>通常有以下方法来创建一个 vue 项目</p><h2 id="script-标签-cdn"><a href="#script-标签-cdn" class="headerlink" title="script 标签+cdn"></a>script 标签+cdn</h2><p>通过</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以在 html 页面上引入 vue 内容，推荐小型项目使用</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>通过命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue</span><br></pre></td></tr></table></figure><p>可以安装 vue 最新稳定版，推荐大型项目使用</p><h2 id="vue-脚手架"><a href="#vue-脚手架" class="headerlink" title="vue 脚手架"></a>vue 脚手架</h2><p>可以使用官方提供的 <code>@vue/cli</code> 快速构建 vue 项目</p><p>官方介绍如下</p><blockquote><p>它为现代前端工作流提供了 batteries-included 的构建设置。只需要几分钟的时间就可以运行起来并带有热重载、保存时 lint 校验，以及生产环境可用的构建版本。</p></blockquote><p>可以查阅 cli 对应的 <a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">官网</a></p><p>具体使用方法如下</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli-service-global</span><br></pre></td></tr></table></figure><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-world</span><br></pre></td></tr></table></figure><p>此时 vue 会询问你，是否采用默认的配置，建议新手选”是”</p><p>选否的话，vue 会询问你具体的各个配置的选项，此时使用方向键的上下来选择选项，并通过空格选定</p><p>注意，此时按回车的话会直接决定这个询问的结果，进入下个询问</p><p>当然你后悔的话，ctrl+c 就可以了，2333</p><p>在询问完所有配置后，vue 会询问你是否保存上述配置为默认配置，这里一般也建议选否</p><p>命令行不习惯的话，也可以用图形化界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure><p>通过上述命令可以打开一个浏览器窗口以显示图形化界面来操作 vue</p><h2 id="codesandbox-io"><a href="#codesandbox-io" class="headerlink" title="codesandbox.io"></a>codesandbox.io</h2><p>什么？我一句命令行也不想打？可以！</p><p>可以访问 <a href="https://codesandbox.io/" target="_blank" rel="noopener">codesandbox.io</a> 来创建 vue 项目</p><p>注意，此时不要登录，登录会有创建数量限制，不登录则无限</p><p>打开页面后直接访问右上角的 create sandbox，在新弹出的菜单中选择 vue 即可创建一个 vue 项目</p><p>codesandbox 提供了在线的热更新，但因为是在线的，所以会略有延迟</p><p>为了解决这个延迟，codesandbox 也提供了下载到本地的方法：</p><ol><li>找到代码编辑界面左上角的 file 选项</li><li>选择 export to zip</li></ol><p>ok！你下载了一个 zip，解压就可以得到你的 vue 项目了，方便快捷</p><p>其效果类似于用 idea 创建 spring boot 项目的时候的 spring assistant，什么都不用做就有一个 helloworld 了2333</p><p>（不过命令行还是要学，不亏</p><h1 id="vue-不同版本"><a href="#vue-不同版本" class="headerlink" title="vue 不同版本"></a>vue 不同版本</h1><h2 id="有哪些版本"><a href="#有哪些版本" class="headerlink" title="有哪些版本"></a>有哪些版本</h2><p>在刚才的介绍中，完全没提及使用 vue 的哪个版本，其实各自有各自默认的版本</p><p>vue 有 2x2=4 种主要版本——完整版/非完整版+开发版/生产版</p><p>非完整版一般也称作仅运行版本（runtime only）</p><p>对应的文件名如下</p><table><thead><tr><th></th><th>完整版</th><th>非完整版</th></tr></thead><tbody><tr><td>开发版</td><td>vue.js</td><td>vue.runtime.js</td></tr><tr><td>生产版</td><td>vue.min.js</td><td>vue.runtime.min.js</td></tr></tbody></table><p>具体特点如下</p><ol><li>完整版，有完整完全的功能</li><li>非完整版，没有编译模板的功能，只支持渲染函数，体积比完整版小 30%</li><li>开发版，包含警告等内容</li><li>生产版，不含有警告，且体积比开发版更小，旨在让用户下载最少的 js</li></ol><h2 id="完整版和非完整版的区别"><a href="#完整版和非完整版的区别" class="headerlink" title="完整版和非完整版的区别"></a>完整版和非完整版的区别</h2><p>假设有如下 html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在意图在 app 中显示一个数字，并提供一个 button 使得点击后可以改变这个数字</p><p>如果你使用完整版，只需要这样写即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123;n&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="comment">// 此处通过 cdn 引入完整版 vue </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 js 中写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        n: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        add()&#123;</span><br><span class="line">            <span class="keyword">this</span>.n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者 html 的 app 中不写内容，而是写在 new Vue 内</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        n: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;n&#125;&#125;</span></span><br><span class="line"><span class="string">        &lt;button @click="add"&gt;+1&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        add()&#123;</span><br><span class="line">            <span class="keyword">this</span>.n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意，此处的 template 需要包裹在同一个 div 中</p><p>就可以实现点击按钮后自增，并同步到页面上</p><p>但是如果用非完整版，就不能这样写</p><p>首先 html 要改成这样</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="comment">// 此处通过 cdn 引入非完整版 vue </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 js 中写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        n: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    render(h)&#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">'div'</span>, [<span class="keyword">this</span>.n, h(<span class="string">'button'</span>, &#123;</span><br><span class="line">            on: &#123;<span class="attr">click</span>: <span class="keyword">this</span>.add&#125;</span><br><span class="line">        &#125;, <span class="string">'+1'</span>)])</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        add()&#123;</span><br><span class="line">            <span class="keyword">this</span>.n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>vue 提供的 render 方法接受一个参数，是 vue 封装好向开发者传来的渲染函数，一般命名为 h（因为文档里就是 h）</p><p>在上例中，h 函数接收 2 个或 3 个参数</p><p>如果只有两个参数，第一个表示其所属的 html 元素类型，第二个参数表示其显示文本</p><p>如果有三个参数，第一个参数同上，第二个参数表示其属性配置，第三个表示其显示文本</p><h2 id="非完整版的意义"><a href="#非完整版的意义" class="headerlink" title="非完整版的意义"></a>非完整版的意义</h2><p>既然非完整版这么麻烦，有什么价值呢？</p><p>答案就是大小和独立</p><p>在完整版中，vue 的参数直接侵入了模板 html，一旦发生修改，则全部都要改，在实际开发中很难同步；而采用 template 参数的话，又导致在 js 中混入了奇怪的不属于 js 的部件</p><p>在非完整版中，所有的局部配置都依赖于同一个 js，当发生修改的时候，只需要修改当前 js</p><p>最重要的是，非完整版支持 vue 组件化！便于控制不同部分的代码</p><p>综上，实际项目中，应该优先使用非完整版（为了更小体积），并且开发中使用开发版，发布的时候使用生产版</p><h1 id="vue-组件"><a href="#vue-组件" class="headerlink" title="vue 组件"></a>vue 组件</h1><p>创建 vue 项目后，就可以发现核心文件 main.js 和 app.vue</p><p>其中 app.vue 就是项目的主组件，并可以以类似逻辑创建 .vue 后缀的文件作为项目的新的 vue 组件</p><p>每个 vue 组件都包含以下 3 部分</p><ol><li><p>template，指示该组件的 html 模板，在需要填充时将该部分填充到 app.vue 的对应位置</p></li><li><p>script，指示该组件使用的 vue 实例的配置</p></li><li><p>style scoped，指示该组件使用的样式</p><p>注意，此处一般要注明 scoped 以使得样式只应用于当前组件，否则会应用到全局</p></li></ol><p>在用户访问时，router 组件会选择 component 并返回</p><p>当在 app.vue router-view 中选择 name=”default” 时，router 里不需要写对象，直接写目标组件即可</p><p>当选择 name=”xxx” 时，router 返回的 component 必须是对象，且包含你指定的 name 字段，该字段值是目标组件对象</p><h1 id="vue-与-SEO"><a href="#vue-与-SEO" class="headerlink" title="vue 与 SEO"></a>vue 与 SEO</h1><p>众所周知 vue 是单页应用，从上面的说明也看出了 vue 的特点：主页只有一个 div#app，没有别的东西，这样搜索引擎怎么知道你这个页面和什么有关系呢</p><p>可以在模板里写 meta 标签来指示本网站相关内容，或是在 div#app 中写入内容（反正会被 vue 渲染替换）</p><p>但是仍然治标不治本，SEO 效果仍然很差，这时候就需要——服务端渲染（SSR）</p><p>不过 SSR 已经远超本章内容了，就不描述了</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端三大框架中相对最简单的 Vue 框架，该怎么上手呢&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>20201222 本站写作方法</title>
    <link href="http://yoursite.com/diary/20201222/"/>
    <id>http://yoursite.com/diary/20201222/</id>
    <published>2020-12-22T03:30:00.000Z</published>
    <updated>2020-12-22T03:48:09.393Z</updated>
    
    <content type="html"><![CDATA[<p>昨天被 yuli 问了这回事，写一下吧</p><a id="more"></a><hr><h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><p>首先是打开 <code>hexo s</code> 然后新建一篇文章</p><p>新建之前，需要想好两点</p><ol><li>文章标题</li><li>文章分类</li></ol><p>因为 hexo 不会上传 markdown 源文件，所以在本地需要有个办法管理这些源文件，我在此处加个前缀</p><p>比如说，当文章是 others 或 diary 分类的时候（比如本文），就直接用日期作为前缀</p><p>再比如一篇 frontend 分类的文章，就用”前端”当前缀，如”前端-webpack 入门 1”</p><p>创建之后，因为 admin 会自动进入编辑页面，所以我也就顺手在编辑页面做一些设定</p><h1 id="文章初始化"><a href="#文章初始化" class="headerlink" title="文章初始化"></a>文章初始化</h1><p>主要在 admin 提供的编辑页面做如下工作：</p><ol><li><p>在文章 title 处去除前缀，只保留文件名上的前缀</p></li><li><p>在右侧设置一下文章的目录和标签</p></li><li><p>写一下文章的缩略语和 more 注释，例如本文就写以下部分</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">昨天被 yuli 问了这回事，写一下吧</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure></li></ol><p>这样，在 admin 上的部分就完成了，现在关掉本地服务器，改用 typora 写文章</p><h1 id="准备写文章"><a href="#准备写文章" class="headerlink" title="准备写文章"></a>准备写文章</h1><p>用 typora 打开文章后，需要做以下工作</p><ol><li>打开源代码模式，为本文附加一个 id（为了部署后文章路径好看）</li><li>回到渲染模式，全程使用渲染模式写文章</li><li>在 more 注释后加上分割线，在结尾处也加上分割线</li><li>拟定文章目录，先写好目录再填充内容</li></ol><h1 id="文章内联资源"><a href="#文章内联资源" class="headerlink" title="文章内联资源"></a>文章内联资源</h1><p>一篇文章内一般会有各种其它资源，比如图片，比如下载</p><p>我采取的策略如下</p><ol><li>能不能使用代码段表示？能就仅使用代码段</li><li>不能做到 1，那能不能使用图片表示？能就仅使用图片</li><li>最后才选择提供下载</li></ol><p>在使用图片的时候，我一般采取以下方案</p><ol><li><p>在专门的图片文件夹 “hexo 图片” 下新建一个图片文件夹，该文件夹名字与当前文章的 id 一致</p></li><li><p>当前文章所涉及的新图片都保存到该文件夹下，每个图片都命名为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`<span class="subst">$&#123;id&#125;</span>-<span class="subst">$&#123;index&#125;</span>.(png|jpg)`</span></span><br></pre></td></tr></table></figure><p>然后通过 markdown 图片引入的方式先插进文章中以便浏览</p></li><li><p>当文章完成后，将所需图片都上传到 cdn，再 ctrl+r 替换文章中对图片的引用路径</p></li><li><p>检查文章，提交</p></li></ol><p>若是提供下载，则是先预留超链接位置，写完文章后执行与图片第 3、第 4 步相同的步骤</p><p>以上</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天被 yuli 问了这回事，写一下吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="diary" scheme="http://yoursite.com/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>Webpack 入门 4</title>
    <link href="http://yoursite.com/frontend/webpack-4/"/>
    <id>http://yoursite.com/frontend/webpack-4/</id>
    <published>2020-12-18T14:55:00.000Z</published>
    <updated>2020-12-20T15:50:21.001Z</updated>
    
    <content type="html"><![CDATA[<p>天天 file 协议，我受够了，来个 server！Webpack 其之四</p><a id="more"></a><hr><p><a href="https://download.ringoer.com/webpack-demo-4.rar" target="_blank" rel="noopener">点我下载本章代码</a></p><h1 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h1><p>查看 <a href="https://www.webpackjs.com/guides/development/#%E4%BD%BF%E7%94%A8-webpack-dev-server" target="_blank" rel="noopener">webpack 官方文档</a>，发现有一个东西叫做 webpack-dev-server，而且也就它带一个 server 单词，试试看！</p><p>先安装它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure><p>然后照抄一下官方给的配置，发现是在 module.exports 下新增以下字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">'./dist'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及在 node 配置中新增以下字段</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"start": "webpack-dev-server --open"</span><br></pre></td></tr></table></figure><p>意思是当运行 <code>npm run start</code> 的时候，执行其值对应的命令行，其中 <code>--open</code> 的意思是自动打开默认浏览器</p><p>抄进我们的配置，start 一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>发现报错了……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Cannot find module &apos;webpack-cli/bin/config-yargs&apos;</span><br></pre></td></tr></table></figure><p>搜索发现，是默认安装的 webpack-cli 版本太高了，以至于和 webpack-dev-server 不兼容</p><p>这时候需要重装 webpack-cli 为合适的版本</p><p>依次运行下述命令可以重装 webpack-cli 为 3 版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall webpack-cli</span><br><span class="line">npm install webpack-cli@3 --save-dev</span><br></pre></td></tr></table></figure><p>现在再试试 start，发现成功打开了浏览器！</p><p>此时坐标 localhost:8080，默认根路径 / 就是我们指定的输出 index.html 的位置</p><p><img src="https://pic.ringoer.com/webpack-4-0.png" alt=""></p><p>尝试修改一下 style，比如背景色改成 blue</p><p>发现随着你在本地保存，浏览器里的页面也会自动更新</p><p>不只是 http 协议，webpack-dev-server 也支持热更新！</p><h1 id="不同的配置"><a href="#不同的配置" class="headerlink" title="不同的配置"></a>不同的配置</h1><p>但是这个 server 再怎么 server，终究还是个 dev，它在编译的时候就应该使用 development mode 而不是 production</p><p>让我们复制一下原来的 config，保存成两份</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js 默认使用 development 模式</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'My App'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].[contenthash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">        <span class="comment">// use: [</span></span><br><span class="line">        <span class="comment">//   'style-loader',</span></span><br><span class="line">        <span class="comment">//   'css-loader'</span></span><br><span class="line">        <span class="comment">// ]</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'file-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.prod.js 使用 production 模式</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'My App'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].[contenthash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'file-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候，我们直接 <code>npm run build</code> 的话，会使用默认的 development 模式的配置，怎么办呢</p><p>答案是修改 node 脚本配置，其中 build 字段改为如下值</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"build": "rimraf ./dist &amp;&amp; webpack --config ./webpack.config.prod.js"</span><br></pre></td></tr></table></figure><p>通过 –config 来指示此时使用哪个配置文件进行构建</p><p>现在再次 <code>npm run build</code>，也不会用错配置文件了！</p><h1 id="管理配置"><a href="#管理配置" class="headerlink" title="管理配置"></a>管理配置</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>配置分开后，我们又发现了新的问题：配置内容重复不少</p><p>重复可是编程一大弊病，必须要避免，容易想到抽出一个公共的配置</p><p>现在让我们把目录变成这样</p><ul><li>webpack.config.js，保存公共配置</li><li>webpack.config.dev.js，保存开发配置</li><li>webpack.config.prod.js，保存部署配置</li></ul><p>然后修改 node 脚本的 start 字段</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"start": "webpack-dev-server --config ./webpack.config.dev.js --open"</span><br></pre></td></tr></table></figure><p>接下来提取刚才两个配置文件中的公共部分</p><h2 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h2><p>显然除了模式、dev-server 有关配置外，其余部分基本一致</p><p>那么把共有部分提取一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js 共有部分配置</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'My App'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].[contenthash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">        <span class="comment">// use: [</span></span><br><span class="line">        <span class="comment">//   'style-loader',</span></span><br><span class="line">        <span class="comment">//   'css-loader'</span></span><br><span class="line">        <span class="comment">// ]</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'file-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.dev.js 使用 development 模式</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.prod.js 使用 production 模式</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在怎么引入呢</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>既然结尾是 js，那这个配置就是按照 js 的引入办法，通过 require 引入</p><p>插播一下，在 webpack 配置这边，遵循的是 AMD 规范，使用 require</p><p>而平时的 node 代码是遵循 CommonJS 规范，使用 import</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.dev.js 使用 development 模式</span></span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...base,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.prod.js 使用 production 模式</span></span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...base,</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处使用 spread 语法展开引入的 base，base 就是 require 的模块里的 <code>module.exports</code> 的值</p><p>现在就可以使得两个不同 mode 的配置，都继承同样的公共配置了</p><p>但是注意，现在不能随便覆写字段，比如我要在 dev mode 新增一个 loader 处理 scss</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...base,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          loader: <span class="string">"sass-loader"</span> <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果这样写，会导致覆写了从 base 引入的 loader，让 css loader 和 file loader 都消失，只有 sass loader</p><p>所以要引入新的专有 loader 的话，还要再应用一次 spread 语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    ...base.module,</span><br><span class="line">    rules: [</span><br><span class="line">        ...base.module.rules,</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"sass-loader"</span> <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有这样才可以保证不会覆写掉共有部分引入的 loader</p><p>其余部分的覆写也要注意这一点</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>手动引入还要注意使用 spread 语法以及避免错误覆写，有没有更方便的呢？有</p><p>搜索 webpack merge，找到其 github 项目主页</p><p>发现要安装，那就安装一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-merge --save-dev</span><br></pre></td></tr></table></figure><p>刚才 dev 的文件已经用了，现在就用 prod 的文件吧</p><p>先引入 merge</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br></pre></td></tr></table></figure><p>注意此处要使用解构赋值，否则引入后还要取模块的 merge 字段才行</p><p>然后连接 base 和新的配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = merge(base, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [&#123;</span><br><span class="line">        loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">"sass-loader"</span> <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>ok！最终效果和使用 spread 语法手动展开是一样的</p><p>merge 这个方法起如下的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    a: [<span class="number">11</span>],</span><br><span class="line">    b: <span class="number">45</span>,</span><br><span class="line">    c: <span class="number">1919</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    a: [<span class="number">514</span>],</span><br><span class="line">    b: <span class="number">114514</span>,</span><br><span class="line">    d: <span class="number">810</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = merge(a,b)</span><br></pre></td></tr></table></figure><p>最终 result 结果如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result === &#123;</span><br><span class="line">    a: [<span class="number">114</span>,<span class="number">514</span>],</span><br><span class="line">    b: <span class="number">114514</span>,</span><br><span class="line">    c: <span class="number">1919</span>,</span><br><span class="line">    d: <span class="number">810</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组取合并，相同取新值，不同均保留</p><p>就是这样~~</p><h1 id="感言"><a href="#感言" class="headerlink" title="感言"></a>感言</h1><p>Webpack 入门系列就到这里了，有兴趣深入的同学，可以查看 webpack 官方文档以及各个插件的官方文档</p><p>学好这几章提及的 webpack 基本原理，对于深入理解 vue 和 react 框架的打包机制是很有必要的（正是基于 webpack）</p><p>勘误可以联系我，谢谢！</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天天 file 协议，我受够了，来个 server！Webpack 其之四&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 入门 3</title>
    <link href="http://yoursite.com/frontend/webpack-3/"/>
    <id>http://yoursite.com/frontend/webpack-3/</id>
    <published>2020-12-18T14:54:00.000Z</published>
    <updated>2020-12-20T15:50:11.893Z</updated>
    
    <content type="html"><![CDATA[<p>现代互联网，资源摩多摩多！Webpack 其之三</p><a id="more"></a><hr><h1 id="扩展CSS-loader"><a href="#扩展CSS-loader" class="headerlink" title="扩展CSS loader"></a>扩展CSS loader</h1><p>既然已经加载了 CSS，就拿 CSS 的三个变种试试手吧</p><p>以下三个变种，都支持默认的 CSS 语法，也就是说直接拿一个 CSS 去改名，就是合法的三种文件</p><h2 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h2><p>在官方文档的 loader 中找到 sass-loader 章节</p><p>文档要求我们安装，那就先安装一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sass-loader dart-sass webpack --save-dev</span><br></pre></td></tr></table></figure><p>注意，文档要求我们安装的是 node-sass，但是这个已经过时了，应该安装更新的 dart-sass</p><p>安装完成后，照抄一下示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"sass-loader"</span> <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合我们在加载 CSS 时候的经验，可以看出 test 是检验文件后缀是否是 .scss</p><p>然后按顺序从后向前调用 loader</p><h2 id="less-和-stylus"><a href="#less-和-stylus" class="headerlink" title="less 和 stylus"></a>less 和 stylus</h2><p>一模一样.jpg</p><p>先安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev less-loader less</span><br><span class="line">npm install --save-dev stylus-loader stylus</span><br></pre></td></tr></table></figure><p>然后引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"less-loader"</span> <span class="comment">// 将 Less 编译成 CSS</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"stylus-loader"</span> <span class="comment">// 将 Stylus 编译成 CSS</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完事了，是不是特别简单？</p><h1 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h1><p>显然图片也是重要的一环</p><p>从上面的 loader 示例中，可以发现 loader 的格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[&#123;</span><br><span class="line">        test: [regex], <span class="comment">// 通过正则表达式识别后缀</span></span><br><span class="line">        use: [&#123;</span><br><span class="line">            loader: <span class="string">"xxx-loader"</span> <span class="comment">// 对应的 loader</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 js 文件中 import 即可引入</p><p>那我们可以试着编写一下图片的 loader 格式</p><p>假设有一张 image.png，我们可以推测 loader 是这样的配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[&#123;</span><br><span class="line">        test: <span class="regexp">/\.png$/</span>, <span class="comment">// 通过正则表达式识别后缀</span></span><br><span class="line">        use: [&#123;</span><br><span class="line">            loader: <span class="string">"image-loader"</span> <span class="comment">// 对应的 loader</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 image-loader 看起来很合理，但是告诉你个坏消息：没有这个 loader</p><p>那怎么办呢？用 file-loader 就可以了</p><p>所以 loader 配置就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[&#123;</span><br><span class="line">        test: <span class="regexp">/\.png$/</span>, <span class="comment">// 通过正则表达式识别后缀</span></span><br><span class="line">        use: [&#123;</span><br><span class="line">            loader: <span class="string">"file-loader"</span> <span class="comment">// 对应的 loader</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在要怎么插入到页面呢？</p><p>首先要知道这时候你在 js 中引入的话，获得了什么呢？是二进制码还是？</p><p>答案是这个图片的一个相对路径</p><p>然后通过 img 标签的 src 进行插入即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> url <span class="keyword">from</span> <span class="string">'./image.png'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">img.src = url</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img)</span><br></pre></td></tr></table></figure><p>其余图片也可以使用类似的方法</p><p>什么？你说还有其它文件怎么办？看文档啊（</p><h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><p>有时候并不想图片什么的一上来就加载，可不可以控制呢？</p><p>答案是可以</p><p>我们注意到，loader 处理后的文件，必须在 import 处理后才可以正常使用，那我们动态延后 import 不就可以了？</p><p>容易想到通过一个 button 之类的元素，来触发某个事件，然后异步加载</p><p>用什么可以异步加载呢？可以使用 js 的 import() 方法来动态加载一个模块，这个方法返回一个 Promise，其成功回调返回一个模块，需要通过 module.default 才能取得其默认值</p><p>那么假设在页面上有一个 button#btn，容易得到以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">'./image.png'</span>).then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="built_in">module</span>.default</span><br><span class="line">        <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">        img.src = url</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(img)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就可以实现页面上图片的懒加载</p><h1 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h1><p>file 协议也太野蛮了，我要 http 协议</p><p><a href="https://ringoer.com/frontend/webpack-4/" target="_blank" rel="noopener">点我查看下集</a></p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代互联网，资源摩多摩多！Webpack 其之三&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 入门 2</title>
    <link href="http://yoursite.com/frontend/webpack-2/"/>
    <id>http://yoursite.com/frontend/webpack-2/</id>
    <published>2020-12-18T14:53:00.000Z</published>
    <updated>2020-12-20T13:56:17.320Z</updated>
    
    <content type="html"><![CDATA[<p>也不能总是只搞 js 吧，我三剑客另两位呢？Webpack 其之二</p><a id="more"></a><hr><p><a href="https://download.ringoer.com/webpack-demo-2.rar" target="_blank" rel="noopener">点我下载本章代码</a></p><h1 id="HTML-插件"><a href="#HTML-插件" class="headerlink" title="HTML 插件"></a>HTML 插件</h1><p>首先先搞一个能看的页面出来</p><p>那当然是选择我们的 HTML</p><p>因为 webpack 只能把资源处理成 js，所以要想得到 HTML，我们就要使用 plugin</p><p>在官方文档的 plugin 中找到 html，发现有这么一个插件</p><p><strong>html-webpack-plugin</strong></p><p>点开之后可以得到其引导，让我们先安装它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure><p>该插件将为你生成一个 HTML5 文件， 其中包括使用 <code>script</code> 标签的 body 中的所有 webpack 包。</p><p>向 module.exports 写入字段 plugins，大致变为如下模样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> HtmlWebpackPlugin()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后试试构建！</p><p>可以发现 dist 目录下产生了新的 js 和一个 html，并为这个 html 自动绑定了 js</p><p><img src="https://pic.ringoer.com/webpack-2-0.png" alt=""></p><p>但是这个页面也太白板了，能不能指定一些个性化设置呢</p><p>查看 <a href="https://github.com/jantimon/html-webpack-plugin#configuration" target="_blank" rel="noopener">插件文档</a> 可以发现有这么一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: <span class="string">'My App'</span>,</span><br><span class="line">        filename: <span class="string">'assets/admin.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>抄进来试试构建！</p><p>发现 dist 目标文件夹变成了这样</p><p><img src="https://pic.ringoer.com/webpack-2-1.png" alt=""></p><p>可以看到 title 被我们成功定制了，但是路径错了？！为什么多了一个 assets？？</p><p>我们发现配置中有 assets 的部分是 filename 字段，想到之前配置中的 output 也有 filename 字段，是指示输出的文件名用的，所以结合构建结果来看插件中的配置应该也同理</p><p>但是这样还是太单薄了，能不能再丰富一点？</p><h1 id="HTML-模板"><a href="#HTML-模板" class="headerlink" title="HTML 模板"></a>HTML 模板</h1><p>答案是可以！</p><p>继续查看插件文档，有一个地方的代码引起了我们的注意</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(), <span class="comment">// Generates default index.html</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;  <span class="comment">// Also generate a test.html</span></span><br><span class="line">        filename: <span class="string">'test.html'</span>,</span><br><span class="line">        template: <span class="string">'src/assets/test.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>注释是说，如果配置了两个 HtmlWebpackPlugin 实例，那么两个实例都会被构建</p><p>其中第二个实例指定了一个新字段，template，翻译是模板，那我们可以猜测这个东西是指示入口 html 文件的</p><p>正好我们目录下有个 index.html，个性化一下先</p><p><img src="https://pic.ringoer.com/webpack-2-2.png" alt=""></p><p>然后指定 template 的路径到这个 html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: <span class="string">'My App'</span>,</span><br><span class="line">        filename: <span class="string">'index.html'</span>,</span><br><span class="line">        template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后再构建一下，发现 dist 结果现在变成了这样</p><p><img src="https://pic.ringoer.com/webpack-2-3.png" alt=""></p><p>虽然构建成功了，自动使用我们提供的模板，并引入了 main.js</p><p>但是我们配置的 title 没有覆盖模板的 title，并且里面自带的 index.js 还留着</p><p>可以猜测配置多余的 title 是没用的，并且不应该自带 js</p><p>现在去掉模板里的 title 和 js 引用再试试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>构建！</p><p>得到的新 dist 变成这样</p><p><img src="https://pic.ringoer.com/webpack-2-4.png" alt=""></p><p>虽然 js 确实自动插进去了，但是……我的 title 呢！！！</p><p>怎么办怎么办，看看插件文档吧</p><p>正好下一节就提出了一个类似 jsp 的语法</p><p><code>&lt;%= htmlWebpackPlugin.options.title %&gt;</code></p><p>将这个语句写在模板中，可以在构建的时候自动获取配置中的 title</p><p>来试试</p><p><img src="https://pic.ringoer.com/webpack-2-5.png" alt=""></p><p>构建！</p><p><img src="https://pic.ringoer.com/webpack-2-6.png" alt=""></p><p>发现成功插入了新的 title！可以推知其它配置也可以采用类似的方法</p><h1 id="css-loader"><a href="#css-loader" class="headerlink" title="css loader"></a>css loader</h1><p>但是这样的页面好丑……我要加 CSS</p><p>看看插件文档怎么说的</p><p>直接在插件文档中搜 css</p><p>发现官方文档里这么说</p><blockquote><p>If you have any CSS assets in webpack’s output (for example, CSS extracted with the <a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="noopener">mini-css-extract-plugin</a>) then these will be included with <code>&lt;link&gt;</code> tags in the HTML head.</p></blockquote><p>意思就是如果要 CSS，你去用 mini-css-extract-plugin 吧</p><p>这也太麻烦了，我想简单点，回头看看 webpack 文档</p><p>在指南中的 加载 CSS 章节发现了这么一段</p><p><img src="https://pic.ringoer.com/webpack-2-7.png" alt=""></p><p>先安装，然后把配置抄过来看看</p><p>然后加个 style.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ol</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 index.js 中引入这个 css</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![webpack<span class="number">-2</span><span class="number">-8</span>](https:<span class="comment">//pic.ringoer.com/webpack-2-8.png)import './style.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(string)</span><br></pre></td></tr></table></figure><p>试试构建，完成后用 file 协议打开 index.html 看看</p><p><img src="https://pic.ringoer.com/webpack-2-8.png" alt=""></p><p>发现成功引入了 css，而且自动化作 style 标签插在了 document.head 中</p><p>此时的 main.xxx.js 变成了复杂的一大串 js 代码，这其实就是 loader 的效果——将其它内容转换为 js</p><p>查看配置，发现用到了两个 loader，根据名称，我们可以推测，任何以 .css 结尾的文件，都会通过 test 的测试，然后从后向前依次调用 loader处理</p><p>先调用 css-loader 将 css 内容转化为 webpack 能理解的 js 内容，再调用 style-loader 将 js 内容中的样式部分化作 style 标签插入到 document.head 上</p><p>那如果我有多个 css 呢？试试看！</p><p>新建一个 style2.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ol</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 index.js 中引入它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style2.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(string)</span><br></pre></td></tr></table></figure><p>然后构建！刷新页面发现变成了这样</p><p><img src="https://pic.ringoer.com/webpack-2-9.png" alt=""></p><p>多个 css 文件会化作多个 style 标签被插入</p><h1 id="css-抽取"><a href="#css-抽取" class="headerlink" title="css 抽取"></a>css 抽取</h1><p>但是如果我 css 多了，插作 style 标签的话，不方便管理，也会加大页面代码冗余</p><p>能不能抽成 css 文件呢？可以！</p><p>我们知道 webpack 基本功能是提取内容变为 js，刚才的 loader 也是这个功能，那现在要提取作非 js 的 css 文件了，肯定需要的是 plugin</p><p>想起刚才 html 的时候，他让我们去用 mini-css-extract-plugin，那我们就去看看</p><p>先安装这个插件</p><p><code>npm install --save-dev mini-css-extract-plugin</code></p><p>然后我们发现了这么一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> MiniCssExtractPlugin()],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>抄下来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'My App'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin()</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后好像没说什么别的了，试试构建吧</p><p><img src="https://pic.ringoer.com/webpack-2-10.png" alt=""></p><p>构建之后发现！！js 文件变简单了，css 也自动抽成了 main.css，还自动在 index.html 中引入了</p><p>不过为什么仅仅是 main.css？我的哈希呢？</p><p>根据之前猜测的 filename 指示输出文件名，来试试修改配置</p><p>将 plugins 中的 filename 改成如下模样，再试试构建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: <span class="string">'[name].[contenthash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>得到了如下结果</p><p><img src="https://pic.ringoer.com/webpack-2-11.png" alt=""></p><p>现在我们的 CSS 也有每次不同的文件名了！并且也不再依赖于 js 的引入</p><h1 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h1><p>更多其它的内容怎么办呢？只有三剑客可不足以撑起现代互联网！</p><p><a href="https://ringoer.com/frontend/webpack-3/" target="_blank" rel="noopener">点我查看下集</a></p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也不能总是只搞 js 吧，我三剑客另两位呢？Webpack 其之二&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 入门 1</title>
    <link href="http://yoursite.com/frontend/webpack-1/"/>
    <id>http://yoursite.com/frontend/webpack-1/</id>
    <published>2020-12-18T14:51:00.000Z</published>
    <updated>2020-12-20T13:00:32.339Z</updated>
    
    <content type="html"><![CDATA[<p>目前版本第一的打包工具 Webpack 其之一</p><a id="more"></a><hr><p><a href="https://download.ringoer.com/webpack-demo-1.rar" target="_blank" rel="noopener">点我下载本章代码</a></p><h1 id="什么是-Webpack"><a href="#什么是-Webpack" class="headerlink" title="什么是 Webpack"></a>什么是 Webpack</h1><p>首先贴出 webpack 的官网</p><p><a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a></p><p><a href="https://www.webpackjs.com/" target="_blank" rel="noopener">webpack 中文文档</a></p><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。构建过程是拓扑排序的一种</p><p>说到底，webpack 基本的功能，其实就是把高版本 js 转换成 js，以及把非 js 的文件转换成 js</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>先安装一下吧</p><p>我们可以看到，官方文档的指南里给出了如下命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack-demo &amp;&amp; <span class="built_in">cd</span> webpack-demo</span><br><span class="line">npm init -y</span><br><span class="line">npm install webpack webpack-cli --save-dev</span><br></pre></td></tr></table></figure><p>那我们也照做一下，完成后目录结构如下</p><p><img src="https://pic.ringoer.com/webpack-1-0.png" alt=""></p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>指南里还要求我们首先建一个新目录，里面包含一个 src 的一个 index.js，以及一下 index.html</p><p>index.html 中记得连接到 index.js</p><p><img src="https://pic.ringoer.com/webpack-1-1.png" alt=""></p><p>然后让我们试试高版本 js 转换成低版本 js 的功能。一般是 ES6 转换成 ES5</p><p>让我们先从文档里找一个能用的 webpack 配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就他了！</p><p>建立一个 webpack.config.js 文件用来保存配置</p><p><img src="https://pic.ringoer.com/webpack-1-2.png" alt=""></p><p>然后试试运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>npx 命令指示 node 从当前目录下的 node_modules 中寻找webpack</p><p>然后发现报错了？！怎么回事呢</p><p>看看报错说什么</p><p><img src="https://pic.ringoer.com/webpack-1-3.png" alt=""></p><p>报错说他不能识别 <code>./path/to/my/entry/file.js</code> 这个文件是什么</p><p>这个字符串在哪里提到了呢？在配置中的 entry</p><p>entry 这个词很明显是入口的意思，加上是 js 结尾，我们试试看用我们现在目录中唯一的 js 替换</p><p><img src="https://pic.ringoer.com/webpack-1-4.png" alt=""></p><p>现在配置变成这样，再试试打包吧！</p><p>这次很顺利的成功了</p><p><img src="https://pic.ringoer.com/webpack-1-5.png" alt=""></p><p>检查目录，发现目录下多了个 dist 文件夹，里面多了个 my-first-webpack.bundle.js 文件</p><p><img src="https://pic.ringoer.com/webpack-1-6.png" alt=""></p><p>打开内容一看，就是和我们的 index.js 里面是一样的内容！甚至还自己分析了语义，省去了不必要的代码</p><p>这就是 webpack 的基本功能 js 转换</p><h1 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h1><p>entry 除了上文提到的单入口指定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以指定多个入口，传入一个 hashtable 即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">      app: <span class="string">'./src/index.js'</span>,</span><br><span class="line">      print: <span class="string">'./src/print.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>传入的入口 js 会分别打包，有兴趣的朋友可以自己尝试一下</p><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>显然代码一般都有开发和部署两种状态，webpack 也有不同的对应代码</p><p>在配置中可以添加 mode 字段来指示 webpack 模式，有两种选择</p><ol><li>production，部署模式，默认</li><li>development，开发模式</li></ol><p>具体来说，打包出来的东西会有区别，比如刚才的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(string)</span><br></pre></td></tr></table></figure><p>在部署模式会被打包成上图样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><p>在开发模式会打包成如下样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").</span></span><br><span class="line"><span class="comment"> * This devtool is not neither made for production nor for readable output files.</span></span><br><span class="line"><span class="comment"> * It uses "eval()" calls to create a separate source file in the browser devtools.</span></span><br><span class="line"><span class="comment"> * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)</span></span><br><span class="line"><span class="comment"> * or disable the default devtool with "devtool: false".</span></span><br><span class="line"><span class="comment"> * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/******/</span> (<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/index.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"let string = 'hello'\r\nconsole.log(string)\n\n//# sourceURL=webpack://webpack-demo/./src/index.js?"</span>);</span><br><span class="line"><span class="comment">/******/</span> &#125;)()</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>多了很多不必要的代码，为了方便程序员查看</p><h1 id="输出哈希"><a href="#输出哈希" class="headerlink" title="输出哈希"></a>输出哈希</h1><p>从配置信息中可以看出，配置里不仅指示了入口文件，还指示了 output——输出文件的配置</p><p>上述配置中令输出文件夹命名为 dist，这也是大部分构建工具的配置</p><p>还指示了 filename，可以猜出是输出的 js 文件的文件名</p><p>在刚才尝试不同模式的构建中，我们已经发现不同的构建会覆盖旧有的文件，但输出文件名仍然是同一个</p><p>根据以前学习的浏览器缓存知识可以了解到，浏览器发现你在 html 文件中的连接 js 名称没变，那就会认为现在的页面还是使用原有的缓存，显然不利于页面的更新</p><p>于是我们要为新构建的 js 指定一个每次都不一样的名称</p><p>但是总不能手动配置吧？那也太烦了</p><p>还好 webpack 提供了 filename 模板</p><p>可以通过 <code>[name].[contenthash].js</code> 来指定随机的新 filename，其中的 contenthash 是依据文件内容进行哈希，也就是说只要文件内容有变化，新打包出来的文件一定不同名</p><p>让我们试试吧</p><p><img src="https://pic.ringoer.com/webpack-1-7.png" alt=""></p><p>更换了新配置之后发现生成了一个 main.xxxxx.js 文件！成功了！</p><h1 id="快捷构建"><a href="#快捷构建" class="headerlink" title="快捷构建"></a>快捷构建</h1><p>每次构建都产生一个不同名文件，虽然有利于浏览器更新，但是不利于本地……毕竟总不能每次都手动删除一下 dist 吧2333</p><p>这时候我们可以考虑修改 node 默认的配置</p><p>可以向 package.json 文件中的 scripts 字段加入如下内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与命令行不同，写在此处的命令可以不加 npx，默认是在本目录下查找</p><p>接下来我们运行 <code>npm run build</code> 就等同于运行 <code>npx webpack</code></p><p><img src="https://pic.ringoer.com/webpack-1-8.png" alt=""></p><p>于是我们就可以把 rm 语句也加进去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"rm -rf ./dist &amp;&amp; webpack"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;&amp; 表示前项执行成功才执行后项</p><p>现在就可以在运行 <code>npm run build</code> 的时候同时删除旧文件了</p><p>注：有的不能用 rm 命令的时候，可以用 rimraf 命令代替</p><h1 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h1><p>只有 js 怎么够？！我要完整的三剑客！</p><p><a href="https://ringoer.com/frontend/webpack-2/" target="_blank" rel="noopener">点我查看下集</a></p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前版本第一的打包工具 Webpack 其之一&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>框架模式之 MVC</title>
    <link href="http://yoursite.com/programing/mvc/"/>
    <id>http://yoursite.com/programing/mvc/</id>
    <published>2020-12-16T12:56:00.000Z</published>
    <updated>2020-12-16T14:48:38.208Z</updated>
    
    <content type="html"><![CDATA[<p>常听说 spring MVC，现在都发展到前端 MVC 了</p><a id="more"></a><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>经典 MVC 模式中，M 是指 Model 业务模型，V 是指 View 用户界面，C 则是 Controller 控制器</p><p>通常是为了使得代码模式固化，让代码复杂度相对稳定</p><h1 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h1><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>比如在 spring 中，Model 通常包括 domain、mapper、dao 等三层，定义了对象模型以及对象对应的存取方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// domain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    User()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span></span>&#123;<span class="keyword">this</span>.id=id;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mapper</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span></span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">selectUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dap</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">selectUserById</span><span class="params">(Integer id)</span></span>&#123;<span class="keyword">return</span> userMapper.selectUserById(id);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller 则是 controller 层 和 service 层，定义了数据接口和关于数据处理的业务方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Integer id)</span></span>&#123;<span class="keyword">return</span> ResponseUtil.ok(userDao.selectUserById(id));&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// controller</span></span><br><span class="line"><span class="meta">@RestController</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/info"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getUser</span><span class="params">(@RequestParam Integer userId)</span></span>&#123;<span class="keyword">return</span> userService.getUser(userId);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的，当 controller 的注解是 @RestController 的时候，仅作为数据接口</p><p>当注解是 @Controller 的时候，可以返回数据或页面，比如 thymeleaf 渲染的页面</p><p>这时候，返回页面的 controller 就是所谓的 View</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>(<span class="string">""</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"index.html"</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>而在前端中，一般不需要考虑与数据库的交互，数据来源一般都是后端提供的数据接口</p><p>这时候，Controller 就不需要提供数据接口，只需要访问，于是原本在后端分离开的 controller 和 service 就融合在了一起，负责提供业务方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Controller = <span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        el: el,</span><br><span class="line">        init()&#123;</span><br><span class="line">model.bindEvents(el)</span><br><span class="line">        &#125;,</span><br><span class="line">        add(target,value)&#123;</span><br><span class="line">            model.data[target]+=value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Model 则是负责保存需要用到的用户数据，并为数据设置事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Model = &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        n: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    events: &#123;</span><br><span class="line">        click: <span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(n)</span><br><span class="line">    &#125;,</span><br><span class="line">    bindEvents(el)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">this</span>.events)&#123;</span><br><span class="line">            el.addEventListener(key,<span class="keyword">this</span>.events[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View 则是负责接收业务方法的信号，重新渲染页面，监听数据事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> View = &#123;</span><br><span class="line">    html: <span class="string">`233&#123;&#123;n&#125;&#125;`</span>,</span><br><span class="line">    render(el)&#123; <span class="comment">// 被触发</span></span><br><span class="line">        html.replace(<span class="string">'&#123;&#123;n&#125;&#125;'</span>,model.data.n)</span><br><span class="line">        el.innerHTML=<span class="keyword">this</span>.html</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是又多了一个和后端不一样的地方——model 和 view 都要关注用户事件</p><p>所以前端 MVC 一般还有一个概念，就是 EventBus 事件总线</p><p>EventBus 提供一系列事件绑定、触发、解除等相关的方法，然后交由 Model 和 View 来调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventBus = &#123;</span><br><span class="line">    on(el, eventName, fn)&#123;</span><br><span class="line">        el.addEventListener(eventName,fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    off(el, eventName, fn)&#123;</span><br><span class="line">        el.removeEventListener(eventName,fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    trigger(el, eventName)&#123;</span><br><span class="line">        el.dispatchEvent(eventName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是现在这些方法怎么转移使用呢？</p><p>基于 js 的特性，可以选择原型链继承或者类继承</p><p>此处可以选择类继承，让 Model、View、EventBus 都成为 class</p><p>然后 Model、View 都 extends EventBus，就可以拥有 EventBus 的所有方法</p><p>之后在使用的时候，声明一个该类的实例即可</p><h1 id="表驱动编程"><a href="#表驱动编程" class="headerlink" title="表驱动编程"></a>表驱动编程</h1><p>上述伪代码中，我们采用了遍历 model.events 的方法来为 events 里的每个键值对都执行绑定</p><p>实际上就是先为要绑定的列表作成一个哈希表，然后遍历这个表</p><p>基于这种方法的编程，代码复杂度恒定——无论增加多少个表项，都不需要修改绑定部分的业务代码</p><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>其实 MVC 也就是一种模块化，毕竟代码分离了</p><p>模块化说到底就是为了方便维护各个部分的代码</p><p>比如同一个页面上有多块不同的功能，这时候我总不可以牵一发而动全身吧，那重构和渲染成本也太高了</p><p>这时候就可以选择在编程的时候模块化，使得代码耦合度降低，上层实现不直接依赖于底层架构</p><p>具体来说就是我们可以把页面上的每个不同功能的部分都应用一次 MVC 架构，这样每个部分都是直接依赖 MVC 提供的接口，而不关心内部的实现</p><p>就像前后端通信一样，只需要接口文档规定好，不需要调用者去关心接口内部是怎么写的</p><p>既然前后端分离的好处显而易见，那模块分离的好处，是不是也同理呢？</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常听说 spring MVC，现在都发展到前端 MVC 了&lt;/p&gt;
    
    </summary>
    
    
      <category term="programing" scheme="http://yoursite.com/categories/programing/"/>
    
    
  </entry>
  
  <entry>
    <title>百文纪念</title>
    <link href="http://yoursite.com/diary/20201212/"/>
    <id>http://yoursite.com/diary/20201212/</id>
    <published>2020-12-12T15:19:00.000Z</published>
    <updated>2020-12-14T10:36:03.009Z</updated>
    
    <content type="html"><![CDATA[<p>博客上写满 100 篇了，来点来点</p><a id="more"></a><p>在双十二之际写下这篇百文纪念</p><p>但是其实已经超过一百不少了</p><p>四舍五入就是二百文纪念（？）</p><p>这一百文见证了我从算法到后端到前端的转变</p><p>下一百文又有什么样的变化呢</p><p>楽しみだな</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客上写满 100 篇了，来点来点&lt;/p&gt;
    
    </summary>
    
    
      <category term="diary" scheme="http://yoursite.com/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>拆箱即用的 http 服务器</title>
    <link href="http://yoursite.com/programing/parcel/"/>
    <id>http://yoursite.com/programing/parcel/</id>
    <published>2020-12-11T10:10:00.000Z</published>
    <updated>2020-12-14T10:33:58.370Z</updated>
    
    <content type="html"><![CDATA[<p>有时候只是想走一下 http 访问，但是我不想特意写个后端！！！！</p><p>有没有什么好办法呢？</p><a id="more"></a><hr><p>那就是伟大的 parcel ！</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>通过以下命令即可安装 parcel</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g parcel-bundler</span><br></pre></td></tr></table></figure><h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>选择一个目录，在这里新建一个 index.html</p><p>写好 html 之后，在当前目录下启动 parcel</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parcel index.html -p 8080</span><br></pre></td></tr></table></figure><p>就会在 8080 端口（默认是 1234）启动 http 服务</p><p>不需要任何配置，非常好用。而 webpack 需要的配置太多了不适合快速开发</p><h1 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h1><p>parcel 还有更好用的一点——页面热更新！</p><p>但是要使用页面热更新，对 html 页面是有要求的</p><p>那就是 html 需要引入至少一个外联的 script 标签</p><p>外联的目标 script 可以是空的，但这个标签不能省略，否则不能热更新</p><p>好了，现在不论你修改的是 html，还是 html 外联的 css，都会在保存之后立刻重新编译然后渲染到页面上，不需要手动刷新页面了</p><h1 id="配置目录"><a href="#配置目录" class="headerlink" title="配置目录"></a>配置目录</h1><p>刚才说到了编译——其实 parcel 是会自动帮你打包的</p><p>比如现在目录下只有</p><ul><li>index.html</li><li>style.css</li><li>main.js</li></ul><p>启动了 parcel 之后，parcel 会自动把你的 html 以及外联的所有文件都组织起来，自己编码后打包成一个 dist 文件夹</p><p>现在开发目录下就变成了 3 个文件加上 1 个文件夹了</p><p>所以建议开发目录中，最好把静态文件都放在同一个文件夹中，按惯例命名为 src</p><p>目录结构就变成这样</p><ul><li>src<ul><li>index.html</li><li>style.css</li><li>main.js</li></ul></li><li>dist<ul><li>…</li></ul></li></ul><p>这样更有利于文件资源管理</p><h1 id="引用路径"><a href="#引用路径" class="headerlink" title="引用路径"></a>引用路径</h1><p>parcel 之所以会产生 dist 文件夹，就是因为它自己把资源编码了</p><p>这时候你的路径就不是原本的路径了</p><p>比如你通过 js 动态插入一个 img 标签，这个 img 的 src 是不能正确命中资源的</p><p>这时候你需要通过 js 的 import 语句来解决这个问题</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候只是想走一下 http 访问，但是我不想特意写个后端！！！！&lt;/p&gt;
&lt;p&gt;有没有什么好办法呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="programing" scheme="http://yoursite.com/categories/programing/"/>
    
    
      <category term="http(s)" scheme="http://yoursite.com/tags/http-s/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你做一个自己的导航首页</title>
    <link href="http://yoursite.com/frontend/navigation-page/"/>
    <id>http://yoursite.com/frontend/navigation-page/</id>
    <published>2020-12-11T08:40:00.000Z</published>
    <updated>2020-12-15T15:07:49.333Z</updated>
    
    <content type="html"><![CDATA[<p>拥有无限潜能的前端导航项目</p><a id="more"></a><hr><p>前端三件套，首先当然是——</p><p>搞什么开发，当然是先需求分析</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>前端导航一般都有两个主要功能</p><ol><li>搜索</li><li>快捷标签页</li></ol><p>通过墨刀作图，可以得到如图原型图</p><p><img src="https://pic.ringoer.com/navigation-page-0.png" alt="产品原型图"></p><h1 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h1><p>得到产品原型图以后，分析一下页面的结构</p><p>首先能够确定的是两边留白，中间三行</p><p>大致就是 3x3 表格模样，特别适合 grid 布局</p><p>什么？兼容？想那么多干啥，先自己写出来，跑起来再说，2333</p><p>在 grid 布局中，用到中间一列，上部放置搜索框，中部放置标签页，下部放置授权标志</p><p>那大致可以得到如下 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>header 中包含两个组件，所以 header 应该写成如下模样</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"searchBox"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"keyword"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"search()"</span> <span class="attr">id</span>=<span class="string">"submit"</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main 中包含多个标签页，数量不确定，行数也不确定，所以标签页决定通过 js 动态插入</p><p>然后新增功能需要一个新增窗口，先画原型图</p><p><img src="https://pic.ringoer.com/navigation-page-1.png" alt="弹出页原型图"></p><p>可见弹出窗口也需要一些组件，且需要用户通过”添加”按钮提供控制</p><p>所以可得如下 main</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"delete"</span> <span class="attr">onclick</span>=<span class="string">"cancel()"</span>&gt;</span>×<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>链接：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"url"</span> <span class="attr">placeholder</span>=<span class="string">"请输入链接"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>描述：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"desp"</span> <span class="attr">placeholder</span>=<span class="string">"请输入描述"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"insertCard()"</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而 footer 的内容不是动态的，所以可以直接写死</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>© 2017 — 2020 ringoer.com 版权所有<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后再引入对全文操作的 js 文件，可得全页面的 HTML 如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>导航<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"searchBox"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"keyword"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"search()"</span> <span class="attr">id</span>=<span class="string">"submit"</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"delete"</span> <span class="attr">onclick</span>=<span class="string">"cancel()"</span>&gt;</span>×<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>链接：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"url"</span> <span class="attr">placeholder</span>=<span class="string">"请输入链接"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>描述：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"desp"</span> <span class="attr">placeholder</span>=<span class="string">"请输入描述"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"insertCard()"</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>© 2017 — 2020 ringoer.com 版权所有<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来开始写CSS</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="全局初始化"><a href="#全局初始化" class="headerlink" title="全局初始化"></a>全局初始化</h2><p>先 fix 一下默认的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为 body 选择一个合适的灰色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>然后就是定位了</p><ol><li>大小，显然要占满全屏，100vh 和 100vw 安排上</li><li>滚动条肯定不给左右给上下，overflow 安排</li><li>说好的 3x3 布局，grid 安排</li></ol><p>可以得到如下 CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.app</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden auto;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">8</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">1</span>fr <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">  <span class="string">". header ."</span></span><br><span class="line">  <span class="string">". main ."</span></span><br><span class="line">  <span class="string">". footer ."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 app 里的 header main footer 都是要做居中的，3 个flex 安排上</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.app</span>&gt;*&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来给三个块分配 grid 空间</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span>&#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: main;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">footer</span>&#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后先来做 header 吧</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>header 包含两个框，输入和按钮，并且还要居中</p><p>所以决定用一个 div 包住这两个，然后把 div 居中，里面一左一右摆放</p><p>先做个定宽居中 div</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.searchBox</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以这里不用写居中，是因为容器 header 已经定义了 flex 居中了</p><p>然后写搜索框宽度，显然这个是自适应的</p><p>那么反过来，先决定 button 的样式</p><p>首先让 button 宽 80px 吧</p><button style="width: 80px">搜索</button><p>然后为了 button 好看，一般会给 padding</p><button style="width: 80px; padding: 8px 12px;">搜索</button><p>接下来背景色给个浅蓝色吧，同时字给白色（为了看得见）</p><button style="width: 80px; padding: 8px 12px;background-color: cornflowerblue;color:white;">搜索</button><p>这边框好丑，我要给白边加圆角</p><button style="width: 80px; padding: 8px 12px;background-color: cornflowerblue;color:white;border: 1px solid #ccc;border-radius: 4px;">搜索</button><p>现在就还挺好看的</p><p>然后给一下上下 margin，以及为了同行显示的 inline-block，可以得到如下 CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#submit</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">8px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">background-color</span>: cornflowerblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来做一个搜索框</p><p>首先给个 padding 让字显示位置不要那么贴边</p><p>然后再和 button 一样弄好看点</p><p>最后再弄个计算宽度来自适应</p><p>可以得到如下 CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#keyword</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(100% - 100px);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">8px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜索就做好了！</p><h2 id="主容器"><a href="#主容器" class="headerlink" title="主容器"></a>主容器</h2><p>首先要让弹窗不能影响我们的布局，于是把弹窗显示去掉</p><p>display: none; 即可去除</p><p>之所以选用 display none，是因为它不会渲染到页面上</p><p>而 visibility hidden 虽然不保留事件，但还是会渲染到页面上占据空间</p><p>opacity 更离谱，事件都还留着</p><p>然后开始做主容器内容</p><p>显然主容器的每列是平均布局，有多列</p><p>多列适合 flex column，但是平均布局不能用 space-between，否则空间分配会失常</p><p>所以先得到容器样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来每一个标签页，都有自己的一张卡片一样的样式</p><p>在卡片中，也有 logo、description、叉叉等三部分内容</p><p>其中叉叉是绝对定位在右上角的，前两个则是纵向居中排列在卡片中</p><p>可以得到卡片样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">160px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> black;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给 margin 预留了足够位置，所以不需要使用 负 margin 法 来平衡</p><p>然后给叉叉定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.delete</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为平时没选中的时候是看不见叉叉的，所以 visibility: hidden;</p><p>然后定义 logo 样式，此处我使用文本而不是矢量图</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.logo</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">80px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慢着，描述变长的时候，描述怎么换行了？</p><p>给描述上一个不许换行的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.desp</span>&#123;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义选中卡片的时候的行为</p><p>显然选中的行为一般都是变大或者上浮，此处选择上浮</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-10px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上浮不能太突兀，给卡片加个过渡动画吧</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span>&#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.3s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当选中的时候，叉叉也要能看到才对</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.delete</span>&#123;</span><br><span class="line">  <span class="attribute">visibility</span>: visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这时候，点叉叉还是点不到，怎么回事呢？因为叉叉浮起不够高，点到别的了！</p><p>让叉叉浮起来</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.delete</span>&#123;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，主容器部分做好了</p><h2 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h2><p>弹窗有几个要点</p><ol><li>绝对定位在视口中央</li><li>三列内容，纵向居中排列，加一个叉</li><li>当它显示时，按键等级（层叠上下文）要比主页高</li></ol><p>于是可以得到如下 CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tab</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="comment">/* display: flex; */</span></span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> black;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%,-50%);</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于 z-index 为什么是 1 呢？</p><p>因为我们刚才给 container 里的 card 里的 delete 赋值了 z-index=1，所以导致 container 的层级也升高了，所以这时候 tab 的 z-index 要不低于 container，才能浮在 container 上方</p><p>接下来为了方便布局，让所有内部子元素都以块级元素形式显示，并设置上下边距</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tab</span>&gt;*&#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tab 里的 delete 和 card 里的不一样，默认是显示的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tab</span>&gt;<span class="selector-class">.delete</span>&#123;</span><br><span class="line">  <span class="attribute">visibility</span>: visible;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再修整一下 tab 里元素的样式，弄好看点</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#url</span>,<span class="selector-id">#desp</span>&#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#tab</span>&gt;<span class="selector-tag">button</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#0381aa</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#00a7de</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>我们刚才都是以 PC 端为基准开发的，现在要支持移动端，怎么办呢？</p><p>答案就是一个媒体查询就完事了</p><p>分析可得在移动端，容器的 3x3 布局变为 1x3 布局，card 也最多只能排列下两个</p><p>所以可得 CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> (max-width: <span class="number">600px</span>)&#123;</span><br><span class="line">  <span class="selector-class">.app</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: </span><br><span class="line">    <span class="string">"header header header"</span></span><br><span class="line">    <span class="string">"main main main"</span></span><br><span class="line">    <span class="string">"footer footer footer"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.card</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">35vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">28vw</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">3vw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.logo</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">60px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应式这样就完成了，不错吧？</p><h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><p>基本的骨架弄好了，现在要赋予这个项目血肉</p><h2 id="搜索-1"><a href="#搜索-1" class="headerlink" title="搜索"></a>搜索</h2><p>从上到下，第一个就是搜索</p><p>很简单，只要研究一下百度的搜索格式就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> baseUrl = <span class="string">'https://www.baidu.com/s?ie=UTF-8&amp;wd='</span></span><br><span class="line">  <span class="keyword">let</span> keyword = <span class="built_in">document</span>.querySelector(<span class="string">'#keyword'</span>).value</span><br><span class="line">  keyword = keyword.replaceAll(<span class="string">' '</span>, <span class="string">'%20'</span>)</span><br><span class="line">  <span class="built_in">window</span>.open(baseUrl + keyword)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意搜索中要改一下默认的 http 字符转义问题，一般是空格转换成 %20 就行了</p><h2 id="标签页渲染"><a href="#标签页渲染" class="headerlink" title="标签页渲染"></a>标签页渲染</h2><p>然后是最重要的标签页渲染的功能</p><p>为了体现效果，此处先多搞几个重复的标签页</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> base_navs = [&#123; <span class="string">'href'</span>: <span class="string">'https://ringoer.com'</span>, <span class="string">'desp'</span>: <span class="string">'Ringoer\'s Site'</span>, <span class="string">'logo'</span>: <span class="string">'R'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'href'</span>: <span class="string">'https://baidu.com'</span>, <span class="string">'desp'</span>: <span class="string">'百度'</span>, <span class="string">'logo'</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'href'</span>: <span class="string">'https://baidu.com'</span>, <span class="string">'desp'</span>: <span class="string">'百度'</span>, <span class="string">'logo'</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'href'</span>: <span class="string">'https://baidu.com'</span>, <span class="string">'desp'</span>: <span class="string">'百度'</span>, <span class="string">'logo'</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'href'</span>: <span class="string">'https://baidu.com'</span>, <span class="string">'desp'</span>: <span class="string">'百度'</span>, <span class="string">'logo'</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'href'</span>: <span class="string">'https://baidu.com'</span>, <span class="string">'desp'</span>: <span class="string">'百度'</span>, <span class="string">'logo'</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'href'</span>: <span class="string">'https://baidu.com'</span>, <span class="string">'desp'</span>: <span class="string">'百度'</span>, <span class="string">'logo'</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'href'</span>: <span class="string">'https://baidu.com'</span>, <span class="string">'desp'</span>: <span class="string">'百度'</span>, <span class="string">'logo'</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'href'</span>: <span class="string">'https://baidu.com'</span>, <span class="string">'desp'</span>: <span class="string">'百度'</span>, <span class="string">'logo'</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'href'</span>: <span class="string">'https://baidu.com'</span>, <span class="string">'desp'</span>: <span class="string">'百度'</span>, <span class="string">'logo'</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'href'</span>: <span class="string">'https://baidu.com'</span>, <span class="string">'desp'</span>: <span class="string">'百度'</span>, <span class="string">'logo'</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'href'</span>: <span class="string">'https://baidu.com'</span>, <span class="string">'desp'</span>: <span class="string">'百度'</span>, <span class="string">'logo'</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'href'</span>: <span class="string">'https://baidu.com'</span>, <span class="string">'desp'</span>: <span class="string">'百度'</span>, <span class="string">'logo'</span>: <span class="string">'B'</span> &#125;,]</span><br></pre></td></tr></table></figure><p>接下来，渲染到页面上</p><p>首先读取列表里的每个项目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.querySelector(<span class="string">'.container'</span>)</span><br><span class="line">container.innerHTML = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; navList.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> nav = navList[i]</span><br><span class="line">    container.appendChild(createCard(i, nav.href, nav.desp, nav.logo))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在最后加上”添加”标签页</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.appendChild(createCard(navList.length, <span class="string">'/'</span>, <span class="string">'添加'</span>, <span class="string">'+'</span>))</span><br></pre></td></tr></table></figure><p>逻辑就完成了</p><p>那么来看看 createCard 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCard</span>(<span class="params">i, href, desp, logo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> card = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">  card.className = <span class="string">'card'</span></span><br><span class="line">  card.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (logo === <span class="string">'+'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> tab = <span class="built_in">document</span>.querySelector(<span class="string">'#tab'</span>)</span><br><span class="line">      tab.style.display = <span class="string">'flex'</span>;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.open(href)</span><br><span class="line">  &#125;, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">if</span> (logo === <span class="string">'+'</span>) &#123;</span><br><span class="line">    card.innerHTML = <span class="string">'&lt;div class="logo"&gt;'</span> + logo + <span class="string">'&lt;/div&gt;'</span> +</span><br><span class="line">      <span class="string">'&lt;div class="desp"&gt;'</span> + desp + <span class="string">'&lt;/div&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    card.innerHTML = <span class="string">'&lt;div class="delete" onclick="deleteCard('</span> + i.toString() + <span class="string">',event)"&gt;×&lt;/div&gt;'</span> +</span><br><span class="line">      <span class="string">'&lt;div class="logo"&gt;'</span> + logo + <span class="string">'&lt;/div&gt;'</span> +</span><br><span class="line">      <span class="string">'&lt;div class="desp"&gt;'</span> + desp + <span class="string">'&lt;/div&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> card</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先动态创建 card，然后根据是不是”添加”标签页，来动态绑定事件并插入子元素，最后返回 card</p><p>为了可以正常打开 tab 页，”添加”标签页的 click 事件让 tab 页的 display 从 none 变成了 flex，就可以显示了</p><p>可以看到里面提及了 delete 按钮拥有的 delete 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteCard</span>(<span class="params">i, event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = confirm(<span class="string">'确定要删除这个标签吗？'</span>)</span><br><span class="line">  <span class="keyword">if</span> (ans) &#123;</span><br><span class="line">    navList.splice(i, <span class="number">1</span>)</span><br><span class="line">    draw()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  event.stopPropagation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一定要阻止冒泡，否则事件一旦冒泡，就会触发 card 的点击事件，导致虽然删除了 card，但是发生了跳转</p><p>这时候发现，我刷新一下怎么就重置了？？</p><p>所以要保存用户使用数据</p><p>为了方便起见，这里保存到 localStorage</p><p>在初始化的时候先读取内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> navList = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'navList'</span>))</span><br><span class="line"><span class="keyword">if</span> (!navList) &#123;</span><br><span class="line">  navList = base_navs</span><br><span class="line">&#125;</span><br><span class="line">draw()</span><br></pre></td></tr></table></figure><p>然后在每次渲染之后都存数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'navList'</span>, <span class="built_in">JSON</span>.stringify(navList))</span><br></pre></td></tr></table></figure><p>这样就可以得到完整的 draw 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> container = <span class="built_in">document</span>.querySelector(<span class="string">'.container'</span>)</span><br><span class="line">  container.innerHTML = <span class="string">''</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; navList.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> nav = navList[i]</span><br><span class="line">    container.appendChild(createCard(i, nav.href, nav.desp, nav.logo))</span><br><span class="line">  &#125;</span><br><span class="line">  container.appendChild(createCard(navList.length, <span class="string">'/'</span>, <span class="string">'添加'</span>, <span class="string">'+'</span>))</span><br><span class="line">  localStorage.setItem(<span class="string">'navList'</span>, <span class="built_in">JSON</span>.stringify(navList))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样渲染功能也大功告成了！</p><h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><p>最后是 tab 页提供的新增功能</p><p>分析需求可得</p><ol><li>只允许 http 或 https 开头的 url</li><li>取 url 去掉协议后的第一个字符作为 logo</li><li>渲染到最后一个，但还在”添加”标签页之前</li></ol><p>于是可得如下 js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertCard</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="built_in">document</span>.querySelector(<span class="string">'#url'</span>).value</span><br><span class="line">  <span class="keyword">let</span> desp = <span class="built_in">document</span>.querySelector(<span class="string">'#desp'</span>).value</span><br><span class="line">  <span class="keyword">if</span> (!url.match(<span class="string">'[http|https]://*'</span>)) &#123;</span><br><span class="line">    alert(<span class="string">'请输入包含http或https的链接格式！'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tab = <span class="built_in">document</span>.querySelector(<span class="string">'#tab'</span>)</span><br><span class="line">    tab.style.display = <span class="string">'none'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> logo = (url.split(<span class="string">'//'</span>)[<span class="number">1</span>])[<span class="number">0</span>].toUpperCase()</span><br><span class="line"></span><br><span class="line">  navList.push(<span class="built_in">JSON</span>.parse(<span class="string">'&#123; "href": "'</span> + url + <span class="string">'", "desp": "'</span> + desp + <span class="string">'", "logo": "'</span> + logo + <span class="string">'" &#125;'</span>))</span><br><span class="line"></span><br><span class="line">  draw()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是主要功能，但是这个 tab 页还得支持关闭呀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tab = <span class="built_in">document</span>.querySelector(<span class="string">'#tab'</span>)</span><br><span class="line">  tab.style.display = <span class="string">'none'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新 none 就好了</p><p>ok，运行试试吧，这就是你的前端导航项目</p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p>其实简单的项目还有很多值得改进的地方</p><p>比如我这个写法，并没有完美复刻设计图</p><p>大致有以下改进点</p><ol><li>完美复刻设计图</li><li>改用 vue 或 react 做这个项目</li><li>支持用户在线保存设置</li><li>改善 logo，支持图片</li></ol><p>以上点就够喝一壶了2333</p><p>那就到这里了</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拥有无限潜能的前端导航项目&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="project" scheme="http://yoursite.com/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>同源策略与跨域方案</title>
    <link href="http://yoursite.com/frontend/cross-domain/"/>
    <id>http://yoursite.com/frontend/cross-domain/</id>
    <published>2020-12-10T15:00:00.000Z</published>
    <updated>2020-12-13T14:27:38.203Z</updated>
    
    <content type="html"><![CDATA[<p>有时候浏览器的 ajax 请求不能正常拉取到别的站点的数据，这是为什么呢？</p><a id="more"></a><hr><h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>为了阻止一些低成本的跨站攻击，浏览器采取了同源策略</p><p>同源策略要求 3 个标准都要完全一致</p><ol><li>协议</li><li>域名</li><li>端口</li></ol><p>三个只要有任何一个不一致，那就认为不是同源，这时候的请求虽然能成功发到目标服务器，但并不能取得数据，因为数据被浏览器扣留了</p><p>举几个例子（http 默认地址是 80 端口，https 是 443，此时写与不写并无区别）</p><table><thead><tr><th>站点 A</th><th>站点 B</th><th>是否同源</th></tr></thead><tbody><tr><td><a href="http://ringoer.com/" target="_blank" rel="noopener">http://ringoer.com/</a></td><td><a href="https://ringoer.com/" target="_blank" rel="noopener">https://ringoer.com/</a></td><td>否，协议不同</td></tr><tr><td><a href="https://www.ringoer.com/" target="_blank" rel="noopener">https://www.ringoer.com/</a></td><td><a href="https://ringoer.com/" target="_blank" rel="noopener">https://ringoer.com/</a></td><td>否，域名不同</td></tr><tr><td><a href="https://ringoer.com:12450/" target="_blank" rel="noopener">https://ringoer.com:12450/</a></td><td><a href="https://ringoer.com/" target="_blank" rel="noopener">https://ringoer.com/</a></td><td>否，端口不同</td></tr><tr><td><a href="https://ringoer.com/archives/" target="_blank" rel="noopener">https://ringoer.com/archives/</a></td><td><a href="https://ringoer.com/tags/index.html" target="_blank" rel="noopener">https://ringoer.com/tags/index.html</a></td><td>是</td></tr></tbody></table><p>同源又称之为”同一个域”（不是域名）</p><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>但有的时候不得不跨站请求数据，比如前后端分离的时候，服务器地址往往和前端地址不一样</p><p>为了解决同源策略带来的限制，提出了跨域方案</p><p>常用的跨域方案有 JSONP 跨域和 CORS 跨域，还有一些其它的基于 iframe 的跨域，此处不介绍</p><h1 id="JSONP-跨域"><a href="#JSONP-跨域" class="headerlink" title="JSONP 跨域"></a>JSONP 跨域</h1><p>JSONP 跨域是在 IE 上的一种妥协</p><p>主要原理是利用 js 脚本可以任意引用，从而在 A 站与 B 站达成协议的情况下，B 站直接在 js 脚本里包藏数据，A 站直接引用这个脚本</p><p>但是 A 站引用后也不能直接看到脚本内容，所以通常采用的方式是 A 站预定义一个数据处理方法，B 站在脚本中直接调用该方法并传入数据</p><p>同时一般为了保持隐秘性，会让每次的数据处理方法名都不一样</p><p>一个 JSONP 实例如下</p><p>首先准备两台服务器模拟 A 站和 B 站</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> ringoer = express();</span><br><span class="line"></span><br><span class="line">ringoer.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serverringoer = ringoer.listen(<span class="number">9999</span>, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> host = serverringoer.address().address;</span><br><span class="line">  <span class="keyword">var</span> port = serverringoer.address().port;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"启动于 http://%s:%s"</span>, host, port);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/friends.json'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(__dirname + <span class="string">'/friends.json'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/friends.js'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> str = fs.readFileSync(<span class="string">'friends.js'</span>).toString()</span><br><span class="line">  <span class="keyword">let</span> json = fs.readFileSync(<span class="string">'friends.json'</span>).toString()</span><br><span class="line">  <span class="keyword">let</span> random = req.query.callback</span><br><span class="line">  str = str.replace(<span class="string">'&#123;&#123;callback&#125;&#125;'</span>, random.toString())</span><br><span class="line">    .replace(<span class="string">`'&#123;&#123;data&#125;&#125;'`</span>, json)</span><br><span class="line">  <span class="built_in">console</span>.log(str)</span><br><span class="line">  res.send(str);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/static/*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(__dirname + req.path);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8888</span>, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> host = server.address().address;</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"启动于 http://%s:%s"</span>, host, port);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后准备一个 html 用于显示 A 站的页面，请求 B 站的数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>点我发请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"data"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    test.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> random = <span class="built_in">Math</span>.random().toString()</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span></span><br><span class="line"><span class="javascript">      script.src = <span class="string">'http://qq.com:8888/friends.js?callback='</span> + random</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>[random] = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        data.innerHTML = <span class="built_in">JSON</span>.stringify(res)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.body.appendChild(script)</span></span><br><span class="line"><span class="javascript">      script.onload = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">        script.remove()</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>html 里的内部 js 定义了一个随机函数，函数的效果是将字符串塞进显示区域内</p><p>同时定义了 script 标签取回后的动作，是执行取回的 js 后（默认动作），移除自身这个标签</p><p>再准备一个 friend.js 用于给 B 站返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>[<span class="string">'&#123;&#123;callback&#125;&#125;'</span>](</span><br><span class="line">  <span class="string">'&#123;&#123;data&#125;&#125;'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>该代码执行一个函数，传入指定的数据</p><p>这里是保留两个占位符，用服务器取得的请求参数（B 站代码的第 15 行）和数据库里取回的数据来填充</p><p>所以还要再写一个 json 用来临时顶替数据库保存数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"ringoer"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"enatsu"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>先设置一下本地的 hosts 文件改变寻址，再启动两台服务器，访问 A 站的首页并点击按键发送请求，就可以看到原本不能取得的数据被打印在了 A 站首页的内容区域</p><h1 id="CORS-跨域"><a href="#CORS-跨域" class="headerlink" title="CORS 跨域"></a>CORS 跨域</h1><p>CORS 跨域是利用 Access-Control-Allow-Origin 的请求头，来设置跨域允许</p><p>该请求头一般是在服务端处理请求，要回送响应的时候，设置在响应包中</p><p>该请求头的值可以是星号表示允许所有跨域，也可以是由分号分隔的域名列表</p><p>一个 CORS 实例如下</p><p>首先准备两台服务器模拟 A 站和 B 站</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> ringoer = express();</span><br><span class="line"></span><br><span class="line">ringoer.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serverringoer = ringoer.listen(<span class="number">9999</span>, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> host = serverringoer.address().address;</span><br><span class="line">  <span class="keyword">var</span> port = serverringoer.address().port;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"启动于 http://%s:%s"</span>, host, port);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/friends.json'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://enatsu.com:9999'</span>)</span><br><span class="line">  res.sendFile(__dirname + <span class="string">'/friends.json'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/static/*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(__dirname + req.path);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8888</span>, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> host = server.address().address;</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"启动于 http://%s:%s"</span>, host, port);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后准备一个 html 用于显示 A 站的页面，请求 B 站的数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"static/style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>点我发请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"data"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    test.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">      xhr.open(<span class="string">'GET'</span>, <span class="string">'http://qq.com:8888/friends.json'</span>)</span></span><br><span class="line"><span class="javascript">      xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="undefined">          data.innerText = xhr.response</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      xhr.send()</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>html 里的内部 js 定义了一个 ajax，并规定当 ajax 返回数据时，填充数据到内容区域</p><p>再准备一个 friend.json 用于给 B 站返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"ringoer"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"enatsu"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>先设置一下本地的 hosts 文件改变寻址，再启动两台服务器，访问 A 站的首页并点击按键发送请求，就可以看到数据成功填充，并且控制台的请求包有 ‘Access-Control-Allow-Origin’ 字段</p><h1 id="简单请求和非简单请求"><a href="#简单请求和非简单请求" class="headerlink" title="简单请求和非简单请求"></a>简单请求和非简单请求</h1><p>但是刚刚的 CORS 跨域只是最简单的 CORS 跨域，其实 CORS 跨域还有很多限制</p><p>浏览器将CORS请求分成两类：简单请求和非简单请求</p><p>只要同时满足以下两大条件，就属于简单请求</p><ol><li><p>请求方法是以下三种方法之一</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>刚才的例子中我们采用的就是 GET 方法</p></li><li><p>HTTP 请求包的头部不含有除以下字段外的其它字段</p><ul><li><p>Accept</p></li><li><p>Accept-Language</p></li><li><p>Content-Language</p></li><li><p>Last-Event-ID</p></li><li><p>Content-Type，只能是空或以下三种之一</p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul><p>可见 application/json 请求是不行的</p></li></ul></li></ol><p>这是为了兼容表单，因为历史上表单一直可以发出跨域请求</p><p>ajax 的跨域设计就是，只要表单可以发，ajax 就可以直接发</p><p>说是上面那么说，其实实际开发的时候谁记得住（</p><p>只要记得把 Chrome 开发者工具的 Disable cache 开了，然后看看请求有没有发个 options 预检就行了</p><p>如果后端没有配置的话，任何非简单请求都不会被放行</p><h1 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h1><p>对于简单请求，浏览器会在请求包中增加一个 Origin 字段，然后直接发出 CORS 请求</p><p>如果 Origin 指定的源不在许可范围内，服务器就会返回一个正常的 HTTP 响应，浏览器发现响应包中没有 Access-Control-Allow-Origin 字段，就会抛出一个错误</p><p>如果成功返回了，浏览器得到的响应可能会多出几个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://enatsu.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: Authorization</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>其中前三个都是和 CORS 高度相关的头部，且第一个和第四个是一定会出现的头部</p><h2 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h2><p>如果 CORS 成功返回，则该字段只能是两种情况之一</p><ol><li>星号，表示允许所有跨域</li><li>与请求中 Origin 字段相同</li></ol><h2 id="Access-Control-Allow-Credentials"><a href="#Access-Control-Allow-Credentials" class="headerlink" title="Access-Control-Allow-Credentials"></a>Access-Control-Allow-Credentials</h2><p>浏览器在 CORS 请求中默认是不发送 Cookie 的</p><p>如果服务器允许该源的 CORS 请求发送 Cookie，将该字段设为 true 即可</p><p>该字段不能设为 false，如果想设为 false，可以直接删除该字段</p><h2 id="Access-Control-Expose-Headers"><a href="#Access-Control-Expose-Headers" class="headerlink" title="Access-Control-Expose-Headers"></a>Access-Control-Expose-Headers</h2><p>浏览器在 CORS 请求中，响应包的默认头部一般只有以下 6 个基本字段</p><ol><li>Cache-Control</li><li>Content-Language</li><li>Content-Type</li><li>Expires</li><li>Last-Modified</li><li>Pragma</li></ol><p>但是看到 Etag 什么的也别惊讶，毕竟实际开发不能认死理对吧</p><p>如果需要让浏览器拿到其它字段，服务器必须设置该字段的值</p><p>比如上例中设置该字段的值为 Authorization，则浏览器就可以从响应头部中取得字段 Authorization 的值</p><h2 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h2><p>该字段取值取决于返回的数据类型，不解释了</p><h2 id="withCredentials"><a href="#withCredentials" class="headerlink" title="withCredentials"></a>withCredentials</h2><p>刚才说到浏览器在 CORS 请求中默认是不发送 Cookie 的，如果有这个需求，应该由服务器设置 Access-Control-Allow-Credentials 为 true</p><p>但其实这样还不够，原则上来说，不止服务端要同意，前端也要主动设置 XMLHTTPRequest 的 withCredentials 为 true，否则即使服务器同意，前端也不会发送 Cookie</p><p>但是呢，还是有的浏览器搞特殊，不设也会发，所以刚才只是说原则上是这样，2333</p><p>除了这两个要求之外，当有跨域 Cookie 需求的时候，Access-Control-Allow-Origin 的值也不能是星号，必须是具体值</p><h1 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h1><p>当你请求动词是 PUT、DELETE 之类的时候，或者 Content-Type 是 application/json 的时候，就是非简单请求</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）</p><h2 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h2><p>浏览器会先向目标服务器发送一个 OPTIONS 请求，询问服务器当前域名是否被许可，以及允许哪些 HTTP 动词和头部字段</p><p>预检请求除了请求方法是 OPTIONS 之外，还包含三个关键字段</p><ol><li>Origin，表示请求源</li><li>Access-Control-Request-Method，表示浏览器会用到哪些 HTTP 请求动词</li><li>Access-Control-Request-Headers，表示浏览器会发送哪些简单请求之外的头部字段，用逗号隔开</li></ol><p>上述前两个字段都是必须给出的</p><h2 id="预检请求的响应"><a href="#预检请求的响应" class="headerlink" title="预检请求的响应"></a>预检请求的响应</h2><p>服务器确认了上述三个字段的值之后，就会做出响应</p><p>如果服务器拒绝响应，会返回一个正常的 HTTP 响应，但是没有任何头部字段，浏览器就会认为服务器拒绝了跨域预检申请，此时会触发 ajax 或 XMLHttpRequest 的 error 事件</p><p>如果服务器同意了预检请求，就会在返回的响应包中加入一些特殊的头部字段，一般有以下 4 种</p><ol><li><p>Access-Control-Allow-Methods，指示服务器接受哪些 HTTP 方法，必须</p></li><li><p>Access-Control-Allow-Headers，指示服务器允许的头部字段</p><p>如果请求中包含 Access-Control-Request-Headers 字段，则响应中该字段是必须的</p></li><li><p>Access-Control-Allow-Credentials，指示是否允许跨域 Cookie，与简单请求中相同</p></li><li><p>Access-Control-Max-Age，指示当前预检请求的有效期，单位为秒，在有效期内不需要再次发出第二次预检请求</p></li></ol><h2 id="预检请求之后"><a href="#预检请求之后" class="headerlink" title="预检请求之后"></a>预检请求之后</h2><p>即便通过了预检，浏览器和服务器之间的交互还是存在间隙，不能像真同源一样通信</p><p>具体表现在浏览器会在每条请求中都加入 Origin 字段，服务器则会在每条响应中都加入 Access-Control-Allow-Origin 字段</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CORS 跨域，功能更强大，但是细节更复杂，需要开发者盯紧开发者工具，并且和后端的同学协调好（但是也便于甩锅2333</p><p>JSONP 跨域只支持 GET 方法，但是支持旧时代的浏览器（比如 IE），以及向某些达成合意但是因为某些原因不支持 CORS 的网站发送跨域请求</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候浏览器的 ajax 请求不能正常拉取到别的站点的数据，这是为什么呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="browser" scheme="http://yoursite.com/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>异步回调与Promise</title>
    <link href="http://yoursite.com/frontend/promise/"/>
    <id>http://yoursite.com/frontend/promise/</id>
    <published>2020-12-07T09:41:00.000Z</published>
    <updated>2020-12-13T08:37:54.360Z</updated>
    
    <content type="html"><![CDATA[<p>在 ajax 中，我们提到了 Promise 式封装</p><p>那么什么是 Promise 呢？</p><a id="more"></a><p>首先要来介绍一下什么是异步回调</p><p>我们在计算机网络中学过通信方式一般有三种：全双工、半双工、单工</p><p>最理想的方式当然是全双工</p><h1 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h1><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步也是一种全双工</p><p>简单来说，就是当一个任务发出后，发件人不需要等待执行方的返回结果，而可以先去做其它事情，等待</p><p>比如你加某个人为 qq 好友，发出请求后你就不需要管了，可以自己先去聊天，等到对方同意或拒绝你的好友请求，你才会收到通知，回来处理这件事</p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>那回调又是什么呢？回调其实解决了异步的一个非常重要的问题——我要这个结果做什么用，简单说就是当异步结果返回的时候，该做什么呢</p><p>在上文 qq 好友的例子中，qq 通知你好友请求返回结果了，你根据结果做出的动作就是回调</p><p>比如好友请求通过，你的回调就是找好友聊天</p><p>比如失败，你的回调可能是自我分析是什么情况，也可以是什么都不做</p><p>在浏览器中，就是浏览器的异步请求取回结果的时候，如果是成功，要进行什么处理、给出什么输出呢？失败的话要不要处理、怎么处理这个错误呢？</p><p>举个例子，就是 setTimeout</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'success'</span>)</span><br><span class="line">setTimeout(fn,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>执行 setTimeout 后，将在 1000ms 后执行 fn</p><p>此处的 fn 就是回调函数</p><h2 id="异步和回调的关系"><a href="#异步和回调的关系" class="headerlink" title="异步和回调的关系"></a>异步和回调的关系</h2><p>上文可以看出，回调函数其实就是事件完成后，处理结果的方法</p><p>但其实事件不一定是异步的，也可以是同步的</p><p>即便是同步的函数，也可以使用回调函数，区别只不过是异步任务执行后可以先做别的再收通知，同步任务执行后必须原地等通知罢了</p><p>但是如果一层层回调，会变成什么样呢</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">       setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">           run()</span><br><span class="line">       &#125;,<span class="number">0</span>) </span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>看，是不是随着回调层数的增加，代码逐渐向右突出。。。这也太难看了</p><p>这就是回调地狱</p><p>而为了解决这个问题，提出了 Promise</p><h1 id="Promise-定义"><a href="#Promise-定义" class="headerlink" title="Promise 定义"></a>Promise 定义</h1><p>Promise 是将“生产者代码”和“消费者代码”连接在一起的一个特殊的 JavaScript 对象。</p><p>用我们的类比来说：这就是就像是“订阅列表”。</p><p>“生产者代码”花费它所需的任意长度时间来产出所承诺的结果，而 “promise” 将在它准备好时，将结果向所有订阅了的代码开放。</p><h1 id="Promise-用途"><a href="#Promise-用途" class="headerlink" title="Promise 用途"></a>Promise 用途</h1><p>一开始主要是为了解决回调地狱而产生的</p><p>现在则已经是前端异步处理的统一解决方案</p><h1 id="Promise-用法"><a href="#Promise-用法" class="headerlink" title="Promise 用法"></a>Promise 用法</h1><p>一般在函数中作为函数返回值，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">        resolve(<span class="number">233</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码也可以直接赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">    resolve(<span class="number">233</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先介绍一下，Promise 有以下状态</p><ol><li>pending，Promise 尚未返回结果</li><li>settled，Promise 已经返回结果，但不确定是成功还是失败<ol><li>fulfilled，Promise 已经成功（resolve）返回</li><li>rejected，Promise 已经失败（reject）返回</li></ol></li></ol><p>可见，Promise 的构造函数要求传入一个包含两个参数的 executor（可执行代码段），两个参数分别是 Promise 给出的两个函数，分别指示 resolve 和 reject 调用的函数</p><p>当然两个参数也可以叫别的名字，只要顺序不变就没有影响，但是一般都是叫 resolve 和 reject</p><p>这段 executor 是立即执行的，但是对结果的处理是异步的，直到 settled 之前，这个 Promise 都不算结束</p><p>即使在 executor 中，半路上就 resolve/reject 了，executor 的代码段还是会完整执行，不会中断</p><p>那么怎么处理 Promise 的返回结果呢？</p><h1 id="Promise-方法"><a href="#Promise-方法" class="headerlink" title="Promise 方法"></a>Promise 方法</h1><p>Promise 的 prototype 上有 3 个重要的回调方法</p><ol><li>then</li><li>catch</li><li>finally</li></ol><p>3 个方法都支持链式调用</p><h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><p>then 方法的函数声明伪代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123; <span class="comment">/* handle a successful result */</span> &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="comment">/* handle an error */</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以接受两个参数，分别表示对于 fulfilled 和 rejected 状态的 Promise 结果的处理函数</p><p>第一个函数接受一个参数，表示成功的结果</p><p>第二个函数接受一个参数，表示失败的原因</p><p>其中 fulfilled 结果处理函数是必要的，rejected 处理函数可以不写出，但如果 Promise 被 reject，而没有其它地方处理这个 error 的话，会直接报错，停止解释器</p><p>上例中的代码，加上 then 回调后，变为如下模样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">    resolve(<span class="number">233</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// expected output: 233</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>then 可以多级传递，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">    resolve(<span class="number">233</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// expected output: 233</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">114514</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// expected output: 114514</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>链式调用中，结果会沿着链传递</p><p>但是分开调用是不对的，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">    resolve(<span class="number">233</span>)</span><br><span class="line">&#125;)</span><br><span class="line">task.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// expected output: 233</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">114514</span></span><br><span class="line">&#125;)</span><br><span class="line">task.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// expected output: 233</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>分开调用，结果不会互相传递</p><p>then 中除了被动出错，也可以使用 throw 子句主动抛出错误</p><h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><p>上例中使用 catch 的话，一般可以写成以下模样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123; <span class="comment">// executor</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">    reject(<span class="number">233</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123; <span class="comment">// then</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果在 Promise 的 executor 或者 then 中出错了，都可以用 catch 捕获错误，因为 catch 在他们的下游</p><p>此时如果是 executor 出错，then 会被跳过，沿着 Promise 链往下寻找 catch 直到找到第一个 catch 为止</p><p>catch 既然支持链式调用，那么 catch 自然也可以再抛出</p><p>比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123; <span class="comment">// executor</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">    reject(<span class="string">'2323'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123; <span class="comment">// then</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err!==<span class="string">'233'</span>) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err 233 is catched'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意，此处要使用 throw 子句来抛出，不能是 return</p><p>如果是 return，接下来的结果就要用 then 来接收</p><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>上例中使用 finally 的话，一般可以写成以下模样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123; <span class="comment">// executor</span></span><br><span class="line">    resolve(<span class="number">233</span>)</span><br><span class="line">&#125;).finally(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 开始运行'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// expected output: 233</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>显然，finally 不一定要写在最后，一般只是用来做阶段性封口而已</p><p>比如此处，在 executor 执行完毕后，不论 executor 是否出错，都会执行 finally，告诉用户 promise 开始了</p><p>然后，不论是 resolve 还是 reject，结果都会越过 finally 传递到可以处理这个结果的回调</p><hr><p>以上就是 Promise 的基本用法</p><p>现在来深究一下 Promise 这么个好东</p><h1 id="Promise-手写"><a href="#Promise-手写" class="headerlink" title="Promise 手写"></a>Promise 手写</h1><p>面试必考的手写 Promise 部分，你会多少呢？</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>首先先实现基本的 Promise 功能——resolve 和 reject</p><p>容易想到以下基本形</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">    executor(resolve,reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 resolve 和 reject 从哪里来？显然要由 Promise 提供</p><p>这两个函数还兼顾了取结果和改状态的效果，所以得到如下形状</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        executor(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="keyword">this</span>.reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">this</span>.result = result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">this</span>.result = err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改数据的时候，要注意不能随便覆盖结果</p><p>注意，我们要在 resolve 和 reject 中使用访问 this 的 status 和 result，所以这两个函数</p><ol><li>必须有自己的 this，不能是箭头函数</li><li>必须指向当前操作的对象，所以要使用 bind 绑定 this</li></ol><p>这样 Promise 最基本的功能就实现了，接下来实现最重要的功能 then</p><h2 id="Promise-then"><a href="#Promise-then" class="headerlink" title="Promise.then"></a>Promise.then</h2><p>容易得到以下形状</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">success,fail</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'fulfilled'</span>) <span class="keyword">this</span>.result = success(<span class="keyword">this</span>.result)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">this</span>.result = fail(<span class="keyword">this</span>.result)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这时候我们发现，这个 then 只能执行同步的链式调用</p><p>那怎么异步调用呢？答案就是发布订阅模式</p><p>可以得到以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.onfulfilled = []</span><br><span class="line">    <span class="keyword">this</span>.onrejected = [] <span class="comment">// 添加两个事件组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        executor(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="keyword">this</span>.reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">this</span>.result = result</span><br><span class="line">        <span class="keyword">this</span>.onfulfilled.map(<span class="function"><span class="params">event</span>=&gt;</span>event.call(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">this</span>.result = err</span><br><span class="line">        <span class="keyword">this</span>.onrejected.map(<span class="function"><span class="params">event</span>=&gt;</span>event.call(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">success,fail</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.onfulfilled.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = success(<span class="keyword">this</span>.result)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">this</span>.onrejected.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = fail(<span class="keyword">this</span>.result)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span>) <span class="keyword">this</span>.result = success(<span class="keyword">this</span>.result)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.result = fail(<span class="keyword">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p=<span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>resolve(<span class="number">233</span>),<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res++)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>可以得到以下结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line"><span class="number">233</span></span><br><span class="line"><span class="number">666</span></span><br></pre></td></tr></table></figure><p>现在 then 也可以支持异步返回了！但是 catch 似乎还没实现，不过我水平不够了，到此为止了2333</p><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>Promise.all 的核心要义就是传入多个 Promise，然后按顺序返回所有结果</p><p>容易想到以下形状</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">P.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> n = <span class="number">0</span>, len = promises.length</span><br><span class="line">            <span class="keyword">let</span> ans = []</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> promises)&#123;</span><br><span class="line">                P.resolve(promises[i])</span><br><span class="line">                .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                    ans[i] = res</span><br><span class="line">                    n++</span><br><span class="line">                    <span class="keyword">if</span>(n === len)&#123;</span><br><span class="line">                        resolve(ans)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们还需要一个 P.resolve 来得到一个新的 P</p><p>所以还要写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P.resolve = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(data <span class="keyword">instanceof</span> P)&#123;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>resolve(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以下测试例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = P.resolve(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> P(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">100</span>, <span class="string">'foo'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">P.all([promise1, promise2, promise3]).then(<span class="function"><span class="keyword">function</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可得结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, &quot;foo&quot;, 42]</span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><p>Promise.race 的核心要义就是传入多个 Promise，然后返回第一个决议的结果，无论是成功还是失败</p><p>其实把 all 的计数器去掉就可以了</p><p>容易想到以下形状</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">P.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> ans = <span class="literal">undefined</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> promises)&#123;</span><br><span class="line">                P.resolve(promises[i])</span><br><span class="line">                .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                    ans = res</span><br><span class="line">                    resolve(ans)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以下测试例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> P(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">500</span>, <span class="string">'one'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> P(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">100</span>, <span class="string">'two'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">P.race([promise1, promise2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可得结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two</span><br></pre></td></tr></table></figure><h2 id="完整的-Promise"><a href="#完整的-Promise" class="headerlink" title="完整的 Promise"></a>完整的 Promise</h2><p>总结一下，可以得到如下的手写 Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.onfulfilled = []</span><br><span class="line">    <span class="keyword">this</span>.onrejected = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        executor(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="keyword">this</span>.reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">this</span>.result = result</span><br><span class="line">        <span class="keyword">this</span>.onfulfilled.map(<span class="function"><span class="params">event</span>=&gt;</span>event.call(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">this</span>.result = err</span><br><span class="line">        <span class="keyword">this</span>.onrejected.map(<span class="function"><span class="params">event</span>=&gt;</span>event.call(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">success,fail</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.onfulfilled.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = success(<span class="keyword">this</span>.result)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">this</span>.onrejected.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = fail(<span class="keyword">this</span>.result)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span>) <span class="keyword">this</span>.result = success(<span class="keyword">this</span>.result)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.result = fail(<span class="keyword">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">P.resolve = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(data <span class="keyword">instanceof</span> P)&#123;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>resolve(data))</span><br><span class="line">&#125;</span><br><span class="line">P.reject = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(data <span class="keyword">instanceof</span> P)&#123;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>reject(data))</span><br><span class="line">&#125;</span><br><span class="line">P.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> n = <span class="number">0</span>, len = promises.length</span><br><span class="line">            <span class="keyword">let</span> ans = []</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> promises)&#123;</span><br><span class="line">                P.resolve(promises[i])</span><br><span class="line">                .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                    ans[i] = res</span><br><span class="line">                    n++</span><br><span class="line">                    <span class="keyword">if</span>(n === len)&#123;</span><br><span class="line">                        resolve(ans)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">P.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> ans = <span class="literal">undefined</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> promises)&#123;</span><br><span class="line">                P.resolve(promises[i])</span><br><span class="line">                .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                    ans = res</span><br><span class="line">                    resolve(ans)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.javascript.info/promise-basics" target="_blank" rel="noopener">Promise</a></p><p><a href="https://www.jianshu.com/p/90b6280dd1b6" target="_blank" rel="noopener">手写Promise.all和Promise.race</a></p><hr><p>谢谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 ajax 中，我们提到了 Promise 式封装&lt;/p&gt;
&lt;p&gt;那么什么是 Promise 呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>事件循环</title>
    <link href="http://yoursite.com/frontend/event-loop/"/>
    <id>http://yoursite.com/frontend/event-loop/</id>
    <published>2020-12-07T09:39:00.000Z</published>
    <updated>2020-12-12T11:35:46.370Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常看到 setTimeout 中延迟设置为 0，但真的是 0 延迟吗？</p><a id="more"></a><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>这涉及到 javascript 的事件循环机制</p><p>众所周知，javascript 是单线程的，但是却支持异步，和 CPU 非常相似</p><p>对照 CPU 的进程调度，可以发现任务是排队执行的，并且有不同的优先级队列</p><p>但是我们可以发现，以下输出不是按顺序的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'then1'</span>)).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'then4'</span>))</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'then2'</span>)).then(<span class="function"><span class="params">res</span>=&gt;</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)&#125;,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'promise'</span>)&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'then3'</span>))</span><br></pre></td></tr></table></figure><p>实际运行一下，得到输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">then1</span><br><span class="line">then2</span><br><span class="line">then3</span><br><span class="line">then4</span><br><span class="line">setTimeout1</span><br><span class="line">setTimeout2</span><br></pre></td></tr></table></figure><p>为什么会这样？？</p><p>这就涉及到宏任务和微任务的概念</p><h1 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h1><p>上文中提到单线程，任务队列，事件循环</p><p>之所以称之为 事件循环，是因为它经常按照类似如下的方式来被实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</span><br><span class="line">  queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个</p><p>任务队列又分为 macro-task（宏任务）与 micro-task（微任务），在最新标准中，它们被分别称为 task 和 jobs</p><p>用操作系统说法，就是进程和线程的区别</p><p>上例可以做如图表示</p><p><img src="https://pic.ringoer.com/event-loop-0.png" alt=""></p><p>因为 new Promise 中 settled 之前的函数都是同步进行的，所以先打印 promise</p><p>当这一轮主线程执行完毕的时候，变为如图情况</p><p><img src="https://pic.ringoer.com/event-loop-1.png" alt=""></p><p>此时，引擎发现，虽然当前主线程为空，但微任务队列不为空，所以当前宏任务还不算结束</p><p>于是引擎将微任务队列的任务都塞进主线程，这个过程就是 <strong>开启下一次事件循环</strong></p><p><img src="https://pic.ringoer.com/event-loop-2.png" alt=""></p><p>再次执行完毕后，变为如图情况</p><p><img src="https://pic.ringoer.com/event-loop-3.png" alt=""></p><p>此时微任务队列依然不为空，再次优先执行微任务队列中的任务</p><p>执行完后变为如图情况</p><p><img src="https://pic.ringoer.com/event-loop-4.png" alt=""></p><p>微任务队列终于空了！主线程开始取宏任务队列中的队首任务，变为如图情况</p><p><img src="https://pic.ringoer.com/event-loop-5.png" alt=""></p><p>执行完毕后，发现微任务队列还是空的，于是再取宏任务，再空，终于所有任务都执行完了！</p><p>这就是 JS 事件调度的过程，可见 setTimeout(fn,0) 并不是真正的 0 延迟执行，而是“尽可能快”</p><p>显然代码可以分为三种</p><ol><li>立即执行的代码</li><li>微任务</li><li>宏任务</li></ol><p>则事件循环的实现，大致有如下伪代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!mainQueue.empty()) &#123;</span><br><span class="line">        solve(mainQueue.front());</span><br><span class="line">        mainQueue.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(microQueue.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!macroQueue.empty())&#123;</span><br><span class="line">            mainQueue.push(macroQueue.front());</span><br><span class="line">            macroQueue.pop();</span><br><span class="line">            render.run();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!microQueue.empty())&#123;</span><br><span class="line">            mainQueue.push(microQueue.front());</span><br><span class="line">            microQueue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文字描述如下</p><ul><li>处理主线程中所有任务</li><li>若微任务队列为空<ul><li>若宏任务队列不为空，则取宏任务队列的队首到主线程中，并在开启下一个事件循环前，进行页面渲染</li></ul></li><li>若微任务队列不为空，则将微任务队列中所有任务加入主线程中</li></ul><p>那么哪些是微任务，哪些是宏任务呢？</p><p>一般有如下认定与支持</p><table><thead><tr><th>宏任务</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td>I/O</td><td>1</td><td>1</td></tr><tr><td>setTimeout</td><td>1</td><td>1</td></tr><tr><td>setInterval</td><td>1</td><td>1</td></tr><tr><td>setImmediate</td><td>0</td><td>1</td></tr><tr><td>requestAnimationFrame</td><td>1</td><td>0</td></tr><tr><td>script 代码块</td><td>1</td><td>0</td></tr></tbody></table><table><thead><tr><th>微任务</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td>Promise.then/catch/finally</td><td>1</td><td>1</td></tr><tr><td>process.nextTick</td><td>0</td><td>1</td></tr><tr><td>MutationObserver</td><td>1</td><td>0</td></tr></tbody></table><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/weixin_30871701/article/details/97270307" target="_blank" rel="noopener">JavaScript的事件队列(Event Queue)—宏任务和微任务</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">并发模型与事件循环</a></p><hr><p>谢谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常看到 setTimeout 中延迟设置为 0，但真的是 0 延迟吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>原生 ajax 详解</title>
    <link href="http://yoursite.com/frontend/ajax/"/>
    <id>http://yoursite.com/frontend/ajax/</id>
    <published>2020-12-06T15:01:00.000Z</published>
    <updated>2020-12-14T13:43:34.851Z</updated>
    
    <content type="html"><![CDATA[<p>做过前后端分离的同学，肯定都知道 ajax 这个异步通信方法</p><a id="more"></a><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>首先肯定是要知道什么是 ajax，毕竟不能保证每个读这篇文章的人都是有前后端分离经验的人（</p><p>Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><p>说这么复杂，其实就是一种前端主动向后端发送 HTTP 请求的技术</p><h1 id="原生写法"><a href="#原生写法" class="headerlink" title="原生写法"></a>原生写法</h1><p>通过 JS 库 XMLHttpRequest 实现</p><p>一般写法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'GET'</span>,<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readystate === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure><p>接下来逐条解释</p><h2 id="创建请求"><a href="#创建请求" class="headerlink" title="创建请求"></a>创建请求</h2><p>通过 new XMLHttpRequest() 可以创建一个请求</p><h2 id="设置请求方法和路径"><a href="#设置请求方法和路径" class="headerlink" title="设置请求方法和路径"></a>设置请求方法和路径</h2><p>通过 xhr.open 方法可以设置请求方法和请求路径</p><p>通常 open 方法一般接受两个参数</p><ol><li>method，表示 HTTP 动词，默认支持 ‘GET’ 或 ‘POST’，大小写没有影响，但一般是大写</li><li>url，表示请求的地址，本例中请求百度首页</li></ol><p>请求默认是异步的，但是当然还可以设置请求为同步，但是严重影响用户体验，故本文不介绍</p><h2 id="请求状态"><a href="#请求状态" class="headerlink" title="请求状态"></a>请求状态</h2><p>一般指 xhr.readystate 和 xhr.status</p><h3 id="readystate"><a href="#readystate" class="headerlink" title="readystate"></a>readystate</h3><p>xhr 一般有 5 个 readystate，含义分别如下</p><table><thead><tr><th>readystate</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>请求被创建</td></tr><tr><td>1</td><td>请求被 open</td></tr><tr><td>2</td><td>请求已经设置好回调，等待发送</td></tr><tr><td>3</td><td>请求已经被 send，等待响应</td></tr><tr><td>4</td><td>请求已经收到响应（不一定是成功）</td></tr></tbody></table><p>因为 readystate === 4 不一定代表成功，所以还引入了第二个属性</p><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>表示请求返回的响应的 HTTP 状态码</p><p>一般 2 开头的表示成功，此处为简单起见直接取 200 来判断</p><h2 id="设置回调"><a href="#设置回调" class="headerlink" title="设置回调"></a>设置回调</h2><p>通过 readystatechange 事件来监听 readystate 的状态以回调</p><p>当 readystate 变为 4 时，会向回调函数中传入一个参数作为结果</p><p>如果成功，则是取回的值，如果失败，则多半没有内容，具体的可以查看 Chrome Network 中的 Response</p><p>所以，我们通过 xhr.onreadystatechange = 包含一个参数的函数，来获取响应的值，并在 readystate === 4 &amp;&amp; status === 200 ——响应成功时，打印取回的值</p><p>注意，设置回调函数要先于发送请求，否则请求异常</p><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>当必要的设置都完成后，就可以发送请求了</p><p>可以通过 xhr.send() 方法来发送请求</p><p>send 方法接受一个可选参数，表示附在请求 body 中的内容，一般是 POST 请求才使用，GET 请求请直接使用拼接 URL</p><h2 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h2><p>当然，还有 abort 方法取消请求、setRequestHeader 方法设置请求头等，此处不介绍了，详询 mdn</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>初级封装就是把上文的代码封装成一个 ajax 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">method,url,callback,data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.open(method,url)</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readystate === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">            callback(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send(data)</span><br><span class="line">&#125;</span><br><span class="line">ajax(<span class="string">'GET'</span>,<span class="string">'https://www.baidu.com/'</span>,<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><p>高级一点的就是用 Promise 封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">method,url,data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(method,url)</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readystate === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(<span class="string">'GET'</span>,<span class="string">'https://www.baidu.com/'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>再高级的我也不会了，就这样吧2333</p><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>现在只有练习和面试的时候会手写原生 ajax 了，正式开发中都是使用基于 ajax 原理的库 axios</p><p>axios 的使用方法与上文中的 Promise 封装相似，详询 axios 中文网，或各个框架的本地化 axios 文档</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做过前后端分离的同学，肯定都知道 ajax 这个异步通信方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>DOM 事件机制</title>
    <link href="http://yoursite.com/frontend/dom-event/"/>
    <id>http://yoursite.com/frontend/dom-event/</id>
    <published>2020-12-05T12:45:00.000Z</published>
    <updated>2020-12-12T14:33:18.900Z</updated>
    
    <content type="html"><![CDATA[<p>弱弱地冒一个泡</p><a id="more"></a><p>经常听到冒泡捕获，那到底是什么东西呢？</p><h1 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h1><p>首先就要介绍一下 W3C DOM 事件模型</p><p>事件总体上分为三个阶段</p><ol><li>捕获阶段，事件从父到子向下传递</li><li>目标阶段，事件传递到达发生事件的目标点</li><li>冒泡阶段，事件从子到父向上传递</li></ol><p>不论是什么事件，没有特殊设置的情况下，都会按顺序经历这三个阶段</p><p>除非该事件被取消冒泡，才会在取消冒泡之后停止传递</p><p>前两个阶段不能停止传递</p><p>通过 on 赋值可以为元素绑定监听器，此时监听器一定是在事件冒泡阶段发生，且后赋值的监听器会覆盖之前的监听器</p><p>例如 <code>button.onclick=()=&gt;{}</code></p><p>通过 addEventListener(eventName, listener, useCapture, priority, useWeakReference) 可以设置监听器是在事件的冒泡阶段还是捕获阶段发生，该方式可以为同一个元素的同一个事件设置多个监听</p><p>useCapture 默认值是 false，表示监听器在事件冒泡阶段发生，反之当为 true 时即表示在捕获阶段发生</p><p>priority 默认值是 0，表示所有同级的监听器按注册顺序进行。可以为个别监听器设置更高的优先级，优先级高的会在该阶段先执行，同优先级的依然按注册顺序进行</p><p>useWeakReference 默认值是 false，表示设置监听器为强引用，使得监听器不被垃圾回收，反之 true 则是允许回收</p><p>当要取消监听器、或要重新设定优先级时，可以使用 removeEventListener() 来取消监听器，之后再重新设定</p><p>每当事件触发一个监听器的时候，都会向监听器内传入两个默认参数</p><p>一个是 this，表示事件现在所处的元素</p><p>一个是 event，包含事件的完整信息</p><h1 id="target-与-currentTarget"><a href="#target-与-currentTarget" class="headerlink" title="target 与 currentTarget"></a>target 与 currentTarget</h1><p>通过在监听器中打印 event，可以发现两件事</p><ol><li>target != currentTarget</li><li>如果先保存 event，事件结束后再打印，则会发现 target 变成了 null</li></ol><p>对于第一点，target 是事件发生的最小元素，也就是唯一有目标阶段的元素</p><p>currentTarget 则是事件现在所处的位置，是传入监听器的 this</p><p>对于第二点，则涉及到事件消亡的知识，篇幅过大，此处不介绍了</p><h1 id="target-元素-事件先后"><a href="#target-元素-事件先后" class="headerlink" title="target 元素 事件先后"></a>target 元素 事件先后</h1><p>刚才说到 target 元素是唯一有目标阶段的元素，那么什么是目标阶段？</p><p>实际上，对于 target 元素来说，目标阶段就是捕获冒泡连续发生，不像事件传递路径上别的元素是分开发生的</p><ul><li>哦哦，那我懂了，所以对 target 元素来说，监听器也是按照设置好的捕获冒泡顺序执行的吧</li><li>不！</li></ul><p>此时监听器不再区分捕获和冒泡，统一按照设置顺序发生</p><h1 id="取消冒泡"><a href="#取消冒泡" class="headerlink" title="取消冒泡"></a>取消冒泡</h1><p>那有时候我想到此为止，不想打扰父级元素，怎么办呢？</p><p>可以在需要中断的元素的冒泡阶段的监听器中，执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.propagetion()</span><br></pre></td></tr></table></figure><p>此时就可以阻止事件继续冒泡</p><h1 id="默认动作"><a href="#默认动作" class="headerlink" title="默认动作"></a>默认动作</h1><p>既然冒泡可以阻止，那默认的事件能不能阻止呢？比如我现在有个 a 标签，想做单页面应用的 tab 页跳转，要是按照默认的，可就跳到新页面去了</p><p>答案是可以！</p><p>在事件中执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.preventDefault()</span><br></pre></td></tr></table></figure><p>就可以阻止默认动作的发生了！</p><h1 id="禁用滚动"><a href="#禁用滚动" class="headerlink" title="禁用滚动"></a>禁用滚动</h1><p>奇怪，说好的阻止默认动作，怎么我在滚动条上不能 prevent，你骗我！</p><p>等下等下，你真的找准是什么东西产生了滚动条了吗？</p><p>有时候你看着是你的元素产生了滚动条，但说不定是 body 产生的！</p><p>找准了之后，我们来禁用滚动条吧——毕竟滚动条其实只是 CSS 产生的东西</p><p>禁用滚动一般分两种：</p><ol><li>看不见滚动条</li><li>看得见滚动条</li></ol><p>对于第一种，其实只需要设置 overflow: hidden 就可以实现了</p><p>对于第二种，比较复杂一些</p><p>首先能看见滚动条，说明 overflow 至少是 auto，甚至是 scroll</p><p>这时候通过划拉滚动条，或者鼠标滚轮，甚至是触屏上的手指，都可以让页面滚动</p><p>这种时候就要分三部分禁止</p><ol><li>禁止滚动条，通过 <code>#div.scrollTop = 0</code>，即可让滚动条锁定在顶端</li><li>禁止鼠标滚轮，通过 <code>#div.onwheel=event=&gt;{event.preventDefault()}</code>，即可阻止滚轮</li><li>禁止触控，通过 <code>#div.ontouchstart=event=&gt;{event.preventDefault()}</code>，即可阻止触控</li></ol><p>既然能在看得见滚动条的情况下禁止滚动，那能不能在看不见滚动条的情况下允许滚动呢？</p><p>于是就又延伸出一个需求。。。</p><p>当然也很简单，通过一个尚未加入标准的 CSS 伪元素即可实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div</span><span class="selector-pseudo">::-webkit-scrollBar</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可实现在看不见滚动条的情况下允许滚动</p><h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><p>那万一我玩得不开心，想自定义一个事件，行不行？</p><p>可以！</p><p>通过以下方法即可创建一个自定义事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> CustomEvent(eventName, &#123; <span class="attr">detail</span>: config &#125;);</span><br></pre></td></tr></table></figure><p>其中第一个参数表示你的事件名称，第二个参数是一个包含 detail 属性的对象</p><p>关于事件的初始化配置，都写在 detail 中</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config=&#123;</span><br><span class="line">    bubbles: <span class="literal">false</span>,</span><br><span class="line">    cancelable: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'test'</span>, &#123; <span class="attr">detail</span>: config &#125;);</span><br></pre></td></tr></table></figure><p>即可创建一个名为 test 的事件，并指示该事件不进行冒泡传递，且不可以被阻止默认动作</p><p>创建完成事件后，还要分发事件，才可以让元素上的监听器正常工作，不然你让浏览器怎么触发你设置的事件？2333</p><p>要分发事件，首先要选中元素，然后触发他身上的事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'#div'</span>)</span><br><span class="line">div.addEventListener(<span class="string">'test'</span>,<span class="built_in">console</span>.log(<span class="number">233</span>))</span><br><span class="line">div.dispatchEvent(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure><p>通过以上代码，就可以为 id 为 div 的元素绑定一个 test 事件的监听器，当事件触发时打印 233</p><p>然后向这个元素分发事件，触发对应的监听器</p><h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>但是有时候，要为很多相似元素各自绑定相同的监听器</p><p>比如一张 10x10 的表格，难道为每个 td 都绑定一个监听器吗？且不说要写 100 行代码，光是 100 个监听器，就卡爆了！</p><p>那么这时候，就需要我们的事件委托</p><p>事件委托就是把大量相似子项的相似逻辑的监听器，全部取消，然后利用事件冒泡传递的特性，把监听器绑定在父项上，使得监听器既能获得事件发生的确切位置，又大幅简化了代码，优化了性能</p><p>比如开头 10x10 表格的例子，就可以将监听器绑定在 table 标签上，借助冒泡传递，获取事件的 target，来处理对应子项的逻辑</p><p>显然，这样是很节省内存的，而且即便后续为表格添加项目，依然可以通过 target 得到事件发生的位置，是非常灵活的</p><p>所以，事件委托有以下三大优点</p><ol><li>节省内存，多个监听器变为 1 个监听器</li><li>动态监听，可以监听未来添加的项目</li><li>封装，大幅简化代码逻辑，易于调试</li></ol><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;弱弱地冒一个泡&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JQuery</title>
    <link href="http://yoursite.com/frontend/jquery/"/>
    <id>http://yoursite.com/frontend/jquery/</id>
    <published>2020-12-05T12:43:00.000Z</published>
    <updated>2020-12-10T15:04:14.928Z</updated>
    
    <content type="html"><![CDATA[<p>DOM API 好难用，我要用 JQ！</p><a id="more"></a><h1 id="什么是-JQuery"><a href="#什么是-JQuery" class="headerlink" title="什么是 JQuery"></a>什么是 JQuery</h1><p>众所周知这 DOM 原生 API 长得 1p，语义还七扭八歪的</p><p>于是就诞生了 JQuery ！</p><p>好吧好吧，简单说就是，这是一个封装了 DOM 操作的库，使用它比直接使用原生 DOM API 更方便，更好读</p><p>那么，为了形成对比，采用和 DOM 那篇一样的结构</p><h1 id="Retrieve"><a href="#Retrieve" class="headerlink" title="Retrieve"></a>Retrieve</h1><p>既然 CSS 选择器这么好用，JQ 怎么能不吸收一下呢</p><p>于是 JQ 采用 <code>$(selector)</code> 来选择元素，返回选择器匹配上的所有元素</p><h1 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h1><p>分为从已有创建和重新创建两种</p><p>对于从已有创建，只需要选中元素后，调用 clone 方法，就可以获得一个拷贝了原元素的新元素</p><p>对于重新创建，只需要直接调用 JQ 构造函数 $，然后传入新元素的 HTML 表示即可</p><h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>分为删除元素和删除内容</p><p>使用 remove 或 detach 方法即可删除元素，但前者不保留元素，后者保留，便于重新插入文档</p><p>使用 empty 方法即可清空元素文本</p><h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>分为</p><ol><li>对 JQ 对象的更新</li><li>对元素的更新</li><li>对元素属性的更新</li><li>对事件的更新</li></ol><h2 id="对-JQ-对象的更新"><a href="#对-JQ-对象的更新" class="headerlink" title="对 JQ 对象的更新"></a>对 JQ 对象的更新</h2><p>可以采用 JQ 专属过滤器来改变结果集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).has(<span class="string">'p'</span>); <span class="comment">// 选择包含p元素的div元素</span></span><br><span class="line">$(<span class="string">'div'</span>).not(<span class="string">'.myClass'</span>); <span class="comment">//选择class不等于myClass的div元素</span></span><br><span class="line">$(<span class="string">'div'</span>).filter(<span class="string">'.myClass'</span>); <span class="comment">//选择class等于myClass的div元素</span></span><br><span class="line">$(<span class="string">'div'</span>).first(); <span class="comment">//选择第1个div元素</span></span><br><span class="line">$(<span class="string">'div'</span>).eq(<span class="number">5</span>); <span class="comment">//选择第6个div元素</span></span><br><span class="line">$(<span class="string">'div'</span>).next(<span class="string">'p'</span>); <span class="comment">//选择div元素后面的第一个p元素</span></span><br><span class="line">$(<span class="string">'div'</span>).parent(); <span class="comment">//选择div元素的父元素</span></span><br><span class="line">$(<span class="string">'div'</span>).closest(<span class="string">'form'</span>); <span class="comment">//选择离div最近的那个form父元素</span></span><br><span class="line">$(<span class="string">'div'</span>).children(); <span class="comment">//选择div的所有子元素</span></span><br><span class="line">$(<span class="string">'div'</span>).siblings(); <span class="comment">//选择div的同级元素</span></span><br><span class="line">$(<span class="string">'div'</span>).siblings().end(); <span class="comment">//返回上一次结果集，此处等效于选中 div</span></span><br></pre></td></tr></table></figure><h2 id="对元素的更新"><a href="#对元素的更新" class="headerlink" title="对元素的更新"></a>对元素的更新</h2><p>其实是指元素在 DOM 树上的位置更新</p><p>一共有 4 对方法</p><table><thead><tr><th>方法名1</th><th>方法名2</th><th>描述</th></tr></thead><tbody><tr><td>insertAfter</td><td>after</td><td>为现有元素插入一个相邻弟弟</td></tr><tr><td>insertBefore</td><td>before</td><td>为现有元素插入一个相邻哥哥</td></tr><tr><td>appendTo</td><td>append</td><td>为现有元素插入一个最小的儿子</td></tr><tr><td>prependTo</td><td>prepend</td><td>为现有元素插入一个最大的儿子</td></tr></tbody></table><p>看起来没什么差别，其实还是有的</p><p>比如第一对方法，调用例如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).insertAfter($(<span class="string">'p'</span>));</span><br><span class="line">$(<span class="string">'p'</span>).after($(<span class="string">'div'</span>));</span><br></pre></td></tr></table></figure><p>显然，虽然都是将 div 元素插入到 p 元素的后面，但前者返回的是对 div 操作的 JQ 元素，后者则是对 p 操作的 JQ 元素</p><p>实际情况下根据需要选择</p><h2 id="对元素属性的更新"><a href="#对元素属性的更新" class="headerlink" title="对元素属性的更新"></a>对元素属性的更新</h2><p>JQ 使用同名方法来作为同一个目标的 getter/setter</p><p>对于 get，如果结果集包含多个元素，则返回第一个元素的值（text 方法例外</p><p>对于 set，不论结果集包含多少元素，对于每个元素都会适配这次 set</p><p>通常有如下 getter/setter 来实现对元素属性的更新</p><table><thead><tr><th>方法</th><th>结果集目标</th><th>描述</th></tr></thead><tbody><tr><td>html()</td><td>第一个元素</td><td>get html 内容</td></tr><tr><td>html(‘233’)</td><td>所有元素</td><td>set html 内容为 ‘233’</td></tr><tr><td>text()</td><td>所有元素</td><td>get text 内容</td></tr><tr><td>text(‘233’)</td><td>所有元素</td><td>set text 内容为 ‘233’</td></tr><tr><td>attr(‘class’)</td><td>第一个元素</td><td>get class</td></tr><tr><td>attr(‘class’,’red’)</td><td>所有元素</td><td>set class 为 red</td></tr><tr><td>width()</td><td>第一个元素</td><td>get width</td></tr><tr><td>width(‘100px’)</td><td>所有元素</td><td>set width 为 100px</td></tr><tr><td>height()</td><td>第一个元素</td><td>get height</td></tr><tr><td>height(‘100px’)</td><td>所有元素</td><td>set height 为 100px</td></tr><tr><td>val()</td><td>第一个元素</td><td>get 某个 input 元素的值</td></tr><tr><td>val(‘233’)</td><td>所有元素</td><td>set 某个 input 元素的值为 ‘233’</td></tr></tbody></table><h2 id="对事件的更新"><a href="#对事件的更新" class="headerlink" title="对事件的更新"></a>对事件的更新</h2><p>直接使用对应事件名作为方法名进行调用</p><p>几乎所有事件都支持</p><p>调用例如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'button'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该调用等效于 set，会更新 JQ 对象结果集中的所有元素，下略</p><p>可以使用 bind 方法来指定多个事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'button'</span>).bind(</span><br><span class="line">    <span class="string">'click change'</span>, <span class="comment">//同时绑定click和change事件</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述绑定方法会重复被触发，但也可以使用 one 方法来设定只触发一次的事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'button'</span>).one(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不想要的事件，也可以用 unbind 方法来解除绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'button'</span>).unbind(<span class="string">'click'</span>)</span><br></pre></td></tr></table></figure><p>当事件触发时，会默认向方法内传入一个参数 event，表示事件发生时的相关信息</p><p>在传入的函数中，如果该函数不是箭头函数，则还可以用 this 来访问触发了该事件的元素</p><p>事件触发除了页面上的操作，还可以用事件函数或 trigger 方法手动触发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'button'</span>).click()</span><br><span class="line">$(<span class="string">'button'</span>).trigger(<span class="string">'click'</span>)</span><br></pre></td></tr></table></figure><h1 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h1><p>除了增删改查，JQ 还提供了一些绑定在 $ 上的方法，不需要选中元素即可调用</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>$.trim()</td><td>去除字符串两端的空格。</td></tr><tr><td>$.each()</td><td>遍历一个数组或对象。</td></tr><tr><td>$.inArray()</td><td>返回一个值在数组中的索引位置。如果该值不在数组中，则返回-1。</td></tr><tr><td>$.grep()</td><td>返回数组中符合某种标准的元素。</td></tr><tr><td>$.extend()</td><td>将多个对象，合并到第一个对象。</td></tr><tr><td>$.makeArray()</td><td>将对象转化为数组。</td></tr><tr><td>$.type()</td><td>判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）。</td></tr><tr><td>$.isArray()</td><td>判断某个参数是否为数组。</td></tr><tr><td>$.isEmptyObject()</td><td>判断某个对象是否为空（不含有任何属性）。</td></tr><tr><td>$.isFunction()</td><td>判断某个参数是否为函数。</td></tr><tr><td>$.isPlainObject()</td><td>判断某个参数是否为用”{}”或”new</td></tr><tr><td>$.support()</td><td>判断浏览器是否支持某个特性。</td></tr></tbody></table><h1 id="特殊效果"><a href="#特殊效果" class="headerlink" title="特殊效果"></a>特殊效果</h1><p>常用的特殊效果方法如下</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>fadeIn()</td><td>淡入</td></tr><tr><td>fadeOut()</td><td>淡出</td></tr><tr><td>fadeTo()</td><td>调整透明度</td></tr><tr><td>hide()</td><td>隐藏元素</td></tr><tr><td>show()</td><td>显示元素</td></tr><tr><td>slideDown()</td><td>向下展开</td></tr><tr><td>slideUp()</td><td>向上卷起</td></tr><tr><td>slideToggle()</td><td>依次展开或卷起某个元素</td></tr><tr><td>toggle()</td><td>依次展示或隐藏某个元素</td></tr></tbody></table><p>每个方法都有两个参数默认值，分别是变化速度 400ms 和回调函数 undefined</p><p>变化速度有两种表示方法，数字表示毫秒，或 slow 等表示指定速度</p><p>回调函数可以指定特效结束时执行的方法</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'h1'</span>).fadeIn(<span class="number">300</span>); <span class="comment">// 300毫秒内淡入</span></span><br><span class="line">$(<span class="string">'h1'</span>).fadeOut(<span class="string">'slow'</span>); <span class="comment">// 缓慢地淡出</span></span><br><span class="line">$(<span class="string">'p'</span>).fadeOut(<span class="number">300</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; $(<span class="keyword">this</span>).remove(); &#125;);</span><br></pre></td></tr></table></figure><p>更复杂的可以使用 animate 自定义</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).animate(</span><br><span class="line">    &#123;</span><br><span class="line">        left : <span class="string">"+=50"</span>,</span><br><span class="line">        opacity : <span class="number">0.25</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">300</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">'done!'</span>); &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>第一个参数填写基于 css 语法的对象，第二个参数表示动画持续时间，第三个参数表示回调函数</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>一个自己封装的 JQ，但是功能肯定比真的 JQ 弱很多，2333</p><p><a href="https://github.com/Ringoer/Toy/blob/main/39/main.js" target="_blank" rel="noopener">https://github.com/Ringoer/Toy/blob/main/39/main.js</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html" target="_blank" rel="noopener">JQuery设计思想</a></p><p><a href="https://www.jquery123.com/" target="_blank" rel="noopener">jQuery API 中文文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DOM API 好难用，我要用 JQ！&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>DOM API</title>
    <link href="http://yoursite.com/frontend/dom-api/"/>
    <id>http://yoursite.com/frontend/dom-api/</id>
    <published>2020-12-05T08:39:00.000Z</published>
    <updated>2020-12-12T14:33:11.111Z</updated>
    
    <content type="html"><![CDATA[<p>只要是学前端的同学，肯定都听说过 DOM</p><a id="more"></a><h1 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h1><p>在 JS 中，常常使用 document.xxx 来对页面进行操作。那实际操作的是什么呢？</p><p>在开发者工具中运行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div=<span class="built_in">document</span>.querySelector(<span class="string">'#container'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(div)</span><br></pre></td></tr></table></figure><p>就可以看到打印出了一个 id 为 container 的元素</p><p>这个元素就是 DOM 元素</p><p>然后去 Elements 中查看，可以发现这些元素呈现层次关系，这个关系正是树形结构</p><p>所以文档结构就是 DOM 树，全称 文档对象模型树（Document Object Model）</p><p>通过打印原型链，可以发现以下原型关系</p><p>Object -&gt; EventTarget -&gt; Node -&gt; Element -&gt; HTMLElement -&gt; HTMLDivElement</p><p>显然，每个 DOM 元素都有自己的属性，但属性原则上属于 DOM 元素的一部分，对属性的操作等效于对元素的操作，故而在 Update 中统一描述</p><h1 id="Retrieve"><a href="#Retrieve" class="headerlink" title="Retrieve"></a>Retrieve</h1><h2 id="查自己"><a href="#查自己" class="headerlink" title="查自己"></a>查自己</h2><p>首先要获取，才能做各种操作</p><p>对于普通的 DOM 元素，一般有如下 API</p><ol><li>document.getElementById(‘xxx’)，获取 id 为 xxx 的元素，包括 IE，全都支持</li><li>window.xxx（或直接使用 xxx），获取 id 为 xxx 的元素，除了 IE，全都支持</li><li>document.getElementsByTagName(‘div’)，获取所有标签名为 div 的元素，返回伪数组</li><li>document.getElementsByClassName(‘yyy’)，获取所有 CSS 类名为 yyy 的元素，返回伪数组</li><li>document.querySelector(selector)，获取第一个满足传入的 CSS 选择器的元素</li><li>document.querySelectorAll(selector)，获取所有满足传入的 CSS 选择器的元素，返回伪数组</li></ol><p>对于特殊的元素，一般有以下 API</p><ol><li>document.documentElement，获取 html 根元素</li><li>document.head，获取 head 元素</li><li>document.body，获取 body 元素</li><li>window，获取窗口（注意窗口不是元素</li><li>document.all，获取所有元素</li></ol><p>在使用 document.all 的时候需要注意，虽然现在所有浏览器都支持这个查询了，但因为历史遗留原因，虽然能获取到值，但转化为布尔值的时候，在非 IE 的浏览器上都返回 false，只有在 IE 上才返回 true</p><h2 id="查祖先"><a href="#查祖先" class="headerlink" title="查祖先"></a>查祖先</h2><p>显然除了根结点，每个结点有且仅有一个父结点</p><p>那么可以通过 <code>div.parentNode</code> 不断向上查找</p><h2 id="查子代"><a href="#查子代" class="headerlink" title="查子代"></a>查子代</h2><p>可以通过 <code>div.childNodes</code> 或 <code>div.children</code> 来查找</p><p>需要注意的是，<code>div.childNodes</code> 返回的是 NodeList，单位类型是 Node，是伪数组，直接 concat 空数组的话不能正常展开，需要用空数组 concat 一个 Array,from 才行</p><p><code>div.children</code> 返回的是 ElementCollection，单位类型均为 Element 的派生类型，与数组操作时注意点同上</p><p>并且，<code>div.childNode</code> 返回值包括文本结点等不直接显示的结点，而 <code>div.children</code> 没有这个问题</p><p>子代中对特定元素也有专有的方法</p><ol><li>查看第一个子结点，div.firstChild</li><li>查看最后一个子结点，div.lastChild</li></ol><h2 id="查兄弟"><a href="#查兄弟" class="headerlink" title="查兄弟"></a>查兄弟</h2><p>可以通过先查父结点，再查父结点的子结点来做到，但要排除自己才是兄弟结点</p><p>同样，兄弟也有专有方法</p><ol><li>查看相邻的上一个兄弟，div.previousSibling</li><li>查看相邻的下一个兄弟，div.nextSibling</li></ol><h1 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h1><p>通常使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement([tagName])</span><br></pre></td></tr></table></figure><p>来创建一个指定标签元素</p><p>或</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createTextNode([string])</span><br></pre></td></tr></table></figure><p>来创建一个包含指定文本的文本结点</p><p>但创建之后的元素或节点，均还在 JS 线程中，必须通过 API 添加到页面上，由渲染线程处理后，才能在页面上显示</p><p>通常通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[parentNode].appendChild([childNode])</span><br></pre></td></tr></table></figure><p>来将指定的结点添加到某个结点中</p><p>关于添加结点，有以下两种特殊情况</p><ol><li><p>同一结点被多次添加到不同结点的子结点列表中</p><p>此时该子结点会出现在最后一次被添加到的位置</p></li><li><p>意图向某结点添加文本</p><p>此时不可以直接 appendChild(string)，必须先将 string 转换成文本结点，或用 innerText、textContent 属性来添加文本</p><p><strong>innerText 是 IE 产物，textContent 是其它浏览器产物，但现在所有浏览器都同时支持两个</strong></p></li></ol><h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>一般有两种方法</p><ol><li><code>[parentNode].removeChild([childNode])</code></li><li><code>[childNode].remove()</code></li></ol><p>对于被从 DOM 树中移除的结点，只要还没丢失对它的引用，就还可以通过 appendChild 再次回到页面上</p><h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>如同前述，对元素的修改包含对属性的修改</p><p>一般分为四种属性</p><ol><li>HTML 标签属性</li><li>CSS 属性</li><li>data 属性</li><li>自定义属性</li></ol><p>不论是何种属性，都可以通过点符号进行 get/set</p><p>但是 JS 中不能使用连接符来访问，所以在使用连接符的地方，要改用驼峰命名法</p><h2 id="HTML-标签属性"><a href="#HTML-标签属性" class="headerlink" title="HTML 标签属性"></a>HTML 标签属性</h2><p>直接使用赋值语句改值即可，注意值必须是字符串</p><p>如 <code>img.width = &#39;200px&#39;</code></p><p>但是有的属性不太一样，比如 a 标签的 href 属性</p><p>如果通过 <code>a.href</code> 来获取，浏览器会自动补全 href 的根路径，最终获取到的字符串是 http/https 开头的</p><p>此时应该通过 <code>a.getAttribute(&#39;href&#39;)</code> 来获取，能保证获取到的字符串不会被浏览器动手脚</p><h2 id="CSS-属性"><a href="#CSS-属性" class="headerlink" title="CSS 属性"></a>CSS 属性</h2><p>有 class 和 style 两种</p><p>对于 class，使用 <code>[node].className=&#39;newClass&#39;</code> 来修改</p><p>或使用 <code>[node].classList.add(&#39;newClass&#39;)</code> 来添加适配的 class</p><p>对于 style，可以直接赋值 style 字符串</p><p>如 <code>div.style=&#39;width:100px; height: 200px&#39;</code></p><p>也可以针对性赋值，如 <code>div.style.width=&#39;100px&#39;</code></p><h2 id="data-属性"><a href="#data-属性" class="headerlink" title="data 属性"></a>data 属性</h2><p>常常可以见到形如 <code>data-*</code> 的属性</p><p>这些属性类似于 style，可以通过统一入口 dataset 来访问</p><p>如属性 <code>data-x-err</code>，可以通过 <code>div.dataset.xErr</code> 来访问</p><h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><p>修改方法与 HTML 属性相同，直接通过点符号访问即可</p><p>但一般不建议采用不是 data 的自定义属性</p><p>因为当目标结点现在在页面中时，对以上三种属性的修改都会直接同步到页面上，但对自定义属性的修改不能同步到页面上</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>每个元素都会有各种事件，此处以 click 事件为例</p><p>要为 click 事件绑定处理函数，可以用如下两种方法</p><ol><li><p><code>div.onclick=()=&gt;{}</code>，此时 div 只能有一个方法，新方法会覆盖旧方法，在冒泡阶段执行</p></li><li><p><code>div.addEventListener(&#39;click&#39;,()=&gt;{},false)</code>，此时 div 有若干个方法，新方法与旧方法都会在 click 事件被触发</p><p>此处的第三个参数默认值 false，表示事件在冒泡阶段触发。如果改为 true 就是在捕获阶段触发</p><p>需要注意的是，IE 只有冒泡阶段，并且事件列表执行顺序是 FIFO，其它非 IE 浏览器则有捕获和冒泡，且执行顺序是 LIFO</p></li></ol><p>不论是如何添加事件，在事件被触发时，都有两个默认参数</p><p>一个是 this，指向事件触发所在的元素</p><p>一个是 event，包含该事件触发时的所有相关信息</p><h2 id="文本内容"><a href="#文本内容" class="headerlink" title="文本内容"></a>文本内容</h2><p>通过 innerText、textContent 属性来添加文本</p><p><strong>innerText 是 IE 产物，textContent 是其它浏览器产物，但现在所有浏览器都同时支持两个</strong></p><h2 id="父子结点关系"><a href="#父子结点关系" class="headerlink" title="父子结点关系"></a>父子结点关系</h2><p>可以通过结点操作或 innerHTML 注入来实现</p><p>例如 <code>div.innerHTML=&#39;&lt;span&gt;233&lt;/span&gt;&#39;</code> 就是向 div 中插入了一个内容为 233 的 span 标签</p><p>注意，此时会覆盖 div 中的所有内容（包括子元素）</p><p>如果想添加新儿子，可以使用 appendChild 方法，不再赘述</p><p>如果想换个新父结点，则只需要利用 appendChild 会出现在最新位置的特点，直接向新父结点插入当前结点即可</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p><a href="https://github.com/Ringoer/Toy/blob/main/37/main.js" target="_blank" rel="noopener">原生 dom 封装</a></p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>既然 DOM API 这么复杂，有没有更方便的方法呢？</p><p>答案是有，典型的例子就是 JQuery 库</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只要是学前端的同学，肯定都听说过 DOM&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
</feed>
