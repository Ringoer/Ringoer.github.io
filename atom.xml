<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ringo&#39;s Coding Life</title>
  
  <subtitle>OI to ACM</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-11T07:02:42.028Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ringoer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Welcome to No. 68 Floating Island</title>
    <link href="http://yoursite.com/uncategorized/mainpage/"/>
    <id>http://yoursite.com/uncategorized/mainpage/</id>
    <published>2332-12-31T16:00:00.000Z</published>
    <updated>2019-03-11T07:02:42.028Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"><b><font size="6">Are You Going To Scarborough Fair ?</font></b></p><br><img src="http://pic.ringoer.com/id63819688.png" alt="id=63819688" title="id=63819688"><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;b&gt;&lt;font size=&quot;6&quot;&gt;Are You Going To Scarborough Fair ?&lt;/font&gt;&lt;/b&gt;&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;http://pic.ringoer.com/id63819688
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>异步回调与Promise</title>
    <link href="http://yoursite.com/frontend/promise/"/>
    <id>http://yoursite.com/frontend/promise/</id>
    <published>2020-12-07T09:41:00.000Z</published>
    <updated>2020-12-13T08:37:54.360Z</updated>
    
    <content type="html"><![CDATA[<p>在 ajax 中，我们提到了 Promise 式封装</p><p>那么什么是 Promise 呢？</p><a id="more"></a><p>首先要来介绍一下什么是异步回调</p><p>我们在计算机网络中学过通信方式一般有三种：全双工、半双工、单工</p><p>最理想的方式当然是全双工</p><h1 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h1><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步也是一种全双工</p><p>简单来说，就是当一个任务发出后，发件人不需要等待执行方的返回结果，而可以先去做其它事情，等待</p><p>比如你加某个人为 qq 好友，发出请求后你就不需要管了，可以自己先去聊天，等到对方同意或拒绝你的好友请求，你才会收到通知，回来处理这件事</p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>那回调又是什么呢？回调其实解决了异步的一个非常重要的问题——我要这个结果做什么用，简单说就是当异步结果返回的时候，该做什么呢</p><p>在上文 qq 好友的例子中，qq 通知你好友请求返回结果了，你根据结果做出的动作就是回调</p><p>比如好友请求通过，你的回调就是找好友聊天</p><p>比如失败，你的回调可能是自我分析是什么情况，也可以是什么都不做</p><p>在浏览器中，就是浏览器的异步请求取回结果的时候，如果是成功，要进行什么处理、给出什么输出呢？失败的话要不要处理、怎么处理这个错误呢？</p><p>举个例子，就是 setTimeout</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'success'</span>)</span><br><span class="line">setTimeout(fn,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>执行 setTimeout 后，将在 1000ms 后执行 fn</p><p>此处的 fn 就是回调函数</p><h2 id="异步和回调的关系"><a href="#异步和回调的关系" class="headerlink" title="异步和回调的关系"></a>异步和回调的关系</h2><p>上文可以看出，回调函数其实就是事件完成后，处理结果的方法</p><p>但其实事件不一定是异步的，也可以是同步的</p><p>即便是同步的函数，也可以使用回调函数，区别只不过是异步任务执行后可以先做别的再收通知，同步任务执行后必须原地等通知罢了</p><p>但是如果一层层回调，会变成什么样呢</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">       setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">           run()</span><br><span class="line">       &#125;,<span class="number">0</span>) </span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>看，是不是随着回调层数的增加，代码逐渐向右突出。。。这也太难看了</p><p>这就是回调地狱</p><p>而为了解决这个问题，提出了 Promise</p><h1 id="Promise-定义"><a href="#Promise-定义" class="headerlink" title="Promise 定义"></a>Promise 定义</h1><p>Promise 是将“生产者代码”和“消费者代码”连接在一起的一个特殊的 JavaScript 对象。</p><p>用我们的类比来说：这就是就像是“订阅列表”。</p><p>“生产者代码”花费它所需的任意长度时间来产出所承诺的结果，而 “promise” 将在它准备好时，将结果向所有订阅了的代码开放。</p><h1 id="Promise-用途"><a href="#Promise-用途" class="headerlink" title="Promise 用途"></a>Promise 用途</h1><p>一开始主要是为了解决回调地狱而产生的</p><p>现在则已经是前端异步处理的统一解决方案</p><h1 id="Promise-用法"><a href="#Promise-用法" class="headerlink" title="Promise 用法"></a>Promise 用法</h1><p>一般在函数中作为函数返回值，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">        resolve(<span class="number">233</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码也可以直接赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">    resolve(<span class="number">233</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先介绍一下，Promise 有以下状态</p><ol><li>pending，Promise 尚未返回结果</li><li>settled，Promise 已经返回结果，但不确定是成功还是失败<ol><li>fulfilled，Promise 已经成功（resolve）返回</li><li>rejected，Promise 已经失败（reject）返回</li></ol></li></ol><p>可见，Promise 的构造函数要求传入一个包含两个参数的 executor（可执行代码段），两个参数分别是 Promise 给出的两个函数，分别指示 resolve 和 reject 调用的函数</p><p>当然两个参数也可以叫别的名字，只要顺序不变就没有影响，但是一般都是叫 resolve 和 reject</p><p>这段 executor 是立即执行的，但是对结果的处理是异步的，直到 settled 之前，这个 Promise 都不算结束</p><p>即使在 executor 中，半路上就 resolve/reject 了，executor 的代码段还是会完整执行，不会中断</p><p>那么怎么处理 Promise 的返回结果呢？</p><h1 id="Promise-方法"><a href="#Promise-方法" class="headerlink" title="Promise 方法"></a>Promise 方法</h1><p>Promise 的 prototype 上有 3 个重要的回调方法</p><ol><li>then</li><li>catch</li><li>finally</li></ol><p>3 个方法都支持链式调用</p><h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><p>then 方法的函数声明伪代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123; <span class="comment">/* handle a successful result */</span> &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="comment">/* handle an error */</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以接受两个参数，分别表示对于 fulfilled 和 rejected 状态的 Promise 结果的处理函数</p><p>第一个函数接受一个参数，表示成功的结果</p><p>第二个函数接受一个参数，表示失败的原因</p><p>其中 fulfilled 结果处理函数是必要的，rejected 处理函数可以不写出，但如果 Promise 被 reject，而没有其它地方处理这个 error 的话，会直接报错，停止解释器</p><p>上例中的代码，加上 then 回调后，变为如下模样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">    resolve(<span class="number">233</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// expected output: 233</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>then 可以多级传递，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">    resolve(<span class="number">233</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// expected output: 233</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">114514</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// expected output: 114514</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>链式调用中，结果会沿着链传递</p><p>但是分开调用是不对的，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">    resolve(<span class="number">233</span>)</span><br><span class="line">&#125;)</span><br><span class="line">task.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// expected output: 233</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">114514</span></span><br><span class="line">&#125;)</span><br><span class="line">task.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// expected output: 233</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>分开调用，结果不会互相传递</p><p>then 中除了被动出错，也可以使用 throw 子句主动抛出错误</p><h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><p>上例中使用 catch 的话，一般可以写成以下模样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123; <span class="comment">// executor</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">    reject(<span class="number">233</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123; <span class="comment">// then</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果在 Promise 的 executor 或者 then 中出错了，都可以用 catch 捕获错误，因为 catch 在他们的下游</p><p>此时如果是 executor 出错，then 会被跳过，沿着 Promise 链往下寻找 catch 直到找到第一个 catch 为止</p><p>catch 既然支持链式调用，那么 catch 自然也可以再抛出</p><p>比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123; <span class="comment">// executor</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 正在运行'</span>)</span><br><span class="line">    reject(<span class="string">'2323'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123; <span class="comment">// then</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err!==<span class="string">'233'</span>) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err 233 is catched'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意，此处要使用 throw 子句来抛出，不能是 return</p><p>如果是 return，接下来的结果就要用 then 来接收</p><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>上例中使用 finally 的话，一般可以写成以下模样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123; <span class="comment">// executor</span></span><br><span class="line">    resolve(<span class="number">233</span>)</span><br><span class="line">&#125;).finally(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 开始运行'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// expected output: 233</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>显然，finally 不一定要写在最后，一般只是用来做阶段性封口而已</p><p>比如此处，在 executor 执行完毕后，不论 executor 是否出错，都会执行 finally，告诉用户 promise 开始了</p><p>然后，不论是 resolve 还是 reject，结果都会越过 finally 传递到可以处理这个结果的回调</p><hr><p>以上就是 Promise 的基本用法</p><p>现在来深究一下 Promise 这么个好东</p><h1 id="Promise-手写"><a href="#Promise-手写" class="headerlink" title="Promise 手写"></a>Promise 手写</h1><p>面试必考的手写 Promise 部分，你会多少呢？</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>首先先实现基本的 Promise 功能——resolve 和 reject</p><p>容易想到以下基本形</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">    executor(resolve,reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 resolve 和 reject 从哪里来？显然要由 Promise 提供</p><p>这两个函数还兼顾了取结果和改状态的效果，所以得到如下形状</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        executor(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="keyword">this</span>.reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">this</span>.result = result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">this</span>.result = err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改数据的时候，要注意不能随便覆盖结果</p><p>注意，我们要在 resolve 和 reject 中使用访问 this 的 status 和 result，所以这两个函数</p><ol><li>必须有自己的 this，不能是箭头函数</li><li>必须指向当前操作的对象，所以要使用 bind 绑定 this</li></ol><p>这样 Promise 最基本的功能就实现了，接下来实现最重要的功能 then</p><h2 id="Promise-then"><a href="#Promise-then" class="headerlink" title="Promise.then"></a>Promise.then</h2><p>容易得到以下形状</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">success,fail</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'fulfilled'</span>) <span class="keyword">this</span>.result = success(<span class="keyword">this</span>.result)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">this</span>.result = fail(<span class="keyword">this</span>.result)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这时候我们发现，这个 then 只能执行同步的链式调用</p><p>那怎么异步调用呢？答案就是发布订阅模式</p><p>可以得到以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.onfulfilled = []</span><br><span class="line">    <span class="keyword">this</span>.onrejected = [] <span class="comment">// 添加两个事件组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        executor(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="keyword">this</span>.reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">this</span>.result = result</span><br><span class="line">        <span class="keyword">this</span>.onfulfilled.map(<span class="function"><span class="params">event</span>=&gt;</span>event.call(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">this</span>.result = err</span><br><span class="line">        <span class="keyword">this</span>.onrejected.map(<span class="function"><span class="params">event</span>=&gt;</span>event.call(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">success,fail</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.onfulfilled.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = success(<span class="keyword">this</span>.result)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">this</span>.onrejected.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = fail(<span class="keyword">this</span>.result)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span>) <span class="keyword">this</span>.result = success(<span class="keyword">this</span>.result)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.result = fail(<span class="keyword">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p=<span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>resolve(<span class="number">233</span>),<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res++)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>可以得到以下结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line"><span class="number">233</span></span><br><span class="line"><span class="number">666</span></span><br></pre></td></tr></table></figure><p>现在 then 也可以支持异步返回了！但是 catch 似乎还没实现，不过我水平不够了，到此为止了2333</p><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>Promise.all 的核心要义就是传入多个 Promise，然后按顺序返回所有结果</p><p>容易想到以下形状</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">P.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> n = <span class="number">0</span>, len = promises.length</span><br><span class="line">            <span class="keyword">let</span> ans = []</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> promises)&#123;</span><br><span class="line">                P.resolve(promises[i])</span><br><span class="line">                .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                    ans[i] = res</span><br><span class="line">                    n++</span><br><span class="line">                    <span class="keyword">if</span>(n === len)&#123;</span><br><span class="line">                        resolve(ans)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们还需要一个 P.resolve 来得到一个新的 P</p><p>所以还要写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P.resolve = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(data <span class="keyword">instanceof</span> P)&#123;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>resolve(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以下测试例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = P.resolve(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> P(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">100</span>, <span class="string">'foo'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">P.all([promise1, promise2, promise3]).then(<span class="function"><span class="keyword">function</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可得结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, &quot;foo&quot;, 42]</span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><p>Promise.race 的核心要义就是传入多个 Promise，然后返回第一个决议的结果，无论是成功还是失败</p><p>其实把 all 的计数器去掉就可以了</p><p>容易想到以下形状</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">P.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> ans = <span class="literal">undefined</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> promises)&#123;</span><br><span class="line">                P.resolve(promises[i])</span><br><span class="line">                .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                    ans = res</span><br><span class="line">                    resolve(ans)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以下测试例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> P(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">500</span>, <span class="string">'one'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> P(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">100</span>, <span class="string">'two'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">P.race([promise1, promise2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可得结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two</span><br></pre></td></tr></table></figure><h2 id="完整的-Promise"><a href="#完整的-Promise" class="headerlink" title="完整的 Promise"></a>完整的 Promise</h2><p>总结一下，可以得到如下的手写 Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.onfulfilled = []</span><br><span class="line">    <span class="keyword">this</span>.onrejected = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        executor(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="keyword">this</span>.reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">this</span>.result = result</span><br><span class="line">        <span class="keyword">this</span>.onfulfilled.map(<span class="function"><span class="params">event</span>=&gt;</span>event.call(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">this</span>.result = err</span><br><span class="line">        <span class="keyword">this</span>.onrejected.map(<span class="function"><span class="params">event</span>=&gt;</span>event.call(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">success,fail</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.onfulfilled.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = success(<span class="keyword">this</span>.result)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">this</span>.onrejected.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = fail(<span class="keyword">this</span>.result)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span>) <span class="keyword">this</span>.result = success(<span class="keyword">this</span>.result)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.result = fail(<span class="keyword">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">P.resolve = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(data <span class="keyword">instanceof</span> P)&#123;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>resolve(data))</span><br><span class="line">&#125;</span><br><span class="line">P.reject = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(data <span class="keyword">instanceof</span> P)&#123;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>reject(data))</span><br><span class="line">&#125;</span><br><span class="line">P.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> n = <span class="number">0</span>, len = promises.length</span><br><span class="line">            <span class="keyword">let</span> ans = []</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> promises)&#123;</span><br><span class="line">                P.resolve(promises[i])</span><br><span class="line">                .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                    ans[i] = res</span><br><span class="line">                    n++</span><br><span class="line">                    <span class="keyword">if</span>(n === len)&#123;</span><br><span class="line">                        resolve(ans)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">P.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> ans = <span class="literal">undefined</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> promises)&#123;</span><br><span class="line">                P.resolve(promises[i])</span><br><span class="line">                .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                    ans = res</span><br><span class="line">                    resolve(ans)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.javascript.info/promise-basics" target="_blank" rel="noopener">Promise</a></p><p><a href="https://www.jianshu.com/p/90b6280dd1b6" target="_blank" rel="noopener">手写Promise.all和Promise.race</a></p><hr><p>谢谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 ajax 中，我们提到了 Promise 式封装&lt;/p&gt;
&lt;p&gt;那么什么是 Promise 呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>事件循环</title>
    <link href="http://yoursite.com/frontend/event-loop/"/>
    <id>http://yoursite.com/frontend/event-loop/</id>
    <published>2020-12-07T09:39:00.000Z</published>
    <updated>2020-12-12T11:35:46.370Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常看到 setTimeout 中延迟设置为 0，但真的是 0 延迟吗？</p><a id="more"></a><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>这涉及到 javascript 的事件循环机制</p><p>众所周知，javascript 是单线程的，但是却支持异步，和 CPU 非常相似</p><p>对照 CPU 的进程调度，可以发现任务是排队执行的，并且有不同的优先级队列</p><p>但是我们可以发现，以下输出不是按顺序的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'then1'</span>)).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'then4'</span>))</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'then2'</span>)).then(<span class="function"><span class="params">res</span>=&gt;</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)&#125;,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'promise'</span>)&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'then3'</span>))</span><br></pre></td></tr></table></figure><p>实际运行一下，得到输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">then1</span><br><span class="line">then2</span><br><span class="line">then3</span><br><span class="line">then4</span><br><span class="line">setTimeout1</span><br><span class="line">setTimeout2</span><br></pre></td></tr></table></figure><p>为什么会这样？？</p><p>这就涉及到宏任务和微任务的概念</p><h1 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h1><p>上文中提到单线程，任务队列，事件循环</p><p>之所以称之为 事件循环，是因为它经常按照类似如下的方式来被实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</span><br><span class="line">  queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个</p><p>任务队列又分为 macro-task（宏任务）与 micro-task（微任务），在最新标准中，它们被分别称为 task 和 jobs</p><p>用操作系统说法，就是进程和线程的区别</p><p>上例可以做如图表示</p><p><img src="https://pic.ringoer.com/event-loop-0.png" alt=""></p><p>因为 new Promise 中 settled 之前的函数都是同步进行的，所以先打印 promise</p><p>当这一轮主线程执行完毕的时候，变为如图情况</p><p><img src="https://pic.ringoer.com/event-loop-1.png" alt=""></p><p>此时，引擎发现，虽然当前主线程为空，但微任务队列不为空，所以当前宏任务还不算结束</p><p>于是引擎将微任务队列的任务都塞进主线程，这个过程就是 <strong>开启下一次事件循环</strong></p><p><img src="https://pic.ringoer.com/event-loop-2.png" alt=""></p><p>再次执行完毕后，变为如图情况</p><p><img src="https://pic.ringoer.com/event-loop-3.png" alt=""></p><p>此时微任务队列依然不为空，再次优先执行微任务队列中的任务</p><p>执行完后变为如图情况</p><p><img src="https://pic.ringoer.com/event-loop-4.png" alt=""></p><p>微任务队列终于空了！主线程开始取宏任务队列中的队首任务，变为如图情况</p><p><img src="https://pic.ringoer.com/event-loop-5.png" alt=""></p><p>执行完毕后，发现微任务队列还是空的，于是再取宏任务，再空，终于所有任务都执行完了！</p><p>这就是 JS 事件调度的过程，可见 setTimeout(fn,0) 并不是真正的 0 延迟执行，而是“尽可能快”</p><p>显然代码可以分为三种</p><ol><li>立即执行的代码</li><li>微任务</li><li>宏任务</li></ol><p>则事件循环的实现，大致有如下伪代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!mainQueue.empty()) &#123;</span><br><span class="line">        solve(mainQueue.front());</span><br><span class="line">        mainQueue.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(microQueue.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!macroQueue.empty())&#123;</span><br><span class="line">            mainQueue.push(macroQueue.front());</span><br><span class="line">            macroQueue.pop();</span><br><span class="line">            render.run();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!microQueue.empty())&#123;</span><br><span class="line">            mainQueue.push(microQueue.front());</span><br><span class="line">            microQueue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文字描述如下</p><ul><li>处理主线程中所有任务</li><li>若微任务队列为空<ul><li>若宏任务队列不为空，则取宏任务队列的队首到主线程中，并在开启下一个事件循环前，进行页面渲染</li></ul></li><li>若微任务队列不为空，则将微任务队列中所有任务加入主线程中</li></ul><p>那么哪些是微任务，哪些是宏任务呢？</p><p>一般有如下认定与支持</p><table><thead><tr><th>宏任务</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td>I/O</td><td>1</td><td>1</td></tr><tr><td>setTimeout</td><td>1</td><td>1</td></tr><tr><td>setInterval</td><td>1</td><td>1</td></tr><tr><td>setImmediate</td><td>0</td><td>1</td></tr><tr><td>requestAnimationFrame</td><td>1</td><td>0</td></tr><tr><td>script 代码块</td><td>1</td><td>0</td></tr></tbody></table><table><thead><tr><th>微任务</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td>Promise.then/catch/finally</td><td>1</td><td>1</td></tr><tr><td>process.nextTick</td><td>0</td><td>1</td></tr><tr><td>MutationObserver</td><td>1</td><td>0</td></tr></tbody></table><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/weixin_30871701/article/details/97270307" target="_blank" rel="noopener">JavaScript的事件队列(Event Queue)—宏任务和微任务</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">并发模型与事件循环</a></p><hr><p>谢谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常看到 setTimeout 中延迟设置为 0，但真的是 0 延迟吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>原生 ajax 详解</title>
    <link href="http://yoursite.com/frontend/ajax/"/>
    <id>http://yoursite.com/frontend/ajax/</id>
    <published>2020-12-06T15:01:00.000Z</published>
    <updated>2020-12-12T05:03:15.454Z</updated>
    
    <content type="html"><![CDATA[<p>做过前后端分离的同学，肯定都知道 ajax 这个异步通信方法</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>首先肯定是要知道什么是 ajax，毕竟不能保证每个读这篇文章的人都是有前后端分离经验的人（</p><p>Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><p>说这么复杂，其实就是一种前端主动向后端发送 HTTP 请求的技术</p><h1 id="原生写法"><a href="#原生写法" class="headerlink" title="原生写法"></a>原生写法</h1><p>通过 JS 库 XMLHttpRequest 实现</p><p>一般写法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'GET'</span>,<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readystate === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure><p>接下来逐条解释</p><h2 id="创建请求"><a href="#创建请求" class="headerlink" title="创建请求"></a>创建请求</h2><p>通过 new XMLHttpRequest() 可以创建一个请求</p><h2 id="设置请求方法和路径"><a href="#设置请求方法和路径" class="headerlink" title="设置请求方法和路径"></a>设置请求方法和路径</h2><p>通过 xhr.open 方法可以设置请求方法和请求路径</p><p>通常 open 方法一般接受两个参数</p><ol><li>method，表示 HTTP 动词，默认支持 ‘GET’ 或 ‘POST’，大小写没有影响，但一般是大写</li><li>url，表示请求的地址，本例中请求百度首页</li></ol><p>请求默认是异步的，但是当然还可以设置请求为同步，但是严重影响用户体验，故本文不介绍</p><h2 id="请求状态"><a href="#请求状态" class="headerlink" title="请求状态"></a>请求状态</h2><p>一般指 xhr.readystate 和 xhr.status</p><h3 id="readystate"><a href="#readystate" class="headerlink" title="readystate"></a>readystate</h3><p>xhr 一般有 5 个 readystate，含义分别如下</p><table><thead><tr><th>readystate</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>请求被创建</td></tr><tr><td>1</td><td>请求被 open</td></tr><tr><td>2</td><td>请求已经设置好回调，等待发送</td></tr><tr><td>3</td><td>请求已经被 send，等待响应</td></tr><tr><td>4</td><td>请求已经收到响应（不一定是成功）</td></tr></tbody></table><p>因为 readystate === 4 不一定代表成功，所以还引入了第二个属性</p><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>表示请求返回的响应的 HTTP 状态码</p><p>一般 2 开头的表示成功，此处为简单起见直接取 200 来判断</p><h2 id="设置回调"><a href="#设置回调" class="headerlink" title="设置回调"></a>设置回调</h2><p>通过 readystatechange 事件来监听 readystate 的状态以回调</p><p>当 readystate 变为 4 时，会向回调函数中传入一个参数作为结果</p><p>如果成功，则是取回的值，如果失败，则多半没有内容，具体的可以查看 Chrome Network 中的 Response</p><p>所以，我们通过 xhr.onreadystatechange = 包含一个参数的函数，来获取响应的值，并在 readystate === 4 &amp;&amp; status === 200 ——响应成功时，打印取回的值</p><p>注意，设置回调函数要先于发送请求，否则请求异常</p><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>当必要的设置都完成后，就可以发送请求了</p><p>可以通过 xhr.send() 方法来发送请求</p><p>send 方法接受一个可选参数，表示附在请求 body 中的内容，一般是 POST 请求才使用，GET 请求请直接使用拼接 URL</p><h2 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h2><p>当然，还有 abort 方法取消请求、setRequestHeader 方法设置请求头等，此处不介绍了，详询 mdn</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>初级封装就是把上文的代码封装成一个 ajax 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">method,url,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.open(method,url)</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readystate === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">            callback(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send()</span><br><span class="line">&#125;</span><br><span class="line">ajax(<span class="string">'GET'</span>,<span class="string">'https://www.baidu.com/'</span>,<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><p>高级一点的就是用 Promise 封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">method,url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(method,url)</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readystate === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(<span class="string">'GET'</span>,<span class="string">'https://www.baidu.com/'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>再高级的我也不会了，就这样吧2333</p><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>现在只有练习和面试的时候会手写原生 ajax 了，正式开发中都是使用基于 ajax 原理的库 axios</p><p>axios 的使用方法与上文中的 Promise 封装相似，详询 axios 中文网，或各个框架的本地化 axios 文档</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做过前后端分离的同学，肯定都知道 ajax 这个异步通信方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>DOM 事件机制</title>
    <link href="http://yoursite.com/frontend/dom-event/"/>
    <id>http://yoursite.com/frontend/dom-event/</id>
    <published>2020-12-05T12:45:00.000Z</published>
    <updated>2020-12-12T14:33:18.900Z</updated>
    
    <content type="html"><![CDATA[<p>弱弱地冒一个泡</p><a id="more"></a><p>经常听到冒泡捕获，那到底是什么东西呢？</p><h1 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h1><p>首先就要介绍一下 W3C DOM 事件模型</p><p>事件总体上分为三个阶段</p><ol><li>捕获阶段，事件从父到子向下传递</li><li>目标阶段，事件传递到达发生事件的目标点</li><li>冒泡阶段，事件从子到父向上传递</li></ol><p>不论是什么事件，没有特殊设置的情况下，都会按顺序经历这三个阶段</p><p>除非该事件被取消冒泡，才会在取消冒泡之后停止传递</p><p>前两个阶段不能停止传递</p><p>通过 on 赋值可以为元素绑定监听器，此时监听器一定是在事件冒泡阶段发生，且后赋值的监听器会覆盖之前的监听器</p><p>例如 <code>button.onclick=()=&gt;{}</code></p><p>通过 addEventListener(eventName, listener, useCapture, priority, useWeakReference) 可以设置监听器是在事件的冒泡阶段还是捕获阶段发生，该方式可以为同一个元素的同一个事件设置多个监听</p><p>useCapture 默认值是 false，表示监听器在事件冒泡阶段发生，反之当为 true 时即表示在捕获阶段发生</p><p>priority 默认值是 0，表示所有同级的监听器按注册顺序进行。可以为个别监听器设置更高的优先级，优先级高的会在该阶段先执行，同优先级的依然按注册顺序进行</p><p>useWeakReference 默认值是 false，表示设置监听器为强引用，使得监听器不被垃圾回收，反之 true 则是允许回收</p><p>当要取消监听器、或要重新设定优先级时，可以使用 removeEventListener() 来取消监听器，之后再重新设定</p><p>每当事件触发一个监听器的时候，都会向监听器内传入两个默认参数</p><p>一个是 this，表示事件现在所处的元素</p><p>一个是 event，包含事件的完整信息</p><h1 id="target-与-currentTarget"><a href="#target-与-currentTarget" class="headerlink" title="target 与 currentTarget"></a>target 与 currentTarget</h1><p>通过在监听器中打印 event，可以发现两件事</p><ol><li>target != currentTarget</li><li>如果先保存 event，事件结束后再打印，则会发现 target 变成了 null</li></ol><p>对于第一点，target 是事件发生的最小元素，也就是唯一有目标阶段的元素</p><p>currentTarget 则是事件现在所处的位置，是传入监听器的 this</p><p>对于第二点，则涉及到事件消亡的知识，篇幅过大，此处不介绍了</p><h1 id="target-元素-事件先后"><a href="#target-元素-事件先后" class="headerlink" title="target 元素 事件先后"></a>target 元素 事件先后</h1><p>刚才说到 target 元素是唯一有目标阶段的元素，那么什么是目标阶段？</p><p>实际上，对于 target 元素来说，目标阶段就是捕获冒泡连续发生，不像事件传递路径上别的元素是分开发生的</p><ul><li>哦哦，那我懂了，所以对 target 元素来说，监听器也是按照设置好的捕获冒泡顺序执行的吧</li><li>不！</li></ul><p>此时监听器不再区分捕获和冒泡，统一按照设置顺序发生</p><h1 id="取消冒泡"><a href="#取消冒泡" class="headerlink" title="取消冒泡"></a>取消冒泡</h1><p>那有时候我想到此为止，不想打扰父级元素，怎么办呢？</p><p>可以在需要中断的元素的冒泡阶段的监听器中，执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.propagetion()</span><br></pre></td></tr></table></figure><p>此时就可以阻止事件继续冒泡</p><h1 id="默认动作"><a href="#默认动作" class="headerlink" title="默认动作"></a>默认动作</h1><p>既然冒泡可以阻止，那默认的事件能不能阻止呢？比如我现在有个 a 标签，想做单页面应用的 tab 页跳转，要是按照默认的，可就跳到新页面去了</p><p>答案是可以！</p><p>在事件中执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.preventDefault()</span><br></pre></td></tr></table></figure><p>就可以阻止默认动作的发生了！</p><h1 id="禁用滚动"><a href="#禁用滚动" class="headerlink" title="禁用滚动"></a>禁用滚动</h1><p>奇怪，说好的阻止默认动作，怎么我在滚动条上不能 prevent，你骗我！</p><p>等下等下，你真的找准是什么东西产生了滚动条了吗？</p><p>有时候你看着是你的元素产生了滚动条，但说不定是 body 产生的！</p><p>找准了之后，我们来禁用滚动条吧——毕竟滚动条其实只是 CSS 产生的东西</p><p>禁用滚动一般分两种：</p><ol><li>看不见滚动条</li><li>看得见滚动条</li></ol><p>对于第一种，其实只需要设置 overflow: hidden 就可以实现了</p><p>对于第二种，比较复杂一些</p><p>首先能看见滚动条，说明 overflow 至少是 auto，甚至是 scroll</p><p>这时候通过划拉滚动条，或者鼠标滚轮，甚至是触屏上的手指，都可以让页面滚动</p><p>这种时候就要分三部分禁止</p><ol><li>禁止滚动条，通过 <code>#div.scrollTop = 0</code>，即可让滚动条锁定在顶端</li><li>禁止鼠标滚轮，通过 <code>#div.onwheel=event=&gt;{event.preventDefault()}</code>，即可阻止滚轮</li><li>禁止触控，通过 <code>#div.ontouchstart=event=&gt;{event.preventDefault()}</code>，即可阻止触控</li></ol><p>既然能在看得见滚动条的情况下禁止滚动，那能不能在看不见滚动条的情况下允许滚动呢？</p><p>于是就又延伸出一个需求。。。</p><p>当然也很简单，通过一个尚未加入标准的 CSS 伪元素即可实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div</span><span class="selector-pseudo">::-webkit-scrollBar</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可实现在看不见滚动条的情况下允许滚动</p><h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><p>那万一我玩得不开心，想自定义一个事件，行不行？</p><p>可以！</p><p>通过以下方法即可创建一个自定义事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> CustomEvent(eventName, &#123; <span class="attr">detail</span>: config &#125;);</span><br></pre></td></tr></table></figure><p>其中第一个参数表示你的事件名称，第二个参数是一个包含 detail 属性的对象</p><p>关于事件的初始化配置，都写在 detail 中</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config=&#123;</span><br><span class="line">    bubbles: <span class="literal">false</span>,</span><br><span class="line">    cancelable: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'test'</span>, &#123; <span class="attr">detail</span>: config &#125;);</span><br></pre></td></tr></table></figure><p>即可创建一个名为 test 的事件，并指示该事件不进行冒泡传递，且不可以被阻止默认动作</p><p>创建完成事件后，还要分发事件，才可以让元素上的监听器正常工作，不然你让浏览器怎么触发你设置的事件？2333</p><p>要分发事件，首先要选中元素，然后触发他身上的事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'#div'</span>)</span><br><span class="line">div.addEventListener(<span class="string">'test'</span>,<span class="built_in">console</span>.log(<span class="number">233</span>))</span><br><span class="line">div.dispatchEvent(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure><p>通过以上代码，就可以为 id 为 div 的元素绑定一个 test 事件的监听器，当事件触发时打印 233</p><p>然后向这个元素分发事件，触发对应的监听器</p><h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>但是有时候，要为很多相似元素各自绑定相同的监听器</p><p>比如一张 10x10 的表格，难道为每个 td 都绑定一个监听器吗？且不说要写 100 行代码，光是 100 个监听器，就卡爆了！</p><p>那么这时候，就需要我们的事件委托</p><p>事件委托就是把大量相似子项的相似逻辑的监听器，全部取消，然后利用事件冒泡传递的特性，把监听器绑定在父项上，使得监听器既能获得事件发生的确切位置，又大幅简化了代码，优化了性能</p><p>比如开头 10x10 表格的例子，就可以将监听器绑定在 table 标签上，借助冒泡传递，获取事件的 target，来处理对应子项的逻辑</p><p>显然，这样是很节省内存的，而且即便后续为表格添加项目，依然可以通过 target 得到事件发生的位置，是非常灵活的</p><p>所以，事件委托有以下三大优点</p><ol><li>节省内存，多个监听器变为 1 个监听器</li><li>动态监听，可以监听未来添加的项目</li><li>封装，大幅简化代码逻辑，易于调试</li></ol><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;弱弱地冒一个泡&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JQuery</title>
    <link href="http://yoursite.com/frontend/jquery/"/>
    <id>http://yoursite.com/frontend/jquery/</id>
    <published>2020-12-05T12:43:00.000Z</published>
    <updated>2020-12-10T15:04:14.928Z</updated>
    
    <content type="html"><![CDATA[<p>DOM API 好难用，我要用 JQ！</p><a id="more"></a><h1 id="什么是-JQuery"><a href="#什么是-JQuery" class="headerlink" title="什么是 JQuery"></a>什么是 JQuery</h1><p>众所周知这 DOM 原生 API 长得 1p，语义还七扭八歪的</p><p>于是就诞生了 JQuery ！</p><p>好吧好吧，简单说就是，这是一个封装了 DOM 操作的库，使用它比直接使用原生 DOM API 更方便，更好读</p><p>那么，为了形成对比，采用和 DOM 那篇一样的结构</p><h1 id="Retrieve"><a href="#Retrieve" class="headerlink" title="Retrieve"></a>Retrieve</h1><p>既然 CSS 选择器这么好用，JQ 怎么能不吸收一下呢</p><p>于是 JQ 采用 <code>$(selector)</code> 来选择元素，返回选择器匹配上的所有元素</p><h1 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h1><p>分为从已有创建和重新创建两种</p><p>对于从已有创建，只需要选中元素后，调用 clone 方法，就可以获得一个拷贝了原元素的新元素</p><p>对于重新创建，只需要直接调用 JQ 构造函数 $，然后传入新元素的 HTML 表示即可</p><h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>分为删除元素和删除内容</p><p>使用 remove 或 detach 方法即可删除元素，但前者不保留元素，后者保留，便于重新插入文档</p><p>使用 empty 方法即可清空元素文本</p><h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>分为</p><ol><li>对 JQ 对象的更新</li><li>对元素的更新</li><li>对元素属性的更新</li><li>对事件的更新</li></ol><h2 id="对-JQ-对象的更新"><a href="#对-JQ-对象的更新" class="headerlink" title="对 JQ 对象的更新"></a>对 JQ 对象的更新</h2><p>可以采用 JQ 专属过滤器来改变结果集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).has(<span class="string">'p'</span>); <span class="comment">// 选择包含p元素的div元素</span></span><br><span class="line">$(<span class="string">'div'</span>).not(<span class="string">'.myClass'</span>); <span class="comment">//选择class不等于myClass的div元素</span></span><br><span class="line">$(<span class="string">'div'</span>).filter(<span class="string">'.myClass'</span>); <span class="comment">//选择class等于myClass的div元素</span></span><br><span class="line">$(<span class="string">'div'</span>).first(); <span class="comment">//选择第1个div元素</span></span><br><span class="line">$(<span class="string">'div'</span>).eq(<span class="number">5</span>); <span class="comment">//选择第6个div元素</span></span><br><span class="line">$(<span class="string">'div'</span>).next(<span class="string">'p'</span>); <span class="comment">//选择div元素后面的第一个p元素</span></span><br><span class="line">$(<span class="string">'div'</span>).parent(); <span class="comment">//选择div元素的父元素</span></span><br><span class="line">$(<span class="string">'div'</span>).closest(<span class="string">'form'</span>); <span class="comment">//选择离div最近的那个form父元素</span></span><br><span class="line">$(<span class="string">'div'</span>).children(); <span class="comment">//选择div的所有子元素</span></span><br><span class="line">$(<span class="string">'div'</span>).siblings(); <span class="comment">//选择div的同级元素</span></span><br><span class="line">$(<span class="string">'div'</span>).siblings().end(); <span class="comment">//返回上一次结果集，此处等效于选中 div</span></span><br></pre></td></tr></table></figure><h2 id="对元素的更新"><a href="#对元素的更新" class="headerlink" title="对元素的更新"></a>对元素的更新</h2><p>其实是指元素在 DOM 树上的位置更新</p><p>一共有 4 对方法</p><table><thead><tr><th>方法名1</th><th>方法名2</th><th>描述</th></tr></thead><tbody><tr><td>insertAfter</td><td>after</td><td>为现有元素插入一个相邻弟弟</td></tr><tr><td>insertBefore</td><td>before</td><td>为现有元素插入一个相邻哥哥</td></tr><tr><td>appendTo</td><td>append</td><td>为现有元素插入一个最小的儿子</td></tr><tr><td>prependTo</td><td>prepend</td><td>为现有元素插入一个最大的儿子</td></tr></tbody></table><p>看起来没什么差别，其实还是有的</p><p>比如第一对方法，调用例如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).insertAfter($(<span class="string">'p'</span>));</span><br><span class="line">$(<span class="string">'p'</span>).after($(<span class="string">'div'</span>));</span><br></pre></td></tr></table></figure><p>显然，虽然都是将 div 元素插入到 p 元素的后面，但前者返回的是对 div 操作的 JQ 元素，后者则是对 p 操作的 JQ 元素</p><p>实际情况下根据需要选择</p><h2 id="对元素属性的更新"><a href="#对元素属性的更新" class="headerlink" title="对元素属性的更新"></a>对元素属性的更新</h2><p>JQ 使用同名方法来作为同一个目标的 getter/setter</p><p>对于 get，如果结果集包含多个元素，则返回第一个元素的值（text 方法例外</p><p>对于 set，不论结果集包含多少元素，对于每个元素都会适配这次 set</p><p>通常有如下 getter/setter 来实现对元素属性的更新</p><table><thead><tr><th>方法</th><th>结果集目标</th><th>描述</th></tr></thead><tbody><tr><td>html()</td><td>第一个元素</td><td>get html 内容</td></tr><tr><td>html(‘233’)</td><td>所有元素</td><td>set html 内容为 ‘233’</td></tr><tr><td>text()</td><td>所有元素</td><td>get text 内容</td></tr><tr><td>text(‘233’)</td><td>所有元素</td><td>set text 内容为 ‘233’</td></tr><tr><td>attr(‘class’)</td><td>第一个元素</td><td>get class</td></tr><tr><td>attr(‘class’,’red’)</td><td>所有元素</td><td>set class 为 red</td></tr><tr><td>width()</td><td>第一个元素</td><td>get width</td></tr><tr><td>width(‘100px’)</td><td>所有元素</td><td>set width 为 100px</td></tr><tr><td>height()</td><td>第一个元素</td><td>get height</td></tr><tr><td>height(‘100px’)</td><td>所有元素</td><td>set height 为 100px</td></tr><tr><td>val()</td><td>第一个元素</td><td>get 某个 input 元素的值</td></tr><tr><td>val(‘233’)</td><td>所有元素</td><td>set 某个 input 元素的值为 ‘233’</td></tr></tbody></table><h2 id="对事件的更新"><a href="#对事件的更新" class="headerlink" title="对事件的更新"></a>对事件的更新</h2><p>直接使用对应事件名作为方法名进行调用</p><p>几乎所有事件都支持</p><p>调用例如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'button'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该调用等效于 set，会更新 JQ 对象结果集中的所有元素，下略</p><p>可以使用 bind 方法来指定多个事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'button'</span>).bind(</span><br><span class="line">    <span class="string">'click change'</span>, <span class="comment">//同时绑定click和change事件</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述绑定方法会重复被触发，但也可以使用 one 方法来设定只触发一次的事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'button'</span>).one(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不想要的事件，也可以用 unbind 方法来解除绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'button'</span>).unbind(<span class="string">'click'</span>)</span><br></pre></td></tr></table></figure><p>当事件触发时，会默认向方法内传入一个参数 event，表示事件发生时的相关信息</p><p>在传入的函数中，如果该函数不是箭头函数，则还可以用 this 来访问触发了该事件的元素</p><p>事件触发除了页面上的操作，还可以用事件函数或 trigger 方法手动触发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'button'</span>).click()</span><br><span class="line">$(<span class="string">'button'</span>).trigger(<span class="string">'click'</span>)</span><br></pre></td></tr></table></figure><h1 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h1><p>除了增删改查，JQ 还提供了一些绑定在 $ 上的方法，不需要选中元素即可调用</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>$.trim()</td><td>去除字符串两端的空格。</td></tr><tr><td>$.each()</td><td>遍历一个数组或对象。</td></tr><tr><td>$.inArray()</td><td>返回一个值在数组中的索引位置。如果该值不在数组中，则返回-1。</td></tr><tr><td>$.grep()</td><td>返回数组中符合某种标准的元素。</td></tr><tr><td>$.extend()</td><td>将多个对象，合并到第一个对象。</td></tr><tr><td>$.makeArray()</td><td>将对象转化为数组。</td></tr><tr><td>$.type()</td><td>判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）。</td></tr><tr><td>$.isArray()</td><td>判断某个参数是否为数组。</td></tr><tr><td>$.isEmptyObject()</td><td>判断某个对象是否为空（不含有任何属性）。</td></tr><tr><td>$.isFunction()</td><td>判断某个参数是否为函数。</td></tr><tr><td>$.isPlainObject()</td><td>判断某个参数是否为用”{}”或”new</td></tr><tr><td>$.support()</td><td>判断浏览器是否支持某个特性。</td></tr></tbody></table><h1 id="特殊效果"><a href="#特殊效果" class="headerlink" title="特殊效果"></a>特殊效果</h1><p>常用的特殊效果方法如下</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>fadeIn()</td><td>淡入</td></tr><tr><td>fadeOut()</td><td>淡出</td></tr><tr><td>fadeTo()</td><td>调整透明度</td></tr><tr><td>hide()</td><td>隐藏元素</td></tr><tr><td>show()</td><td>显示元素</td></tr><tr><td>slideDown()</td><td>向下展开</td></tr><tr><td>slideUp()</td><td>向上卷起</td></tr><tr><td>slideToggle()</td><td>依次展开或卷起某个元素</td></tr><tr><td>toggle()</td><td>依次展示或隐藏某个元素</td></tr></tbody></table><p>每个方法都有两个参数默认值，分别是变化速度 400ms 和回调函数 undefined</p><p>变化速度有两种表示方法，数字表示毫秒，或 slow 等表示指定速度</p><p>回调函数可以指定特效结束时执行的方法</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'h1'</span>).fadeIn(<span class="number">300</span>); <span class="comment">// 300毫秒内淡入</span></span><br><span class="line">$(<span class="string">'h1'</span>).fadeOut(<span class="string">'slow'</span>); <span class="comment">// 缓慢地淡出</span></span><br><span class="line">$(<span class="string">'p'</span>).fadeOut(<span class="number">300</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; $(<span class="keyword">this</span>).remove(); &#125;);</span><br></pre></td></tr></table></figure><p>更复杂的可以使用 animate 自定义</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).animate(</span><br><span class="line">    &#123;</span><br><span class="line">        left : <span class="string">"+=50"</span>,</span><br><span class="line">        opacity : <span class="number">0.25</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">300</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">'done!'</span>); &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>第一个参数填写基于 css 语法的对象，第二个参数表示动画持续时间，第三个参数表示回调函数</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>一个自己封装的 JQ，但是功能肯定比真的 JQ 弱很多，2333</p><p><a href="https://github.com/Ringoer/Toy/blob/main/39/main.js" target="_blank" rel="noopener">https://github.com/Ringoer/Toy/blob/main/39/main.js</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html" target="_blank" rel="noopener">JQuery设计思想</a></p><p><a href="https://www.jquery123.com/" target="_blank" rel="noopener">jQuery API 中文文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DOM API 好难用，我要用 JQ！&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>DOM API</title>
    <link href="http://yoursite.com/frontend/dom-api/"/>
    <id>http://yoursite.com/frontend/dom-api/</id>
    <published>2020-12-05T08:39:00.000Z</published>
    <updated>2020-12-12T14:33:11.111Z</updated>
    
    <content type="html"><![CDATA[<p>只要是学前端的同学，肯定都听说过 DOM</p><a id="more"></a><h1 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h1><p>在 JS 中，常常使用 document.xxx 来对页面进行操作。那实际操作的是什么呢？</p><p>在开发者工具中运行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div=<span class="built_in">document</span>.querySelector(<span class="string">'#container'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(div)</span><br></pre></td></tr></table></figure><p>就可以看到打印出了一个 id 为 container 的元素</p><p>这个元素就是 DOM 元素</p><p>然后去 Elements 中查看，可以发现这些元素呈现层次关系，这个关系正是树形结构</p><p>所以文档结构就是 DOM 树，全称 文档对象模型树（Document Object Model）</p><p>通过打印原型链，可以发现以下原型关系</p><p>Object -&gt; EventTarget -&gt; Node -&gt; Element -&gt; HTMLElement -&gt; HTMLDivElement</p><p>显然，每个 DOM 元素都有自己的属性，但属性原则上属于 DOM 元素的一部分，对属性的操作等效于对元素的操作，故而在 Update 中统一描述</p><h1 id="Retrieve"><a href="#Retrieve" class="headerlink" title="Retrieve"></a>Retrieve</h1><h2 id="查自己"><a href="#查自己" class="headerlink" title="查自己"></a>查自己</h2><p>首先要获取，才能做各种操作</p><p>对于普通的 DOM 元素，一般有如下 API</p><ol><li>document.getElementById(‘xxx’)，获取 id 为 xxx 的元素，包括 IE，全都支持</li><li>window.xxx（或直接使用 xxx），获取 id 为 xxx 的元素，除了 IE，全都支持</li><li>document.getElementsByTagName(‘div’)，获取所有标签名为 div 的元素，返回伪数组</li><li>document.getElementsByClassName(‘yyy’)，获取所有 CSS 类名为 yyy 的元素，返回伪数组</li><li>document.querySelector(selector)，获取第一个满足传入的 CSS 选择器的元素</li><li>document.querySelectorAll(selector)，获取所有满足传入的 CSS 选择器的元素，返回伪数组</li></ol><p>对于特殊的元素，一般有以下 API</p><ol><li>document.documentElement，获取 html 根元素</li><li>document.head，获取 head 元素</li><li>document.body，获取 body 元素</li><li>window，获取窗口（注意窗口不是元素</li><li>document.all，获取所有元素</li></ol><p>在使用 document.all 的时候需要注意，虽然现在所有浏览器都支持这个查询了，但因为历史遗留原因，虽然能获取到值，但转化为布尔值的时候，在非 IE 的浏览器上都返回 false，只有在 IE 上才返回 true</p><h2 id="查祖先"><a href="#查祖先" class="headerlink" title="查祖先"></a>查祖先</h2><p>显然除了根结点，每个结点有且仅有一个父结点</p><p>那么可以通过 <code>div.parentNode</code> 不断向上查找</p><h2 id="查子代"><a href="#查子代" class="headerlink" title="查子代"></a>查子代</h2><p>可以通过 <code>div.childNodes</code> 或 <code>div.children</code> 来查找</p><p>需要注意的是，<code>div.childNodes</code> 返回的是 NodeList，单位类型是 Node，是伪数组，直接 concat 空数组的话不能正常展开，需要用空数组 concat 一个 Array,from 才行</p><p><code>div.children</code> 返回的是 ElementCollection，单位类型均为 Element 的派生类型，与数组操作时注意点同上</p><p>并且，<code>div.childNode</code> 返回值包括文本结点等不直接显示的结点，而 <code>div.children</code> 没有这个问题</p><p>子代中对特定元素也有专有的方法</p><ol><li>查看第一个子结点，div.firstChild</li><li>查看最后一个子结点，div.lastChild</li></ol><h2 id="查兄弟"><a href="#查兄弟" class="headerlink" title="查兄弟"></a>查兄弟</h2><p>可以通过先查父结点，再查父结点的子结点来做到，但要排除自己才是兄弟结点</p><p>同样，兄弟也有专有方法</p><ol><li>查看相邻的上一个兄弟，div.previousSibling</li><li>查看相邻的下一个兄弟，div.nextSibling</li></ol><h1 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h1><p>通常使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement([tagName])</span><br></pre></td></tr></table></figure><p>来创建一个指定标签元素</p><p>或</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createTextNode([string])</span><br></pre></td></tr></table></figure><p>来创建一个包含指定文本的文本结点</p><p>但创建之后的元素或节点，均还在 JS 线程中，必须通过 API 添加到页面上，由渲染线程处理后，才能在页面上显示</p><p>通常通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[parentNode].appendChild([childNode])</span><br></pre></td></tr></table></figure><p>来将指定的结点添加到某个结点中</p><p>关于添加结点，有以下两种特殊情况</p><ol><li><p>同一结点被多次添加到不同结点的子结点列表中</p><p>此时该子结点会出现在最后一次被添加到的位置</p></li><li><p>意图向某结点添加文本</p><p>此时不可以直接 appendChild(string)，必须先将 string 转换成文本结点，或用 innerText、textContent 属性来添加文本</p><p><strong>innerText 是 IE 产物，textContent 是其它浏览器产物，但现在所有浏览器都同时支持两个</strong></p></li></ol><h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>一般有两种方法</p><ol><li><code>[parentNode].removeChild([childNode])</code></li><li><code>[childNode].remove()</code></li></ol><p>对于被从 DOM 树中移除的结点，只要还没丢失对它的引用，就还可以通过 appendChild 再次回到页面上</p><h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>如同前述，对元素的修改包含对属性的修改</p><p>一般分为四种属性</p><ol><li>HTML 标签属性</li><li>CSS 属性</li><li>data 属性</li><li>自定义属性</li></ol><p>不论是何种属性，都可以通过点符号进行 get/set</p><p>但是 JS 中不能使用连接符来访问，所以在使用连接符的地方，要改用驼峰命名法</p><h2 id="HTML-标签属性"><a href="#HTML-标签属性" class="headerlink" title="HTML 标签属性"></a>HTML 标签属性</h2><p>直接使用赋值语句改值即可，注意值必须是字符串</p><p>如 <code>img.width = &#39;200px&#39;</code></p><p>但是有的属性不太一样，比如 a 标签的 href 属性</p><p>如果通过 <code>a.href</code> 来获取，浏览器会自动补全 href 的根路径，最终获取到的字符串是 http/https 开头的</p><p>此时应该通过 <code>a.getAttribute(&#39;href&#39;)</code> 来获取，能保证获取到的字符串不会被浏览器动手脚</p><h2 id="CSS-属性"><a href="#CSS-属性" class="headerlink" title="CSS 属性"></a>CSS 属性</h2><p>有 class 和 style 两种</p><p>对于 class，使用 <code>[node].className=&#39;newClass&#39;</code> 来修改</p><p>或使用 <code>[node].classList.add(&#39;newClass&#39;)</code> 来添加适配的 class</p><p>对于 style，可以直接赋值 style 字符串</p><p>如 <code>div.style=&#39;width:100px; height: 200px&#39;</code></p><p>也可以针对性赋值，如 <code>div.style.width=&#39;100px&#39;</code></p><h2 id="data-属性"><a href="#data-属性" class="headerlink" title="data 属性"></a>data 属性</h2><p>常常可以见到形如 <code>data-*</code> 的属性</p><p>这些属性类似于 style，可以通过统一入口 dataset 来访问</p><p>如属性 <code>data-x-err</code>，可以通过 <code>div.dataset.xErr</code> 来访问</p><h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><p>修改方法与 HTML 属性相同，直接通过点符号访问即可</p><p>但一般不建议采用不是 data 的自定义属性</p><p>因为当目标结点现在在页面中时，对以上三种属性的修改都会直接同步到页面上，但对自定义属性的修改不能同步到页面上</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>每个元素都会有各种事件，此处以 click 事件为例</p><p>要为 click 事件绑定处理函数，可以用如下两种方法</p><ol><li><p><code>div.onclick=()=&gt;{}</code>，此时 div 只能有一个方法，新方法会覆盖旧方法，在冒泡阶段执行</p></li><li><p><code>div.addEventListener(&#39;click&#39;,()=&gt;{},false)</code>，此时 div 有若干个方法，新方法与旧方法都会在 click 事件被触发</p><p>此处的第三个参数默认值 false，表示事件在冒泡阶段触发。如果改为 true 就是在捕获阶段触发</p><p>需要注意的是，IE 只有冒泡阶段，并且事件列表执行顺序是 FIFO，其它非 IE 浏览器则有捕获和冒泡，且执行顺序是 LIFO</p></li></ol><p>不论是如何添加事件，在事件被触发时，都有两个默认参数</p><p>一个是 this，指向事件触发所在的元素</p><p>一个是 event，包含该事件触发时的所有相关信息</p><h2 id="文本内容"><a href="#文本内容" class="headerlink" title="文本内容"></a>文本内容</h2><p>通过 innerText、textContent 属性来添加文本</p><p><strong>innerText 是 IE 产物，textContent 是其它浏览器产物，但现在所有浏览器都同时支持两个</strong></p><h2 id="父子结点关系"><a href="#父子结点关系" class="headerlink" title="父子结点关系"></a>父子结点关系</h2><p>可以通过结点操作或 innerHTML 注入来实现</p><p>例如 <code>div.innerHTML=&#39;&lt;span&gt;233&lt;/span&gt;&#39;</code> 就是向 div 中插入了一个内容为 233 的 span 标签</p><p>注意，此时会覆盖 div 中的所有内容（包括子元素）</p><p>如果想添加新儿子，可以使用 appendChild 方法，不再赘述</p><p>如果想换个新父结点，则只需要利用 appendChild 会出现在最新位置的特点，直接向新父结点插入当前结点即可</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p><a href="https://github.com/Ringoer/Toy/blob/main/37/main.js" target="_blank" rel="noopener">原生 dom 封装</a></p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>既然 DOM API 这么复杂，有没有更方便的方法呢？</p><p>答案是有，典型的例子就是 JQuery 库</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只要是学前端的同学，肯定都听说过 DOM&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JS循环打印与延迟执行</title>
    <link href="http://yoursite.com/frontend/javascript-setTimeout/"/>
    <id>http://yoursite.com/frontend/javascript-setTimeout/</id>
    <published>2020-12-02T02:23:00.000Z</published>
    <updated>2020-12-02T03:38:38.563Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知 var 在循环里有坑</p><p>本文介绍基于经典例子——打印 0 到 5</p><a id="more"></a><p>关于打印 0 到 5 这个任务，该怎么办呢？很自然地想到使用循环打印</p><p>但如果是普通的循环打印，就不会有这篇文章了</p><p>我们要做的是——通过 setTimeout 的循环打印</p><p>首先是 c 风格的循环打印代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run 了一看，ん？？怎么打了 6 个 6</p><p>原因是此时 i 变量相对于 for 来说处在全局，而不是封闭的词法环境</p><p>光是这个原因，都足以抹平 let 和 var 的差距了</p><p>再加上 setTimeout 的宏任务，会在下一个事件循环开启的时候才执行（关于宏任务，会在其它文章介绍，本篇略</p><p>于是执行就变成了</p><ol><li>声明 i=0</li><li>循环设置定时器，定时器中索引指向 i</li><li>循环完毕，i=6</li><li>当前事件循环清空，开启下一个事件循环</li><li>通过索引发现 i=6，于是所有定时器都打印了 6</li></ol><p>那怎么办呢？此时注意到，刚才我提到了一个关键词——封闭的词法环境</p><p>那采用闭包的思想，让 i 处于封闭的词法环境，不就可以了！</p><p>来试试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就可以正常打印 0 到 5 了！</p><p>为什么呢？因为此时 i 的作用域仅限于 for 之内，每个 setTimeout 获取 i 的索引的时候，获取到的都是不一样的值，所以现在可以正常打印</p><p>但是在这里，换成 var 就大不相同了</p><p>因为通过 var 声明的变量实际上会绑定到 window，所以此时获取的索引还是相同，还是要打印 6 个 6</p><p>那么，还有什么别的，能通过 setTimeout 打印 0 到 5 的办法呢？</p><p>容易想到，有两种改变</p><ol><li>通过在 setTimeout 中自增来实现</li><li>通过 generator 实现</li></ol><p>先说第一种，代码很简单，把控制自增的部分从 for 移动到 setTimeout 就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n++)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到此时 let i 除了控制循环，已经和 setTimeout 没有关系了</p><p>配合后置 ++ 运算符的先取值再自增特性，很容易实现了在 setTimeout 中的自增</p><p>那么 generator 怎么实现呢？</p><p>我不想在这里介绍 generator 语法（（实在太长了</p><p>直接给出例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; i++) <span class="keyword">yield</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g=generateSequence(<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(g.next().value)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以声明一个生成器工厂，每当运行该工厂方法的时候，传入上下界，然后返回一个生成器</p><p>每当生成器调用 next 方法的时候，都会返回一个对象，该对象包含 value 字段和 done 字段，分别表示抛出的值和该生成器当前的状态</p><p>显然生成器的调用是不可逆的，所以也约等于刚才说的在 setTimeout 中自增</p><p>以上</p><p>你还有别的办法吗？可以通过本站的”联系方式”向我发邮件~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知 var 在循环里有坑&lt;/p&gt;
&lt;p&gt;本文介绍基于经典例子——打印 0 到 5&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>py对拍器</title>
    <link href="http://yoursite.com/algorithm/python-counterpoint/"/>
    <id>http://yoursite.com/algorithm/python-counterpoint/</id>
    <published>2020-12-01T07:03:00.000Z</published>
    <updated>2020-12-01T07:21:55.533Z</updated>
    
    <content type="html"><![CDATA[<p>今天在验题的时候，与其他验题人输出不合，偶感，特此写一个对拍器</p><a id="more"></a><p>可以用于 c/cpp 对拍</p><p>请先去除代码中的 freopen，并编译成 exe</p><p>使用时只需要修改运行目录，和验题人标识符，即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.chdir(<span class="string">'E:\problems\div1\T1'</span>)</span><br><span class="line">arr=os.listdir()</span><br><span class="line">input_files=[file <span class="keyword">for</span> file <span class="keyword">in</span> arr <span class="keyword">if</span> file.endswith(<span class="string">'.in'</span>)]</span><br><span class="line">l=len(input_files)</span><br><span class="line"></span><br><span class="line">names=[<span class="string">'lzz'</span>,<span class="string">'ringoer'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">    os.system(name+<span class="string">'.exe &lt;'</span>+input_files[i]+<span class="string">' &gt;'</span>+str(i+<span class="number">1</span>)+<span class="string">'.'</span>+name+<span class="string">'.out'</span>)</span><br><span class="line"></span><br><span class="line">arr=os.listdir()</span><br><span class="line">output_files=[file <span class="keyword">for</span> file <span class="keyword">in</span> arr <span class="keyword">if</span> file.endswith(<span class="string">'.out'</span>)]</span><br><span class="line"></span><br><span class="line">ans=[[open(file,mode=<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>).read() <span class="keyword">for</span> file <span class="keyword">in</span> output_files <span class="keyword">if</span> name <span class="keyword">in</span> file] <span class="keyword">for</span> name <span class="keyword">in</span> names]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">  flag=<span class="keyword">True</span></span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(names)):</span><br><span class="line">    <span class="keyword">if</span> ans[<span class="number">0</span>][i] != ans[j][i]:</span><br><span class="line">      flag=<span class="keyword">False</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">if</span> flag:</span><br><span class="line">    print(flag)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,len(names)):</span><br><span class="line">      print(names[j]+<span class="string">'='</span>+ans[j][i])</span><br></pre></td></tr></table></figure><p>高度解耦，非常美观</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在验题的时候，与其他验题人输出不合，偶感，特此写一个对拍器&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>JS对象用法</title>
    <link href="http://yoursite.com/frontend/javascript-object/"/>
    <id>http://yoursite.com/frontend/javascript-object/</id>
    <published>2020-11-30T03:26:00.000Z</published>
    <updated>2020-11-30T06:20:39.426Z</updated>
    
    <content type="html"><![CDATA[<p>JS 也有面向对象</p><a id="more"></a><p>又到了我第 114514 喜欢的 CRUD 环节</p><h1 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h1><p>创建属性一般有两种办法</p><ol><li>在对象声明时创建</li><li>在对象声明后插入</li></ol><h2 id="声明对象"><a href="#声明对象" class="headerlink" title="声明对象"></a>声明对象</h2><p>一般有两种</p><ol><li><p>直接创建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    x:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过 Object 对象方法创建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">    x:<span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>为什么会有两种写法？因为第二种才是正规的</p><p>但是架不住第一种更方便，于是第一种也变成合法的了</p><p>obj 的键一定是字符串，所以可以写任意的键名，甚至包括 空字符串 和 emoji</p><p>需要注意的是，无论你怎么写 obj 的键，它在构造完成后都会变成字符串</p><p>可以通过 Object.keys(obj) 来查看</p><p>比如</p><ol><li><p>键是数字的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    <span class="number">2</span>:<span class="string">'233'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 obj 会拥有一个名为 ‘2’ 的键</p></li><li><p>有同名变量的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    a:<span class="string">'233'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 obj 会拥有一个名为 ‘a’ 的键</p></li></ol><p>但还有 2 种情况例外</p><ol><li><p>当 obj 是数字表达式的时候</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    <span class="number">1e2</span>: <span class="string">'233'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 obj 会拥有一个名为 ‘100’ 的键</p></li><li><p>当 obj 使用方括号表达式的时候</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">233</span>;</span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    [a]:<span class="string">'233'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 obj 会拥有一个名为 ‘233’ 的键</p></li></ol><p>而且，obj 在自动构建后会包含一个 <code>__proto__</code> 属性指向其原型</p><p>那我不要默认的 Object 原型，想要别的原型怎么办？</p><p>可以使用 Object.create 来创建来自指定原型的新对象</p><p>示例如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> common=&#123;</span><br><span class="line">    xxx:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> a=<span class="built_in">Object</span>.create(common,&#123;<span class="attr">yyy</span>:&#123;<span class="attr">value</span>:<span class="number">2</span>&#125;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>期望输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;yyy: 2&#125;</span><br><span class="line">yyy: 2</span><br><span class="line">__proto__:</span><br><span class="line">xxx: 1</span><br><span class="line">__proto__: Object</span><br></pre></td></tr></table></figure><p>此时 a 可以访问属性 xxx 和 yyy，其中 yyy 来自自身，xxx 来自原型</p><p>需要注意的是，在 create 的第二个参数中，要求写的是属性描述符，一般包括</p><ol><li>value，属性值，必填</li><li>writeable，默认 true，可以编辑，若为 false 则只读</li><li>enumerable，默认 true，可以被枚举，若为 false 则不能通过简单的键遍历找到</li><li>configureable，默认 true，可以被重新配置，若为 false 则永远在当前对象上保持当前状态</li></ol><p>等 4 个配置</p><h2 id="插入属性"><a href="#插入属性" class="headerlink" title="插入属性"></a>插入属性</h2><p>一般有两种逐条插入的写法</p><ol><li>obj.property = value</li><li>obj[property] = value</li></ol><p>都是合法的写法</p><p>但是对于第一种，点号后必须是完整键名，不加引号</p><p>对于第二种，方括号内可以是表达式或字符串，如果可以识别为字符串，则字符串优先</p><p>示例如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    xxx: <span class="number">666</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="string">'abc'</span>]=<span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> abc=<span class="string">'xxx'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.abc); <span class="comment">// 233</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">'abc'</span>]); <span class="comment">// 233</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[abc]); <span class="comment">// 666</span></span><br></pre></td></tr></table></figure><p>可见点符号的识别和方括号的识别是不一样的</p><p>还有一种批量插入的写法 Object.assign</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    xxx: <span class="number">666</span>,</span><br><span class="line">    yyy: <span class="number">233</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(obj,&#123;<span class="attr">xxx</span>:<span class="number">111</span>,<span class="attr">zzz</span>:<span class="number">114514</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>期望输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;xxx: 111, yyy: 233, zzz: 114514&#125;</span><br></pre></td></tr></table></figure><p>可见 assign 可以覆盖，可以新增，而且不会影响其他原有值</p><h1 id="Retrieve"><a href="#Retrieve" class="headerlink" title="Retrieve"></a>Retrieve</h1><p>显然可以分为按键查找和按值查找两种类型</p><h2 id="按键查找"><a href="#按键查找" class="headerlink" title="按键查找"></a>按键查找</h2><p>可以使用以下两种方法</p><ol><li>in</li><li>Object.hasOwnProperty</li></ol><p>in 通过查找原型链确定某个参数是否存在于指定对象上</p><p>Object.hasOwnProperty 只会查找对象本身，不会上升到原型链</p><p>也可以用以下的 Object 方法来查找键或值</p><ol><li>Object.keys 列出所有键</li><li>Object.values 列出所有值</li><li>Object.entries 列出所有键值对</li></ol><h2 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h2><p>通过上述的 entries 方法取得所有键值对，然后遍历即可</p><h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>可以使用</p><ol><li>点符号</li><li>方括号</li><li>Object.assign</li><li>Object.defineProperty</li></ol><p>来更新属性</p><p>需要注意的是，上述方法均不会直接修改到原型上</p><p>比如原型上有属性 xxx，当前对象 obj 上没有</p><p>则令 obj.xxx=’233’，会为当前对象绑定一个新属性 xxx，而不会修改原型上的</p><p>虽然可以通过 <code>__proto__.xxx</code> 来修改，但十分不推荐修改原型的属性</p><p>那如果直接修改原型呢？</p><p>虽然 JS 是允许直接通过 <code>__proto__ = xxx</code> 来修改对象的原型指向的，但性能十分之低下</p><p>如果一定要修改原型，最好在创建对象的时候使用 Object.create，在创建时就指定新的原型</p><h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>一般有删除值和删除键两种需求</p><p>对于删除值，只需要取对应的键，然后赋值 undefined 即可</p><p>对于删除键，只需要使用 delete 语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.property;</span><br></pre></td></tr></table></figure><p>即可删除键</p><p>可以用 <code>property in obj</code> 查看 obj 中是否还含有指定键名</p><p>但待删除的键不可以是不可配置的（通过 Object.defineProperty 设置的不可配置）</p><p>需要注意的是，delete 语句用于删除属性时，在所有情况下都会返回 true 表示删除成功，即便 obj 中不存在目标键</p><p>除非将 delete 用于删除对象等非属性值，才会返回 false</p><p>谢谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 也有面向对象&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS语法-基于C</title>
    <link href="http://yoursite.com/frontend/javascript-base-grammar/"/>
    <id>http://yoursite.com/frontend/javascript-base-grammar/</id>
    <published>2020-11-29T04:21:00.000Z</published>
    <updated>2020-11-30T03:28:00.840Z</updated>
    
    <content type="html"><![CDATA[<p>本文描述 JavaScript 的基本语法，但和 c 一样的就跳过了</p><a id="more"></a><h1 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h1><p>与 c 基本相同，但是 c 对于分号是强要求，js 对于分号并不强要求，只要不影响断句，想怎么样都可以</p><p>并且，c 对于换行的语句基本不支持，但是 js 依然是只要不影响断句就可以</p><p>但是 return 不一样，js 的 return 不能换行，否则会返回 undefined</p><h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>c 的标识符只能接受数字字母下划线，且不能以数字开头</p><p>js 的标识符可以接受所有符号，包括希腊文、中文等，不过依然不能以数字开头</p><h1 id="if、else、switch、三目表达式"><a href="#if、else、switch、三目表达式" class="headerlink" title="if、else、switch、三目表达式"></a>if、else、switch、三目表达式</h1><p>与 c 完全相同</p><h1 id="while、break、continue"><a href="#while、break、continue" class="headerlink" title="while、break、continue"></a>while、break、continue</h1><p>与 c 完全相同</p><h1 id="for"><a href="#for" class="headerlink" title="for"></a>for</h1><p>c 只能接受 for(初始化; 循环条件; 迭代) 这种形式</p><p>js 除了上述形式，还可以接受 for(let 标识符 of 可迭代对象) 或 for(let 标识符 in 可迭代对象) 的形式</p><p>for … in 还可以用于枚举对象键</p><h1 id="label"><a href="#label" class="headerlink" title="label"></a>label</h1><p>类似于 c 的 goto 语句</p><p>区别是 c 只有 goto，只能前往 label 所在区域</p><p>但是 js 只有 break 和 continue，只能打破现在所在 label</p><p>为什么这里 continue 不是循环？因为 continue 的作用是进入下一次迭代，但是普通的 label，除非写在循环中，否则哪里来的下一次迭代呢</p><hr><p>以上</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文描述 JavaScript 的基本语法，但和 c 一样的就跳过了&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hexo唯一ID遍历器</title>
    <link href="http://yoursite.com/others/hexo-uniform-id/"/>
    <id>http://yoursite.com/others/hexo-uniform-id/</id>
    <published>2020-11-26T08:11:00.000Z</published>
    <updated>2020-11-28T04:08:37.576Z</updated>
    
    <content type="html"><![CDATA[<p>用 hexo 写博客，为了 URL 好看，显然要手动为每一篇文章都指定 ID，怎么防止重复呢？</p><a id="more"></a><p>可以用 python 代码实现</p><p>强语义的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变当前工作目录，并获取目录下的所有文件</span></span><br><span class="line">os.chdir(<span class="string">'D:\hexo\source\_posts'</span>)</span><br><span class="line">arr=os.listdir()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取每个文件的内容，存数组</span></span><br><span class="line">arr=[open(file,mode=<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>).read() <span class="keyword">for</span> file <span class="keyword">in</span> arr]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取每个内容中的 ID，存数组</span></span><br><span class="line">arr=[text.split(<span class="string">'id: '</span>)[<span class="number">1</span>].split(<span class="string">'\n'</span>)[<span class="number">0</span>] <span class="keyword">for</span> text <span class="keyword">in</span> arr]</span><br><span class="line">arr.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">  print(i)</span><br></pre></td></tr></table></figure><p>通过如上代码，一眼就可以看出哪里 ID 重复了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 hexo 写博客，为了 URL 好看，显然要手动为每一篇文章都指定 ID，怎么防止重复呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="others" scheme="http://yoursite.com/categories/others/"/>
    
    
      <category term="others" scheme="http://yoursite.com/tags/others/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>JS的历史</title>
    <link href="http://yoursite.com/frontend/javascript-history/"/>
    <id>http://yoursite.com/frontend/javascript-history/</id>
    <published>2020-11-26T08:06:00.000Z</published>
    <updated>2020-12-10T15:05:17.904Z</updated>
    
    <content type="html"><![CDATA[<p>简单讲讲前端利器 JavaScript 的历史</p><a id="more"></a><h1 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h1><p>JavaScript 诞生自美国人布兰登之手</p><p>布兰登于 1961 年出生，1995 年进入网景公司，受命为网景公司的浏览器开发了 JavaScript 功能</p><p>该功能当初只是为了蹭 Java 的热度，所以才命名为 JavaScript，类似雷锋和雷峰塔的关系（</p><p>布兰登当初只花了 10 天就设计出了 JavaScript 的雏形</p><h1 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h1><p>没想到后来大家发现 JavaScript 在浏览器上这么好用，于是每家浏览器都开发了自己浏览器上的 JavaScript 方言，其中包括微软 IE 浏览器</p><p>网景公司一看，这怎么行，我要合纵连横，打败微软先</p><p>于是 1996 年 11 月，网景向 ECMA 提交了 JavaScript 语言标准，但因为版权问题，改名为 ECMAScript</p><p>现在我们所说的 ECMAScript 是标准，JavaScript 是实现，类似于 C99 和 C语言的关系</p><h1 id="停滞"><a href="#停滞" class="headerlink" title="停滞"></a>停滞</h1><p>在和网景的竞争中，微软采取了一个很”机智”的行为：将 IE6 捆绑进 Windows XP 系统</p><p>这个行为虽然在之后被判定为垄断行为，但在当时确实帮助 IE 迅速抢占了大量的市场份额，直接导致网景公司无法继续运营</p><p>网景决定绝地求生奋力一搏，将自己的浏览器源代码开源了，这就是后来的 Firefox</p><p>但是即便开源，也还是竞争不过 IE，终于在 1998 年年底，网景被收购了</p><p>这之后 IE6 打遍天下无敌手，以至于微软都觉得 IE 不需要继续改进了，于是解散了 IE6 团队</p><p>在看到 IE6 团队解散后，Firefox 打算再试试，卷土重来，继续与 IE 竞争，但收效甚微</p><p>到 2004 年，IE6 占有全球市场的 80%</p><p>但是——IE6 不兼容 W3C 标准，特别是 CSS！！！！</p><p>2005 年，微软终于发现 IE6 还是太菜，BUG 巨多，标准不兼容，于是重新组建了 IE7 团队，但却不是 IE 原班人马，这导致 IE7 甚至打不过 IE6</p><p>特别是中国市场，几乎全国都是盗版 Windows XP，所以 IE6 在中国大行其道</p><p>直到 2008 年，Chrome 发布第一版为止，JavaScript 都因为浏览器大战，只产生了几项新技术，没有太大的发展</p><h1 id="重新起步"><a href="#重新起步" class="headerlink" title="重新起步"></a>重新起步</h1><p>2004 年，谷歌抓住机会，抢了一些从 Firefox 和 IE 流失的程序员</p><p>同年，谷歌发布了 Gmail 在线网页，向人们展示了 JavaScript 不止可以做小功能，还可以在网页上做到当时应用程序才能做到的邮件系统功能，让人们发现了 JavaScript 的无限可能性</p><p>显然，邮件系统的交互是用到了网页与服务器通信的技术的</p><p>于是在 2005 年，Jesse 总结了这项技术，并将其命名为 AJAX。这标志着前端这个领域正式诞生</p><p>2008 年，谷歌发布了 Chrome 第一版</p><p>Chrome 对标准支持良好，JavaScript 终于有能正常运行的地方了，这才又重新慢慢发展</p><p>之后的 2010 年，iPhone4 发布，世界进入智能手机时代</p><p>虽然微软也试图搭上这班车，但 Windows Phone 实在是不行，竞争中没有任何优势</p><p>于是智能手机市场就出现了一个情况——因为智能手机上没有 IE，所以不需要在智能手机上兼容 IE 了！</p><p>这是 IE 消亡的重大征兆，毕竟从现在回头看，跟不上智能手机市场的服务基本都被淘汰了</p><p>在中国国内，则有一个重大事件：2016 年，淘宝和天猫宣布不再支持 IE6、7、8</p><p>中国程序员也摆脱了 IE 的枷锁，让 JavaScript 再也没有后顾之忧地开始极速发展</p><h1 id="ECMAScript-标准"><a href="#ECMAScript-标准" class="headerlink" title="ECMAScript 标准"></a>ECMAScript 标准</h1><p>1997 年 6 月，第一版</p><p>1999 年 12 月，第三版。因为此时 IE6 还在更新，所以 IE6 也有实现该标准的部分要求，所以这一版成为了使用最广的版本</p><p>第四版则因为贪心不足蛇吞象，加入新功能太多，浏览器厂商纷纷表示不能实现，于是流产了</p><p>这下一搞，直到十年之后，浏览器大战结束的 2009 年 12 月，才发布了第五版</p><p>又拖到 2015 年 6 月，Chrome 占有全球过半市场，才发布了第六版</p><p>标准的制定与发布遵循以下流程：</p><ol><li>浏览器厂商尝试添加新功能，添加后用户反馈良好</li><li>浏览器厂商将该功能推荐给 ECMA，ECMA 询问其他厂商意见</li><li>其他厂商一致认为该功能是有用的，于是 ECMA将该功能加入标准</li></ol><p>从此 ES6 发布开始，JavaScript 发展进入快车道，每年都有一版新标准发布，以年份命名</p><p>但目前面试常考的只有 ES5 和 ES6，至于 ES2016、ES2017等标准，一般不会在面试中考察</p><h1 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h1><p>Chrome 使用的 JS 引擎叫 V8 引擎，是一个系列引擎的一种，其余引擎分别解析其它语言</p><p>2009 年，Ryan 基于 V8 创造了 Node.js；2010 年，Isaac 基于 Node.js 创造了 npm。这让 JavaScript 在浏览器之外也可以执行了！所以 Node.js 快速流行起来</p><p>还是 2010 年，TJ 基于 Node.js 发布了 Express 框架，从此 JavaScript 也可以用于后端开发了</p><p>之后前端的发展越来越快，产生了很多其其它它的框架，比如 requirejs，比如 webpack 打包，比如 React、Vue 等前端框架，总之技术发展日新月异，JS 生命力旺盛，蓬勃向上</p><p>相信未来也会有更多更多的，关键的新技术出现</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JavaScript 其实是和 Java 同年出生的，如果没有十年浏览器大战，JavaScript 现在又会是何等光景呢……</p><p>不过也正是 JavaScript 现在正处在市场热点，我才有机会通过这项技术找到工作，2333</p><p>希望 JavaScript 越来越好！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单讲讲前端利器 JavaScript 的历史&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://yoursite.com/knowledge/computer-network/"/>
    <id>http://yoursite.com/knowledge/computer-network/</id>
    <published>2020-11-25T13:31:00.000Z</published>
    <updated>2020-12-12T14:34:10.234Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍一些计算机网络相关的专业知识</p><a id="more"></a><p>众所周知，计算机网络最重要的概念是 OSI 七层模型</p><h1 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h1><p>自底向上，分为以下七层</p><ol><li>物理层，完成 bit 到载波之间的转换，处理物理介质接口</li><li>数据链路层，负责介质访问控制和逻辑链路控制</li><li>网络层，负责主机到主机之间的通信与路由寻址</li><li>传输层，负责进程间端到端通信和可靠传输</li><li>会话层，负责会话的建立、撤销与面向连接的口令认证等</li><li>表示层，负责信息的加密、解密、压缩、转换等</li><li>应用层，提供最通用的应用程序（电子邮件、web等），完成用户与软件的交互</li></ol><p>然后先介绍一下重要的协议们</p><ol><li>网络层，IP 协议</li><li>传输层，TCP 协议</li><li>应用层，HTTP 协议</li><li>介于网络层和传输层之间，SSL 协议</li></ol><h1 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h1><p>网络层负责路径确定与逻辑寻址</p><p>而路径，就是由 IP 地址提供的，通过点分十进制计数法确定 IPv4 地址</p><p>但是显然 IP 地址总数是有限的，怎么延长寿命呢？</p><p>1985 年起增加 “子网号字段”，IP 地址变为 网络号+子网号+主机号</p><p>其中，主机号全 0 代表网络，主机号全 1 代表广播</p><p>这样，网络数量就增加了，但还是不够用，于是又产生了 网络地址转换——NAT</p><p>根据网络的 ABC 类，分配不同的私有地址，私有地址是同一路由器内特有的</p><p>常见的民用 IP 地址是 C 类，私有地址就是 192.168.0.0/16， 16 指子网掩码</p><p>为了 IP 协议的正常运转，又产生了 差错报告机制——ICMP，我们知道的 ping 命令测试网络连接可达性，就是基于 ICMP 的</p><p>而且 ping 命令是应用层直接使用 网络层 ICMP 的，并没有经过传输层的 TCP 或 UDP</p><p>一个 ping 实例如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ping baidu.com</span><br><span class="line"></span><br><span class="line">正在 Ping baidu.com [220.181.38.148] 具有 32 字节的数据:</span><br><span class="line">来自 220.181.38.148 的回复: 字节=32 时间=49ms TTL=53</span><br><span class="line">来自 220.181.38.148 的回复: 字节=32 时间=46ms TTL=53</span><br><span class="line">来自 220.181.38.148 的回复: 字节=32 时间=47ms TTL=53</span><br><span class="line">来自 220.181.38.148 的回复: 字节=32 时间=47ms TTL=53</span><br><span class="line"></span><br><span class="line">220.181.38.148 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 46ms，最长 = 49ms，平均 = 47ms</span><br></pre></td></tr></table></figure><h1 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h1><p>传输层有 TCP 协议和 UDP 协议，其中 TCP 协议负责端到端连接、可靠性和流量控制</p><p>TCP 的特点如下</p><ol><li>面向连接</li><li>点对点</li><li>可靠</li><li>全双工</li><li>字节流</li></ol><p>相对的 UDP 的特点如下</p><ol><li>无连接</li><li>尽力交付</li><li>面向报文</li><li>允许广播</li></ol><p>因为 TCP 有 UDP 所没有的最重要的机制 —— 三次握手、四次挥手，所以 TCP 传输会比 UDP 安全很多，也易于控制，但是也因此在连接上消耗了更多时间，传输速率不如 UDP 快</p><p>TCP 的主要机制如下，其特点全部依赖其机制</p><ul><li>应答机制、超时机制、重传机制、窗口机制</li><li>流量控制：滑动窗口机制</li><li>拥塞控制：慢开始、拥塞避免、快重传、快恢复、随机早期检测</li><li>连接的建立和解除：三次握手、四次挥手</li></ul><p>虽然实际的数据报交换还是网络层在负责，但传输层解决了网络层的主要问题：丢包、重复、乱序</p><p>为什么可以解决这些问题呢？因为网络通信本质上是两个进程间的通信，而不是主机之间的通信</p><p>通信中由 IP 地址唯一标识主机，由端口号唯一标识进程，所以可以通过 IP 地址+端口号的形式来进行进程间通信</p><p>而传输层又向上层隐藏了硬件拓扑、路由细节等，使得上层应用程序可以直接调用其接口，建立一条虚拟的端到端的通信信道</p><p>建立信道和解除的过程如下图</p><p><img src="https://pic.ringoer.com/三次握手.png" alt="三次握手"><img src="https://pic.ringoer.com/四次挥手.png" alt="四次挥手"></p><h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>万维网 WWW（World Wide Web）建立的原因，是一个美好的愿景：万物互联</p><p>万维网是分布式超媒体系统，是超文本系统的扩充</p><p>在万维网客户程序与万维网服务器程序之间进行交互所使用的就是超文本传输协议 HTTP，这是一个应用层协议，基于 TCP 进行可靠传输</p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>万维网通过”链接”的方法能主动地按需获取信息，不同的信息通过 <strong>统一资源定位符 URL</strong> 来标识</p><p>URL 的格式如下</p><p><code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code></p><p>此处的协议可以是 http、ftp、file 等，但本文只介绍 http 协议相关内容</p><h2 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h2><p>HTTP 1.0 协议是无状态的，HTTP 本身也是无连接的，虽然使用了基于 TCP 的可靠传输，但是每次通过 TCP 传输完毕后，该 TCP 连接都会被关闭</p><p>作为改进，HTTP 1.1 协议使用持续连接，指在收到服务器响应后，连接仍会保持一段时间，同一个客户和该服务器之间可以继续使用这条连接进行通信</p><h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>URL 中的主机号可以是 IP 地址，或一个域名，或一个计算机地址标识符</p><p>域名系统 DNS（Domain Name System）提供了将人类可读符号映射到计算机地址的服务（计算机地址不止是 IP 地址）</p><p>域名与计算机地址之间的关系是多对一，即一个域名只能映射到一个计算机地址，但一个计算机地址可以被多个域名所映射</p><p>域名的结构为 <strong>层次树状结构</strong>，由标号序列组成，各部分之间用 点号 隔开</p><p>但是如何知道域名和计算机地址的映射关系？需要通过 DNS 服务器来进行解析</p><p>每个 DNS 服务器负责一个区，此时该 DNS 服务器称为 <strong>权限域名服务器</strong>，用来保存该区中所有主机的域名到 计算机地址 的映射</p><p>包括 权限域名服务器，DNS 服务器自顶向下共有以下类型</p><ol><li><p>根域名服务器</p><p>最重要的域名服务器。所有根域名服务器都知道所有顶级域名服务器的域名和 IP 地址</p><p>不论是哪一个本地域名服务器，只要这个本地域名服务器不能自己解析一个域名，就会首先求助根域名服务器</p></li><li><p>顶级域名服务器</p><p>负责管理在自己注册的所有二级域名</p><p>响应可能是域名解析结果，也可能是下一步应当询问的域名服务器地址</p></li><li><p>权限域名服务器</p><p>负责一个区的域名服务器</p><p>响应可能是域名解析结果，也可能是下一步应当询问的权限域名服务器地址</p></li><li><p>本地域名服务器，也称为默认域名服务器</p><p>一般是客户端主机上设置的首选 DNS 服务器，也称为 ISP DNS 服务器</p><p>当主机发出 DNS 查询请求时，该请求报文首先发送给本地域名服务器</p></li></ol><p>显然查询 DNS 的请求是要经过多级中转的。如何决定查询顺序呢？</p><p>有两个阶段</p><ol><li><p>递归查询：主机向本地域名服务器的查询</p><p>如果主机所询问的本地域名服务器不知道域名解析的结果，则本地域名服务器就以 DNS 客户的身份，向其他服务器继续发出查询请求报文</p></li><li><p>迭代查询：本地域名服务器向根域名服务器及其他域名服务器的查询</p><p>如果本地域名服务器所询问的根域名服务器不知道域名解析的结果，则告诉本地域名服务器下一个查询目标服务器的地址，由本地域名服务器继续提交请求</p></li></ol><p>示意图如下</p><p><img src="https://pic.ringoer.com/DNS查询.png" alt="DNS查询"></p><p>这是服务器上的 DNS 查询，但不是每次 DNS 查询都直接从本地域名服务器开始</p><p>DNS 查询流程按顺序一般如下</p><ol><li>浏览器缓存</li><li>操作系统缓存</li><li>路由器缓存</li><li>主机上的 hosts 文件</li><li>本地域名服务器…</li></ol><p>可以使用 <code>nslookup [addr]</code> 命令来解析目标域名</p><p>一个 nslookup 实例如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nslookup baidu.com</span><br><span class="line"></span><br><span class="line">服务器:  UnKnown</span><br><span class="line">Address:  192.168.1.1</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    baidu.com</span><br><span class="line">Addresses:  220.181.38.148</span><br><span class="line">          39.156.69.79</span><br></pre></td></tr></table></figure><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>此处特指软件意义上的端口，有别于交换机上的硬件端口</p><p>端口号一般是一个 16 为无符号整数，范围在 0 - 65536</p><p>一般 0 - 1023 号端口是服务保留端口，自己的项目最好不要启动在这些端口上，除非你知道自己在干什么</p><p>常用端口一般有 20、21、22、80、443 等</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>对于静态资源服务器，路径一般与服务器所在的磁盘目录一一对应</p><p>对于动态服务器，路径一般是个逻辑路径，用以标识资源</p><p>在动态服务器的路径，一般采用 RESTFUL API 设计，用 URI 标识资源，用 HTTP 动词描述动作</p><p>一般在路径的末尾都有一个斜杠，除非该路径指向一个具体的静态文件</p><h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><p>HTTP 有两类报文：请求报文（request）和响应报文（response）</p><p>由于 HTTP 是面向文本的，所以报文中每个字段都是 ASCII 码串，长度不确定</p><p>报文都分为开始行、首部行和实体主体，分别对应 Chrome 控制台中看到的 General、Headers 和 Payload</p><p>在请求报文中，开始行就是请求行</p><p>可以在本地命令行通过 <code>curl -v [url]</code> 查看报文信息</p><p>一个 curl 实例如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">curl -v baidu.com</span><br><span class="line"></span><br><span class="line">* Rebuilt URL to: baidu.com/</span><br><span class="line">*   Trying 220.181.38.148...</span><br><span class="line">* TCP_NODELAY <span class="built_in">set</span></span><br><span class="line">* Connected to baidu.com (220.181.38.148) port 80 (<span class="comment">#0)</span></span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; Host: baidu.com</span><br><span class="line">&gt; User-Agent: curl/7.55.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Fri, 27 Nov 2020 04:02:06 GMT</span><br><span class="line">&lt; Server: Apache</span><br><span class="line">&lt; Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">&lt; ETag: <span class="string">"51-47cf7e6ee8400"</span></span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt; Content-Length: 81</span><br><span class="line">&lt; Cache-Control: max-age=86400</span><br><span class="line">&lt; Expires: Sat, 28 Nov 2020 04:02:06 GMT</span><br><span class="line">&lt; Connection: Keep-Alive</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"refresh"</span> content=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">* Connection <span class="comment">#0 to host baidu.com left intact</span></span><br></pre></td></tr></table></figure><h2 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h2><p>显然请求方法是很重要的。通常有如下请求方法</p><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>OPTION</td><td>向服务器请求一些构成请求的关键选项，例如允许的方法</td></tr><tr><td>HEAD</td><td>向服务器询问，首部行中哪些头部是 required</td></tr><tr><td>GET</td><td>查</td></tr><tr><td>POST</td><td>增</td></tr><tr><td>PUT</td><td>改</td></tr><tr><td>PATCH</td><td>部分改</td></tr><tr><td>DELETE</td><td>删</td></tr><tr><td>TRACE</td><td>用于环回测试</td></tr><tr><td>CONNECT</td><td>用于代理服务器</td></tr></tbody></table><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>HTTP 状态码分为 5 大类</p><table><thead><tr><th>状态码</th><th>意义</th></tr></thead><tbody><tr><td>1xx</td><td>通知</td></tr><tr><td>2xx</td><td>成功</td></tr><tr><td>3xx</td><td>重定向</td></tr><tr><td>4xx</td><td>客户端出错</td></tr><tr><td>5xx</td><td>服务器出错</td></tr></tbody></table><p>常见的有 200、301、302、304、401、403、404、415、500、502 等</p><h1 id="SSL-协议"><a href="#SSL-协议" class="headerlink" title="SSL 协议"></a>SSL 协议</h1><p>SSL 只有一个重点，就是 RSA 加密，可以查看本文 <a href="https://ringoer.com/algorithm/rsa/" target="_blank" rel="noopener">图解非对称加密</a></p><p>接下来介绍一下物理层和数据链路层</p><p>待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍一些计算机网络相关的专业知识&lt;/p&gt;
    
    </summary>
    
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CSS动画</title>
    <link href="http://yoursite.com/frontend/css-animation/"/>
    <id>http://yoursite.com/frontend/css-animation/</id>
    <published>2020-11-24T16:15:00.000Z</published>
    <updated>2020-11-26T08:02:19.053Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 也具备原生的动画实现机制，可以在不使用或少使用 JS 的情况下做到动画的效果</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>CSS 动画是基于对盒模型的变形、变色等 2D变换 实现的</p><p>也就是说，其核心是 transform 属性</p><p>一般有三种方案</p><ol><li>定时器</li><li>transition 过渡</li><li>animation 动画</li></ol><p>显然动画是逐帧播放的，每一帧都依赖于浏览器渲染。于是先介绍一下浏览器渲染</p><h1 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h1><p>关于浏览器渲染的详细优化，可以查阅 <a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">渲染性能</a></p><p>首先介绍一个关键词：像素管道</p><h2 id="像素管道"><a href="#像素管道" class="headerlink" title="像素管道"></a>像素管道</h2><p>如图，这就是像素管道，表示渲染的全过程</p><p><img src="https://pic.ringoer.com/css-animation-render-5.jpg" alt=""></p><ul><li><strong>JavaScript</strong>。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如用 jQuery 的 <code>animate</code> 函数做一个动画、对一个数据集进行排序或者往页面里添加一些 DOM 元素等。当然，除了 JavaScript，还有其他一些常用方法也可以实现视觉变化效果，比如：CSS Animations、Transitions 和 Web Animation API。</li><li><strong>样式计算</strong>。此过程是根据匹配选择器（例如 <code>.headline</code> 或 <code>.nav &gt; .nav__item</code>）计算出哪些元素应用哪些 CSS 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。</li><li><strong>布局</strong>。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 <code>&lt;body&gt;</code> 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。</li><li><strong>绘制</strong>。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。</li><li><strong>合成</strong>。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。</li></ul><p>并非每次渲染都会触发全部的 5 个过程，大致分为如下 3 种</p><ol><li><p>JS / CSS &gt; 样式 &gt; 布局 &gt; 绘制 &gt; 合成</p><p><img src="https://pic.ringoer.com/css-animation-render-5.jpg" alt=""></p><p>当修改了元素的几何属性时，会触发重新布局，所以 5 个过程都会执行</p></li><li><p>JS / CSS &gt; 样式 &gt; 绘制 &gt; 合成</p><p><img src="https://pic.ringoer.com/css-animation-render-4.jpg" alt=""></p><p>如果只是修改了背景图片、文字颜色等仅依赖绘制的属性，即不会影响布局，则浏览器会跳过布局，但仍将执行绘制</p></li><li><p>JS / CSS &gt; 样式 &gt; 合成</p><p><img src="https://pic.ringoer.com/css-animation-render-3.jpg" alt=""></p><p>如果更改的属性是一个既不需要布局也不需要绘制的属性，则浏览器将直接跳到合成</p><p>第 3 种情况的开销最小，最适合于应用生命周期中的高压力点，例如动画或滚动</p></li></ol><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>首次布局，称之为 布局（layout）</p><p>之后的修改布局，称之为 回流 或 重排（reflow）</p><p>重排，即元素的几何属性被修改，导致浏览器重新执行整个渲染流程</p><p>由上图情况 1 可得，重排必定引发重绘</p><h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>首次绘制，称之为 绘制（paint）</p><p>之后的修改表现，称之为 重绘（repaint）</p><p>重绘，即背景图片、文字颜色等仅依赖绘制的属性被修改，导致浏览器重新绘制所需的颜色等</p><p>由上图情况 1 和 2 可得，引发重绘的时候不一定发生重排</p><h2 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h2><p>已经算完了，只要同步到页面上就可以了，这就是合成，所以不能跳过</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>那怎么知道什么属性会不会引发重排或重绘呢？可以查看 <a href="https://csstriggers.com/" target="_blank" rel="noopener">CSS Triggers</a></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Chrome 提供了工具，来帮助开发者确定什么时候发生了重绘</p><p>打开工具的流程如下</p><ol><li><p>F12 打开开发者工具</p></li><li><p>在 HTML 和 CSS 界面，按 ESC 打开 console 界面</p></li><li><p>按 console 界面左上角的更多，打开 Rendering 面板</p></li><li><p>勾选 Paint flashing，即可观察到浏览器在每次发生重绘时，重绘的部分发绿</p><p>设置如图</p><p><img src="https://pic.ringoer.com/css-animation-rendering.png" alt=""></p><p>也可以查看 Chrome 的文档 <a href="https://developers.google.com/web/fundamentals/performance/rendering/simplify-paint-complexity-and-reduce-paint-areas#%E4%BD%BF%E7%94%A8_chrome_devtools_%E5%BF%AB%E9%80%9F%E7%A1%AE%E5%AE%9A%E7%BB%98%E5%88%B6%E7%93%B6%E9%A2%88" target="_blank" rel="noopener">使用 Chrome DevTools 快速确定绘制瓶颈</a></p></li></ol><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>可以通过定时器，为某个盒子设置定时变换</p><p>一般有三种定时器</p><ol><li>setTimeout</li><li>setInterval</li><li>requestAnimationFrame</li></ol><p>其中 1 和 2 的用法相同，类似如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    div.style.cssText=<span class="string">'transform: translate(100px,200px)'</span>;</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>setTimeout 和 setInterval 方法都会返回一个 long 整数，表示计时器 ID</p><p>可以使用 cancelTimeout(id) 或 cancelInterval(id) 来取消计时器</p><p>但是使用 setTimeout 的动画，不是统一管理动画帧，而是分别渲染的，所以会导致有时候这一帧还没渲染好，下一帧的请求又来了，会造成丢帧的问题</p><p>所以更建议使用 requestAnimationFrame 来管理动画</p><p>requestAnimationFrame 的方法原型是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestAnimationFrame(callback)</span><br></pre></td></tr></table></figure><p>要求传入一个回调函数，并在执行时向回调函数内传入一个 long 整数，表示时间戳</p><p>requestAnimationFrame 默认的执行间隔约 16.67 ms，约每秒 60 帧</p><p>可以在回调函数内通过时间戳判断是否应该准备渲染下一帧</p><p>与 setTimeout 同样的是，requestAnimationFrame 返回值也是一个 long 整数，表示计时器 ID</p><p>可以使用 cancelAnimationFrame(id) 来取消计时器</p><p>范例可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">MDN window.requestAnimationFrame</a> 或 <a href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution#%E4%BD%BF%E7%94%A8_requestanimationframe_%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%A7%86%E8%A7%89%E5%8F%98%E5%8C%96" target="_blank" rel="noopener">使用 requestAnimationFrame 来实现视觉变化</a></p><h1 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h1><p>第二种办法是使用 CSS transition 属性，令元素在两个状态之间过渡</p><p>一般用于制作悬浮等特效，呈现动画效果，而不是真正意义上的动画</p><p>查看 transition 的相关效果，可以访问 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition" target="_blank" rel="noopener">MDN transition</a></p><p>transition 一般有如下 4 个参数</p><ol><li><p>property name（required），指示监视的属性名，当该属性在指定两个状态之间发生变化的时候触发过渡效果</p><p>可以指定该属性取值为 all，表示监视该 css 选择器选中元素的所有属性</p></li><li><p>duration（required），指示过渡动画的播出时间</p></li><li><p>delay，指示过渡效果在触发时，先延迟 delay 时长，再开始播放过渡效果</p></li><li><p>timing function，指示过渡效果的变化速率曲线，默认是 ease，可以指定为 linear（线性）</p></li></ol><p>如上参数并排写，只需要用空格隔开</p><p>默认第一个出现的时间指示的是 duration，第二个才是 delay</p><p>当有多个 property 需要监视时，可以用逗号隔开参数语句</p><h1 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h1><p>第三种办法是使用 CSS animation 属性，令元素在若干个状态之间连续变化</p><p>与 transition 的区别是，transition 不能在没有触发条件的情况下播放，但 animation 不仅可以做到 transition 能做到的，还可以自动无限播放</p><p>查看 animation 的相关效果，可以访问 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation" target="_blank" rel="noopener">MDN animation</a></p><p>animation 一般有如下 8 个参数</p><ol><li>keyframe name（required），指示使用的动画帧定义</li><li>duration（required），指示动画的播出时间</li><li>delay，指示动画效果在触发时，先延迟 delay 时长，再开始播放动画效果</li><li>timing function，指示动画效果的变化速率曲线，默认是 ease，可以指定为 linear（线性）</li><li>iteration count，指示动画播出的次数，默认是 1，可以修改为 infinite</li><li>direction，指示动画播出的方向，默认是 normal，可以修改为 reverse 反向播放，或 alternate 表示来回播放</li><li>fill mode，指示动画播放结束时保留的帧，默认是 none，不保留任何帧，可以设置为 forwards 保留最后一帧，或 backwards 保留第一帧，或 both 在两个方向上扩展动画</li><li>play state，指示一个动画所处的状态，默认是 running，可以通过 JS 设置为 paused 来暂停动画，重新修改为 running 则会在暂停的位置继续播放</li></ol><p>显然，animation 属性规定了动画在播放时的参数，但还需要另外指定关键帧</p><p>在 transition 中是根据不同的动作触发，在 animation 中则是用 @keyframes 关键字定义</p><p>@keyframes 一般有如下两种写法</p><ol><li><p>from-to写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> slidein &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(0%); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让 animation 在起始和末尾的两个帧之间变化</p></li><li><p>百分比写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> identifier &#123;</span><br><span class="line">  0% &#123; <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>; &#125;</span><br><span class="line">  30% &#123; <span class="attribute">top</span>: <span class="number">50px</span>; &#125;</span><br><span class="line">  50% &#123; <span class="attribute">top</span>: <span class="number">30px</span>; <span class="attribute">left</span>: <span class="number">20px</span>; &#125;</span><br><span class="line">  50% &#123; <span class="attribute">top</span>: <span class="number">10px</span>; &#125;</span><br><span class="line">  68%, 72% &#123; <span class="attribute">left</span>: <span class="number">50px</span>; &#125;</span><br><span class="line">  100% &#123; <span class="attribute">top</span>: <span class="number">100px</span>; <span class="attribute">left</span>: <span class="number">100%</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让动画在生命周期的不同节点呈现不同的效果</p><p>相同节点重复定义，会以最后一次定义为准，如第 4 和第 5 行，只有第 5 行会生效</p><p>相同效果可以用逗号隔开，如第 6 行</p></li></ol><p>以上，就是 CSS 动画相关的效果</p><p>关于优化等问题，需要配合 JS，此处就不描述了</p><p>谢谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 也具备原生的动画实现机制，可以在不使用或少使用 JS 的情况下做到动画的效果&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局</title>
    <link href="http://yoursite.com/frontend/css-layout/"/>
    <id>http://yoursite.com/frontend/css-layout/</id>
    <published>2020-11-23T16:15:00.000Z</published>
    <updated>2020-11-24T16:02:08.287Z</updated>
    
    <content type="html"><![CDATA[<p>现代网站都需要各种布局以保证页面展示效果，本文就说说布局</p><a id="more"></a><h1 id="布局类型"><a href="#布局类型" class="headerlink" title="布局类型"></a>布局类型</h1><h2 id="视觉类型"><a href="#视觉类型" class="headerlink" title="视觉类型"></a>视觉类型</h2><p>不同布局看起来的效果不一样</p><p>主要有 3 种</p><ol><li>两栏布局，很少单独使用了，一般用在给三栏布局的中间部分做两栏布局</li><li>三栏布局（多栏布局同三栏思路），如淘宝首页，两侧留空，中间保有内容</li><li>平均布局，如淘宝首页下方的 猜你喜欢，平均排列各种商品</li></ol><h2 id="技术类型"><a href="#技术类型" class="headerlink" title="技术类型"></a>技术类型</h2><p>可以选用不同的方案实现布局</p><p>主要有 4 种</p><ol><li>纯文档流布局</li><li>float 浮动布局</li><li>flex 弹性盒子布局</li><li>grid 网格布局</li></ol><p>本文以技术类型为轴，分别尝试实现 3 种视觉类型</p><p>本文中的两栏布局采用如下设计图</p><p><img src="https://pic.ringoer.com/css-layout-0.png" alt=""></p><p>如图，画得不太准，认为是方形就好了，同时为了展示效果，在代码中会放大 10 倍</p><p>三栏布局采用 <a href="https://www.taobao.com/" target="_blank" rel="noopener">淘宝首页</a> 作为示例</p><p>平均布局采用 <a href="https://www.bilibili.com/" target="_blank" rel="noopener">bilibili</a> 番剧区作为示例</p><h1 id="纯文档流"><a href="#纯文档流" class="headerlink" title="纯文档流"></a>纯文档流</h1><p>纯文档流布局，利用了文档流本身的特点——表现为块级的元素逐行排列，表现为内联的元素同行自左向右排列</p><h2 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h2><p>由图片可得，大致有如下结构的 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"large"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"small"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"small"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用如下 CSS，即可完成两栏布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125; <span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">/* 去除两列之间的空白 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span>&gt;<span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-class">.main</span>&gt;<span class="selector-tag">div</span>&gt;<span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125; <span class="comment">/* 令 class=main 下的子 div 和孙 div 都获得边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block; <span class="comment">/* 使得左右两列并排 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 之后在左右盒子中分别逐行排列即可 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.large</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.small</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="https://pic.ringoer.com/css-layout-1.png" alt=""></p><h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><p>显然只需要在 body 中放置 3 个块</p><p>于是可以推出如下 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用如下 CSS，即可完成三栏布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125; <span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">/* 去除底部空白 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&gt;* &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125; <span class="comment">/* 使得三个块并排 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60vw</span>;</span><br><span class="line">&#125; <span class="comment">/* 使得 main 获得大小和边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 分别设定左右宽度 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20vw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="https://pic.ringoer.com/css-layout-2.png" alt=""></p><p><img src="https://pic.ringoer.com/css-layout-3.png" alt=""></p><p>可见随着视口变小，中间部分也会自适应</p><h2 id="平均布局"><a href="#平均布局" class="headerlink" title="平均布局"></a>平均布局</h2><p>平均布局一般都设定了每个单位所占大小，所以一般分为占满全行和占不满两种</p><p>而占不满的话，在多行场合下末行又会很难看，所以一般都是占满全行</p><p>设每个块大小为 width = height = 200px，每行 4 个块，放在刚才的三栏布局的 main 元素中</p><p>那么显然，为了维持每行 4 个块，应该取消响应式</p><p>鉴于之前说过的 margin 的同行不合并特性，一般只会设置单方向（通常为 right）的 margin</p><p>设每两个块之间隔开的距离为 x，显然 4 <em> 200px + 3 </em> x = main.width - main.border.width * 2</p><p>设 x = 30px，则 main.width = 892px</p><p>可以推出如下 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用以下 CSS，即可实现占满全行的效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 去除底部空白 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使得三个块并排 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&gt;* &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使得 main 获得大小和边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">892px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分别设定左右宽度 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>((100vw - 892px) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>((100vw - 892px) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.entity</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="https://pic.ringoer.com/css-layout-4.png" alt=""></p><p>发现惨了！怎么换行了！</p><p>从开发者工具可以看到，是因为每行最后一个 div 的右外边距超出容器了，所以被换行，这时候，我们需要添加如下 CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 去除底部空白 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使得三个块并排 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&gt;* &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使得 main 获得大小和边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">892px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分别设定左右宽度 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>((100vw - 892px) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>((100vw - 892px) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.entity</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择第 4 个 entity div 并取消其右外边距 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.column</span>&gt;<span class="selector-class">.entity</span><span class="selector-pseudo">:nth-child(4)</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或选用对容器进行调整的 CSS，更高级，更受面试官喜爱</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 去除底部空白 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使得三个块并排 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&gt;* &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使得 main 获得大小和边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">892px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分别设定左右宽度 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>((100vw - 892px) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>((100vw - 892px) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.entity</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令行末的右外边距折返 30px */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.column</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="https://pic.ringoer.com/css-layout-5.png" alt=""></p><p>但是现在纯文档流布局已经没人用了，除非你的网站需要在 IE 6 以下运行……</p><h1 id="float"><a href="#float" class="headerlink" title="float"></a>float</h1><p>通过 caniuse，我们知道对于 IE，float 可以运行在 IE 6 7 8 9 10 11 上，除非 6 以下才需要使用纯文档流布局</p><p>而 flex 在 IE 6 7 8 9 上都不能使用，10 和 11 的兼容性也不是完全兼容</p><p>所以，假如你还需要兼容 IE，最好使用 float 布局</p><h2 id="两栏布局-1"><a href="#两栏布局-1" class="headerlink" title="两栏布局"></a>两栏布局</h2><p>由图片可得，大致有如下结构的 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main clearfix"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"large"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"small"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"small"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用如下 CSS，即可完成两栏布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 去除两列之间的空白 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span>&gt;<span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-class">.main</span>&gt;<span class="selector-tag">div</span>&gt;<span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令 class=main 下的子 div 和孙 div 都获得边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令 left 和 right 都向左浮动 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 之后在左右盒子中分别逐行排列即可 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.large</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.small</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于清除浮动，否则会发现父元素的高度变成了 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图与纯文档流相同</p><p><img src="https://pic.ringoer.com/css-layout-1.png" alt=""></p><p>从 CSS 可见，如果同层级的两个元素都是向左浮动的话，则排列顺序按照其在文档中的出现顺序</p><p>当然也可以令右边盒子向右浮动，此时右边盒子会出现在父元素的最右边，具体位置取决于父元素宽度</p><p>在本例中，如果父元素宽度为 800px，则与向左浮动表现相同</p><h2 id="三栏布局-1"><a href="#三栏布局-1" class="headerlink" title="三栏布局"></a>三栏布局</h2><p>显然只需要在 body 中放置 3 个块</p><p>于是可以推出如下 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用如下 CSS，即可完成三栏布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使得 main 获得大小和边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid white;</span><br><span class="line">    <span class="comment">/* 若不设定边框，则会观察到左右空白的宽度都变为 0，但可以设置白色边框保持左边空白 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="comment">/* 右边不需要设置边框，因为排列是从左向右的，除非 main 的 float = right */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于清除浮动，否则会发现父元素的高度变成了 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图与纯文档流相同</p><p><img src="https://pic.ringoer.com/css-layout-2.png" alt=""></p><h2 id="平均布局-1"><a href="#平均布局-1" class="headerlink" title="平均布局"></a>平均布局</h2><p>float 实现平均布局的代码和效果，与纯文档流几乎一致，除了 <code>clearfix</code>，就只是把</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br></pre></td></tr></table></figure><p>换成了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">float</span>: <span class="selector-tag">left</span>;</span><br></pre></td></tr></table></figure><p>而已</p><p>关于右外边距溢出容器的处理，也与纯文档流一致</p><p>故此处不再给出示例</p><h1 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h1><p>通过 caniuse 可以发现，除了 IE 之外的所有浏览器最新版本均支持 flex，但 grid 布局尚未受到全面支持</p><p>所以当你不需要兼容 IE，但又不是只需要兼容最新的浏览器时，可以选择 flex 布局方案</p><p>附一个 flex 布局小游戏</p><p><a href="https://flexboxfroggy.com/#zh-cn" target="_blank" rel="noopener">FLEXBOX FROGGY</a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool(%E8%AF%AD%E6%B3%95%E7%AF%87" target="_blank" rel="noopener">Flex 布局教程：语法篇</a>)</p><p>flex 有两个主要概念：容器（container）和项目（item）</p><p>一个容器中包含两条轴：主轴和交叉轴，交叉轴恒垂直于主轴。默认主轴是水平方向</p><p>一个容器中往往包含多个项目，项目沿主轴排列</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器上可以设置 6 个属性</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><p>属性含义不解释了，本文不是教语法的，是教布局的，可以点击阮一峰博客学习语法</p><p>下同，不讲语法</p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>项目上可以设置 6 个属性</p><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><h2 id="两栏布局-2"><a href="#两栏布局-2" class="headerlink" title="两栏布局"></a>两栏布局</h2><p>显然扭转主轴方向到竖直方向，更有利于排版</p><p>所以由图片可得，大致有如下结构的 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"large"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"small"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"small"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用如下 CSS，即可完成两栏布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令 class=main 下的子 div 和孙 div 都获得边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span>&gt;<span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-class">.main</span>&gt;<span class="selector-tag">div</span>&gt;<span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令主盒子成为弹性盒子容器，使得左右盒子沿默认主轴（水平方向）排列 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="comment">/* 令左右盒子都成为弹性盒子容器 */</span></span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="comment">/* 更改主轴方向 */</span></span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 之后在左右盒子中分别设置大小即可 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.large</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.small</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图与纯文档流相同</p><p><img src="https://pic.ringoer.com/css-layout-1.png" alt=""></p><h2 id="三栏布局-2"><a href="#三栏布局-2" class="headerlink" title="三栏布局"></a>三栏布局</h2><p>显然只需要在 body 中放置 3 个块</p><p>于是可以推出如下 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用如下 CSS，即可完成三栏布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使得 body 成为弹性盒子容器，让三个区域都沿默认主轴（水平方向）排列 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使得 main 获得大小和边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图与纯文档流相同</p><p><img src="https://pic.ringoer.com/css-layout-2.png" alt=""></p><p>代码明显比 float 简洁许多，所以是比 float 更好用的布局方案</p><h2 id="平均布局-2"><a href="#平均布局-2" class="headerlink" title="平均布局"></a>平均布局</h2><p>设每个块大小为 width = height = 200px，每行 4 个块，放在刚才的三栏布局的 main 元素中</p><p>可以推出如下 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用以下 CSS，即可实现占满全行的效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使得 body 成为弹性盒子容器，让三个区域都沿默认主轴（水平方向）排列 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使得 main 获得大小和边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.column</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">15vw</span>;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.entity</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="https://pic.ringoer.com/css-layout-6.png" alt=""></p><p>发现，坏了，怎么最后一行隔开这么远</p><p>于是我们便不能使用 <code>justify-content</code> 来简单控制间距，必须使用 <code>margin-right</code> 来控制</p><p>计算结果沿用纯文档流布局的计算结果</p><p>于是 CSS 变更为如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 去除底部空白 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使得三个块并排 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&gt;* &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使得 main 获得大小和边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">892px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分别设定左右宽度 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>((100vw - 892px) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>((100vw - 892px) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令行末的右外边距折返 30px */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.column</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.entity</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="https://pic.ringoer.com/css-layout-7.png" alt=""></p><p>好了，使用负 margin，成功修复！</p><p>当然 nth-child 也可以，不过不建议</p><h1 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h1><p>通过 caniuse 可以发现，grid 布局尚未受到全面支持</p><p>所以当你只需要兼容最新的，甚至是未来的浏览器时，可以选择 grid 布局方案</p><p>附一个 grid 布局小游戏</p><p><a href="https://cssgridgarden.com/#zh-cn" target="_blank" rel="noopener">GRID GARDEN</a></p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">CSS Grid 网格布局教程</a></p><p>容器和项目的概念同 flex，但是 grid 没有主轴和交叉轴</p><p>如果说 flex 的精力集中在每个容器的主轴上，是一维操作，那 grid 布局就是二维操作</p><h3 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h3><p>容器上可以设置 7 种属性</p><ul><li><p>grid-template-columns/rows/areas</p></li><li><p>column/row-gap</p></li><li><p>gap</p></li><li><p>grid-auto-flow</p></li><li><p>justify/align/place-items</p></li><li><p>justify/align/place-content</p></li><li><p>grid-auto-columns/rows</p></li></ul><h3 id="项目-1"><a href="#项目-1" class="headerlink" title="项目"></a>项目</h3><p>项目上可以设置 3 种属性</p><ul><li>grid-column/row-start/end</li><li>grid-column/row/area</li><li>justify/align/place-self</li></ul><h2 id="两栏布局-3"><a href="#两栏布局-3" class="headerlink" title="两栏布局"></a>两栏布局</h2><p>由图片可得，大致有如下结构的 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"large"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"small1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"small2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用如下 CSS，即可完成两栏布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令 class=main 下的子 div 和孙 div 都获得边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span>&gt;<span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-class">.main</span>&gt;<span class="selector-tag">div</span>&gt;<span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令主盒子成为 grid 容器 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">400px</span> <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(9, 100px);</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: <span class="string">'large middle1'</span></span><br><span class="line">        <span class="string">'large middle1'</span></span><br><span class="line">        <span class="string">'large middle1'</span></span><br><span class="line">        <span class="string">'large middle2'</span></span><br><span class="line">        <span class="string">'large middle2'</span></span><br><span class="line">        <span class="string">'small1 middle2'</span></span><br><span class="line">        <span class="string">'small1 middle3'</span></span><br><span class="line">        <span class="string">'small2 middle3'</span></span><br><span class="line">        <span class="string">'small2 middle3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.large</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: large;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.small1</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: small1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.small2</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: small2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.middle1</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: middle1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.middle2</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: middle2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.middle3</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: middle3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图与纯文档流相同</p><p><img src="https://pic.ringoer.com/css-layout-1.png" alt=""></p><p>语义化非常好，一看就知道布局长什么样</p><h2 id="三栏布局-3"><a href="#三栏布局-3" class="headerlink" title="三栏布局"></a>三栏布局</h2><p>显然只需要在 body 中放置 3 个块</p><p>于是可以推出如下 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用如下 CSS，即可完成三栏布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令 div 都获得边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令主盒子成为 grid 容器 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">3</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: <span class="string">'left center right'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://pic.ringoer.com/css-layout-8.png" alt=""></p><p>这令人惊叹的高度语义化，比 flex 高到不知道哪去了</p><h2 id="平均布局-3"><a href="#平均布局-3" class="headerlink" title="平均布局"></a>平均布局</h2><p>设每个块大小为 width = height = 200px，每行 4 个块，放在刚才的三栏布局的 main 元素中</p><p>可以推出如下 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用以下 CSS，即可实现占满全行的效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令 div 都获得边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令主盒子成为 grid 容器 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">3</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: <span class="string">'left center right'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: center;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(4, 1fr);</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(auto-fill, 200px);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="https://pic.ringoer.com/css-layout-9.png" alt=""></p><p>完美的自动占格子，不再有负 margin 的问题</p><p>即便需要间隔，也可以通过 gap 来实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令 div 都获得边框，便于观察 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令主盒子成为 grid 容器 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">3</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: <span class="string">'left center right'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: center;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(4, 1fr);</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(auto-fill, 200px);</span><br><span class="line">    <span class="attribute">column-gap</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">row-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="https://pic.ringoer.com/css-layout-10.png" alt=""></p><p>天不生我 grid 布局，万古如长夜！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代网站都需要各种布局以保证页面展示效果，本文就说说布局&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>浏览器请求机制</title>
    <link href="http://yoursite.com/frontend/browser-request-mechanism/"/>
    <id>http://yoursite.com/frontend/browser-request-mechanism/</id>
    <published>2020-11-23T05:43:00.000Z</published>
    <updated>2020-12-12T14:33:30.917Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，前端的内容一般都是通过 HTTP 相关协议获取，并在浏览器上呈现的</p><a id="more"></a><p>要想深刻了解浏览器的请求机制，首先要有一定的 <a href="https://ringoer.com/knowledge/computer-network/" target="_blank" rel="noopener">计算机网络基础</a></p><h1 id="浏览器的请求流程"><a href="#浏览器的请求流程" class="headerlink" title="浏览器的请求流程"></a>浏览器的请求流程</h1><p>显然，我们要先了解一下，当我们访问一个网页时，浏览器都做了什么</p><p>浏览器执行了以下动作</p><ol><li>URL 解析，判断用户输入的是什么，自动组装请求</li><li>查看本地缓存，是否有已经缓存的该地址的资源，若未过期则直接取用，跳到处理 HTML 文档</li><li>DNS 查询，获得服务器地址</li><li>与服务器建立 TCP 连接，如果是 HTTPS 协议，还会有密钥交换</li><li>向服务器发送 HTTP 或 HTTPS 请求</li><li>服务器如果回复了一个永久重定向（301）或临时重定向（302），则浏览器需要向新的地址重新发送请求</li><li>服务器处理请求并响应，此时浏览器收到的响应状态码可能是 200 或 304</li><li>浏览器开始处理 HTML 文档，根据 HTML 文档生成 DOM 树和 CSSOM 树</li><li>合并两棵树，得到渲染树</li><li>根据渲染树，开始执行渲染五步骤</li></ol><p>总的来说，涉及以下知识点</p><ol><li>缓存机制</li><li>DNS 查询</li><li>TCP 连接</li><li>HTTP 与 HTTPS</li><li>页面渲染</li></ol><h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><p>显然网络请求是非常消耗时间的</p><p>有没有办法能减少网络请求呢？答案就是缓存</p><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>首先要了解一下缓存保存在哪里，浏览器又是如何索引缓存的</p><p>按照访问顺序，缓存一般有如下 4 个存储位置</p><ol><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ol><h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能<br>使用 Service Worker 的话，传输协议必须为 HTTPS，因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全<br>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的</p><h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p>也就是内存缓存，包含一些小文件</p><p>但一旦关掉当前标签页，该标签页对应的内存缓存就被释放了</p><h3 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h3><p>硬盘缓存，显然比内存缓存要慢，但存储空间要大，且只有资源过期了才会释放资源</p><p>一般大文件会放到 Disk Cache 中，小文件放到 Memory Cache 中</p><p>但如果当前系统内存占用高，则会优先存进 Disk Cache</p><h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>是 HTTP 2 中的 <strong>服务端推送</strong> 产生的缓存，只在 session 中存在，且缓存时间也很短（在 Chrome 中约 5 分钟）</p><p>关于其优点，详见 HTTP 2 的特点描述</p><h2 id="缓存过程"><a href="#缓存过程" class="headerlink" title="缓存过程"></a>缓存过程</h2><p>浏览器会根据以下流程，确定缓存的处理方法</p><p>URL 解析后，是否含有目标地址的缓存？</p><ul><li><p>否</p><ul><li>向服务器发送请求</li><li>返回请求结果和缓存标识，将结果存入缓存</li></ul></li><li><p>是</p><p> 缓存是否过期？</p><p> 根据 Expires ( HTTP 1.0 ) 或 Cache-Control ( HTTP 1.1 ) 判断</p><ul><li>是（协商缓存机制）<ul><li>在头部添加字段 If-Modified-Since ( HTTP 1.0 ) 或 If-None-Match ( HTTP 1.1 ) ，然后向服务器发送请求</li><li>服务器根据字段值判断资源是否有更新，并响应给浏览器</li><li>资源是否更新？<ul><li>是，则连带 HTML 文档一同返回给浏览器，同时状态码置为 200，浏览器将请求结果存入缓存</li><li>否，返回状态码 304，读取并返回缓存</li></ul></li></ul></li><li>否（强缓存机制）<ul><li>读取并返回缓存</li></ul></li></ul></li></ul><p>缓存机制图示如下</p><p><img src="https://pic.ringoer.com/缓存机制.png" alt="缓存机制"></p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>缓存未过期，则不会向服务器发送请求，直接读取并返回缓存</p><p>该操作会在控制台产生一个假请求，返回状态码 200，并显示 from memory cache 或 from disk cache</p><p>由上图可见，有两个参数可以决定强缓存</p><ol><li>Expires</li><li>Cache-Control</li></ol><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>是 HTTP 1 的产物</p><p>由服务端指定具体多久之后过期，关键字段名为 max-age，实际的 Expires = max-age + 服务器收到请求的时间</p><p>显然，Expires 是否过期，取决于与本地时间的对比结果，所以如果设置本地时间为超过 Expires 的值，则会直接造成 Expires 过期</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>是 HTTP 1.1 的产物</p><p>一般有以下字段</p><table><thead><tr><th>字段名</th><th>参考值</th><th>作用</th></tr></thead><tbody><tr><td>public</td><td>无</td><td>客户端和代理服务器均可以缓存该资源</td></tr><tr><td>private</td><td>无</td><td>只有客户端可以缓存该资源</td></tr><tr><td>max-age</td><td>30</td><td>缓存 30 秒后过期</td></tr><tr><td>s-maxage</td><td>30</td><td>覆盖 max-age，但只在代理服务器中生效</td></tr><tr><td>no-store</td><td>无</td><td>不缓存</td></tr><tr><td>no-cache</td><td>无</td><td>资源被缓存，但立即过期，下次请求会发起协商缓存认证</td></tr><tr><td>max-stale</td><td>30</td><td>30 秒内即使过期也使用该缓存</td></tr><tr><td>min-fresh</td><td>30</td><td>希望在 30 秒内获取最新的响应</td></tr></tbody></table><p>推荐的配置思路图如下</p><p><img src="https://pic.ringoer.com/Cache-Control推荐设置.png" alt=""></p><p>在使用 Cache-Control 的时候，有两种常见情况，其描述和对策如下</p><table><thead><tr><th>情况</th><th>对策</th><th>描述</th></tr></thead><tbody><tr><td>资源频繁更新</td><td>Cache-Control: no-cache</td><td>永不缓存，确保时效性</td></tr><tr><td>资源不常更新</td><td>Cache-Control: max-age=31536000</td><td>缓存一年</td></tr></tbody></table><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>由上文可知，Cache-Control 是更新版本的参数，也具有更强大的功能，所以当 Cache-Control 和 Expires 同时存在时，Cache-Control 优先级要高于 Expires</p><p>现在的 Expires，只是为了兼容不支持 HTTP 1.1 的环境罢了</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>当强缓存查找不到未过期的合适缓存，但存在已过期的合适缓存时，浏览器会采用协商缓存策略</p><p>一般有两种情况</p><ol><li>协商缓存有效，服务器返回 304 Not Modified</li><li>协商缓存失效，服务器返回 200 和新的资源</li></ol><p>那么如何提交协商缓存请求呢？可以通过设置两组参数实现</p><h3 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h3><p>是 HTTP 1 提出的缓存控制参数</p><p>浏览器在第一次访问资源时，服务器可以在响应中加入请求头 Last-Modified，值是这个资源在服务器上的最后修改时间</p><p>浏览器下次强缓存命中失败，要请求这个资源时，发现这个已过期资源带有 Last-Modified 标识，则会在请求中带上 If-Modified-Since 的 header</p><p>服务器收到 If-Modified-Since 后，与服务器上的资源对比，如果 If-Modified-Since 的时间小于服务器上该资源的最后更新时间，则说明资源有更新，服务器返回 200 和新的资源文件，否则仅返回 304</p><p>但如果客户在本地打开缓存文件，即使没有修改，也依然会造成 Last-Modified 更新，此时会导致缓存失效</p><p>并且，Last-Modified 的精确度是秒，所以如果在小于秒的时间内修改了文件，Last-Modified 并不会更新，导致命中的文件不正确</p><p>所以，HTTP 1.1 提出了更加精确的验证参数，Etag 和 If-None-Match</p><h3 id="Etag-和-If-None-Match"><a href="#Etag-和-If-None-Match" class="headerlink" title="Etag 和 If-None-Match"></a>Etag 和 If-None-Match</h3><p>浏览器在第一次访问资源时，服务器可以在响应中加入请求头 Etag，值是这个资源在服务器上的唯一标识。只要文件发生变化，Etag 就会重新生成</p><p>如同 Last-Modified，浏览器在使用 Etag 进行协商缓存时，也会在请求中加入特殊的 header，此时这个 header 为 If-None-Match</p><p>如果 If-None-Match 与服务器上的文件标识符相同，则返回 304，否则返回 200 和新的资源文件</p><h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3><p>显然 Etag 要比 Last-Modified 更精确，但精确的代价就是生成标识符的算法的复杂性增大</p><p>但大部分情况下，Etag 造成的性能损耗都可以忽略不计，所以当 Etag 和 Last-Modified 同时存在时，Etag 的优先级较高</p><h3 id="无缓存策略"><a href="#无缓存策略" class="headerlink" title="无缓存策略"></a>无缓存策略</h3><p>如果服务器什么缓存都没设置，难道就不缓存了吗？显然不是</p><p>此时浏览器会取响应报文中的 Date 来减去 Last-Modified，取得一个时间差值，然后取这个差值的 10% 作为缓存时间</p><h1 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h1><p>DNS 查询流程按顺序一般如下</p><ol><li>浏览器缓存</li><li>操作系统缓存</li><li>路由器缓存</li><li>主机上的 hosts 文件</li><li>本地域名服务器等域名服务器</li></ol><h1 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h1><p>流程中说到，浏览器与服务器之间会建立 TCP 连接来传输数据，那么显然具有至少一个 TCP 连接</p><p>那么自然产生了以下问题</p><ol><li>一个 TCP 连接能用多久？什么时候断开？</li><li>一个 TCP 连接可以承担几个 HTTP 请求的任务？</li><li>一个 TCP 连接能不能同时发送数个 HTTP 请求？</li><li>浏览器最多能对同一服务器建立几个 TCP 连接？</li></ol><h2 id="一个-TCP-连接能用多久"><a href="#一个-TCP-连接能用多久" class="headerlink" title="一个 TCP 连接能用多久"></a>一个 TCP 连接能用多久</h2><p>在 HTTP 1 中，服务器会在响应了一个 HTTP 请求后，立刻断开这个 TCP 连接</p><p>但如果要对该服务器连续发起多个请求，重复建立连接显然开销过大</p><p>于是开始有某些服务器，提出了不在 HTTP 标准中的头部字段 Connection，并通过设置 Connection: keep-alive 来保持当前请求使用的 TCP 连接不断开</p><p>因为 SSL 也是基于 TCP 的，所以此时 SSL 连接也不会断开，不需要重新交换密钥和验证</p><p>既然 Connection: keep-alive 这么好用，于是 HTTP 1.1 就将其加入了标准之中，并且默认保持 TCP 连接，除非手动在请求头中指定 Connection: close</p><h2 id="一个-TCP-连接可以承担几个-HTTP-请求的任务"><a href="#一个-TCP-连接可以承担几个-HTTP-请求的任务" class="headerlink" title="一个 TCP 连接可以承担几个 HTTP 请求的任务"></a>一个 TCP 连接可以承担几个 HTTP 请求的任务</h2><p>从上一个问题，显然可以看出，如果一个 TCP 连接不断开，是可以用来发送多个 HTTP 请求的，直到断开为止</p><h2 id="一个-TCP-连接能不能同时发送数个-HTTP-请求"><a href="#一个-TCP-连接能不能同时发送数个-HTTP-请求" class="headerlink" title="一个 TCP 连接能不能同时发送数个 HTTP 请求"></a>一个 TCP 连接能不能同时发送数个 HTTP 请求</h2><p>在 HTTP 1.1 中，一个 TCP 连接同时只能处理一个请求，不同请求不能同时使用同一个 TCP 连接</p><p>虽然标准中设计了一个参数 Pipelining 来试图解决这个问题，但是了解网络工作原理的人都知道，客户端按某个顺序发送的请求，服务器并不能按顺序接收（同一个请求的 IP 报文可以，详见 IP 数据报）</p><p>那就造成客户端发送请求后，接收到的响应不能和请求按发送时的顺序一一对应，那请求就完全错乱了</p><p>所以在 HTTP 1.x 的场合，浏览器没有合适的并发方案，只能通过保持连接或同时并行多个连接来提高效率</p><p>但是 HTTP 2 中引入了多路复用的概念，在应用层采取如同网络层的 IP 数据报一样的分段标号模式，此时同一个 TCP 连接就可以正常并发多个 HTTP 请求了</p><h2 id="浏览器最多能对同一服务器建立几个-TCP-连接"><a href="#浏览器最多能对同一服务器建立几个-TCP-连接" class="headerlink" title="浏览器最多能对同一服务器建立几个 TCP 连接"></a>浏览器最多能对同一服务器建立几个 TCP 连接</h2><p>依据浏览器不同，这个限制是不同的</p><p>对于 Chrome，最多允许对同一个 host 建立 6 个 TCP 连接</p><h1 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h1><p>HTTP 1.0 和 HTTP 1.1 在上文已经有提到一些了，除了缓存机制和 TCP 以外也没有什么太大的差别，所以着重讨论 HTTP 2.0 和 HTTPS</p><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><p>HTTP 2.0 有如下特点</p><ol><li>二进制分帧</li><li>首部压缩</li><li>多路复用</li><li>服务端推送</li></ol><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>我们知道数据链路层有以太网帧，网络层有 IP 报文分割，此处的二进制分帧设计思路正是基于前两者的特点而得来的</p><p>使用了二进制分帧后，每个 HTTP 报文都使用二进制格式传输数据，每个报文都由一个或多个帧组成</p><p>相比 HTTP 1.x 的文本格式传输，HTTP 2.0 的二进制格式解析效率更高</p><p>为了正常使用帧，HTTP 2.0 同时使用了流的概念</p><p>流是一个虚拟通道，可以承载双向消息，每个流都有一个唯一 ID</p><p>简单理解，流就是同一组请求和响应的组号</p><h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p>显然每个请求之间都使用了大量的头部字段，且这些字段的值在浏览器和服务器之前是一致的</p><p>HTTP 2.0 则采用了”首部表”来缓存已经发送过的头部字段键值对，使得浏览器和服务器对于与缓存相同的字段，不需要重复在请求中发送，显著减小了请求报文的大小</p><p>该首部表在 HTTP 2.0 连接断开前始终存在，由使用双方共同更新</p><p>当产生未记录的键值对时，要么更新首部表中的记录值，要么追加到首部表的末端</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>在 HTTP 2.0 中，相同域名下的所有通信都使用同一个连接完成，该连接可以并发任意数量的请求和响应，克服了 HTTP 1.x 中同一个连接不能并发请求的问题，消除了 TCP 连接多次建立以及浏览器同时维护多个 TCP 连接的开销</p><p>之所以可以做到这一点，是因为二进制分帧后，同一个流的每个帧都含有首部流标识，可以乱序发送，双方都可以根据首部流标识得到正确的消息</p><p>该设计思路的具体描述可以参考 IP 数据报的分割</p><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>是 HTTP 2.0 最重要的特性</p><p>在 HTTP 1.x 中，如果浏览器没有发出请求，服务器是不能向浏览器发送数据的</p><p>但在 HTTP 2.0 中，服务器可以打开 PUSH 模式，当浏览器请求了一个资源后，服务器可以推送相关资源给浏览器</p><p>例如，有如下 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"example.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果在 HTTP 1.x 中，浏览器需要发起 3 个请求，才可以得到整个页面的完整数据</p><p>但在 HTTP 2.0 中，如果服务器打开 了 PUSH 模式，浏览器只需要发送 1 个请求，申请取得 HTML 文档，服务器就会先返回 HTML 文档，然后根据 HTML 文档中的资源指向，向浏览器推送 css 文件和 png 文件，这样浏览器在后续要使用的时候，就发现已经收到了资源，不需要再发请求了</p><p>这样，只要 1 个请求，就完成了以前 3 个请求才能完成的事情，效率显然大大提高</p><p>既然服务器可以主动推送，客户端自然也可以选择是否接受</p><p>如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收</p><p>主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS 基于 SSL 协议，采用 RSA 算法，使得通信双方不需要直接发送私钥，就可以达成合意开始加密通信</p><p>具体流程如下</p><ol><li>浏览器向服务器发起 HTTPS 连接请求</li><li>服务器向浏览器发送公钥和根据自己的私钥与公钥联合加密的密文</li><li>浏览器收到公钥和密文，随机产生一个私钥，向服务器发送根据自己的私钥与公钥联合加密的密文</li><li>双方都根据公钥、自己的私钥和对方发送的密文进行计算，得到共同的密钥，通信建立</li><li>在之后的通信中，都使用这个计算出来的密钥进行加密通信</li></ol><p>算法原理概述可以参看 <a href="https://ringoer.com/algorithm/rsa/" target="_blank" rel="noopener">图解非对称加密</a></p><h1 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h1><p>首先是浏览器渲染 5 步图</p><p><img src="https://pic.ringoer.com/css-animation-render-5.jpg" alt=""></p><p>根据上图，可知浏览器渲染流程如下</p><h2 id="首次渲染"><a href="#首次渲染" class="headerlink" title="首次渲染"></a>首次渲染</h2><ol><li>解析 JS 脚本。该动作会导致阻塞，所以一般放在 HTML 文档最后</li><li>构建 DOM 树和 CSSOM 树</li><li>合并为渲染树，进行布局</li><li>布局完成后，根据渲染树进行绘制</li><li>绘制完成后交由 GPU 进行合成</li></ol><h2 id="后续渲染"><a href="#后续渲染" class="headerlink" title="后续渲染"></a>后续渲染</h2><ol><li>解析 JS 脚本</li><li>计算布局和样式更改</li><li>将布局和样式更改同步到渲染树上</li><li>根据渲染树重排、重绘</li><li>重绘完成后交由 GPU 进行合成</li></ol><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>浏览器渲染有如下几个特性</p><h3 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h3><p>我们在编码中从来没有见过浏览器报 HTML 和 CSS 的错，因为现代浏览器对 CSS 有强大的容错能力，会自动修复那些可以修复的 HTML 和 CSS 的语法错误，对于不能修复的则直接跳过不加解析</p><h3 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h3><p>HTML 页面生命周期中有以下事件</p><ol><li>DOMContentLoaded</li><li>load</li><li>beforeunload</li><li>unload</li></ol><p>触发时间点如下</p><table><thead><tr><th>事件</th><th>触发时点</th></tr></thead><tbody><tr><td>DOMContentLoaded</td><td>当 DOM 树构建完毕</td></tr><tr><td>load</td><td>当所有资源已经加载完毕</td></tr><tr><td>beforeunload</td><td>当用户正在离开页面，此时数据尚未清除</td></tr><tr><td>unload</td><td>当用户已经离开页面</td></tr></tbody></table><p>通常我们可以利用 beforeunload 事件来弹出一个对话框，用以询问用户是否确定离开</p><p>需要注意的是，当 DOMContentLoaded 事件发生时，async 和 defer 脚本可能尚未执行，其余文件也很有可能正在下载中，不要轻易访问它们</p><p>除了上述事件，我们也可以用 document.readyState 来获取页面当前的状态，并通过 readystatechange 事件来监听页面生命周期的变化</p><p>document.readyState 通常有 3 个值</p><ol><li>loading，页面正在加载中</li><li>interactive，页面解析完毕，触发时点与 DOMContentLoaded 相同，但执行时比 DOMContentLoaded 要早</li><li>complete，页面上所有资源都已经加载完毕，触发时点与 load 相同，但执行时比 load 要早</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/jin-zhe/p/11586327.html" target="_blank" rel="noopener">在浏览器输入URL回车之后发生了什么？（超详细版）</a></p><p><a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="noopener">深入理解浏览器的缓存机制</a></p><p><a href="https://www.jianshu.com/p/aaba68b87416" target="_blank" rel="noopener">面试官问我：一个 TCP 连接可以发多少个 HTTP 请求？我竟然回答不上来…</a></p><p><a href="https://zhuanlan.zhihu.com/p/26559480" target="_blank" rel="noopener">一文读懂 HTTP/2 特性</a></p><p><a href="https://www.cnblogs.com/confach/p/10141273.html" target="_blank" rel="noopener">深入浅出：HTTP/2</a></p><p><a href="https://segmentfault.com/a/1190000011468675" target="_blank" rel="noopener">页面生命周期：DOMContentLoaded, load, beforeunload, unload</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，前端的内容一般都是通过 HTTP 相关协议获取，并在浏览器上呈现的&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>CSS盒子要点简述</title>
    <link href="http://yoursite.com/frontend/css-box-summary/"/>
    <id>http://yoursite.com/frontend/css-box-summary/</id>
    <published>2020-11-23T05:42:00.000Z</published>
    <updated>2020-11-23T16:14:38.131Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 的知识点太多了，本文只讲一些重要的、和盒子有关的知识点</p><a id="more"></a><h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><p>首先当然先介绍 CSS 最重要的概念：盒子模型</p><p>我们在网站上可以看到各种各样的元素，在页面上显示为一个方形的”盒子”</p><p><img src="https://pic.ringoer.com/css-summary-1.png" alt=""></p><p>用开发者工具一看，每个元素都带着各自的彩色边</p><p><img src="https://pic.ringoer.com/css-summary-2.png" alt=""></p><p>这个盒子，就是盒子模型</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>从上图彩色部分可以看出，每个盒子都有 4 块彩色区域，分别是</p><ol><li>margin，外边距，表示盒子外部空出的空间</li><li>border，边框，表示盒子的界限</li><li>padding，内边距，表示盒子内部空出的空间，也即边框和内容的距离</li><li>content，内容</li></ol><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>知道了盒子模型的组成，就可以介绍一下盒子的类型</p><p>盒子模型有两种类型</p><ol><li>content-box（默认）</li><li>border-box</li></ol><p>我们知道，可以通过控制 width 和 height 属性来控制盒子的大小，那顾名思义</p><ol><li>在 content-box 中设置 width 就是设置内容区域的宽度，高度同理</li><li>在 border-box 中设置 width 就是设置内容+内边距+边框的宽度，高度同理。此处尺寸包含边框的尺寸大小</li></ol><p>所以在 content-box 中，width = content.width，总宽度自动计算</p><p>在 border-box 中，width = content.width + padding.width + border.width，内容宽度自动计算</p><p>那么怎么设置呢？可以通过</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br></pre></td></tr></table></figure><p>来切换成 border-box</p><h1 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h1><p>然后介绍一下 CSS 基本概念——文档流</p><p>观察开发者工具里的 HTML 文档，可以观察到类似如下情况</p><p><img src="https://pic.ringoer.com/css-summary-3.png" alt=""></p><p><img src="https://pic.ringoer.com/css-summary-4.png" alt=""></p><p>可见元素一般是从上到下、独占一行的，只有文字之类的内部元素才占同一行</p><p>而图片占的位置，又会影响后面标签页的位置</p><p>一般一个元素独占一行，且前面的布局会影响后面的布局，这样的就是文档流</p><p>要使元素脱离文档流，可以修改其 position 属性，或为其 float 属性赋值</p><p>那么哪些元素会独占一行呢？</p><h1 id="display"><a href="#display" class="headerlink" title="display"></a>display</h1><p>HTML 中有 div，表现为占据一行，也有 span，表现为在同一行显示。为什么会有这种区别呢？</p><p>答案就在 CSS 的 display 属性身上</p><p>display 一般有三种取值</p><ol><li>block</li><li>inline</li><li>inline-block</li></ol><p>默认值要看是什么标签，不同标签默认值不同</p><p>表现分别如下</p><table><thead><tr><th>display 取值</th><th>特性</th></tr></thead><tbody><tr><td>block</td><td>独占一行，高度自适应，可以设置宽高</td></tr><tr><td>inline</td><td>多个共用一行，高度自适应，宽度尽可能短，行末溢出则切断，不可设置宽高</td></tr><tr><td>inline-block</td><td>多个共用一行，高度自适应，宽度尽可能短，行末溢出不切断，其余同 block</td></tr></tbody></table><p>那么既然可以设置宽高，如果 block 中文本长度超出设定范围，怎么办呢</p><h1 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h1><p>可以使用 overflow 属性定义内容溢出的情况下父元素如何表现</p><p>overflow 一般有 5 种取值</p><ol><li>visible（默认）</li><li>hidden</li><li>scroll</li><li>auto</li><li>inherit</li></ol><p>表现分别如下</p><table><thead><tr><th>overflow 取值</th><th>特性</th></tr></thead><tbody><tr><td>visible</td><td>溢出部分恒可见</td></tr><tr><td>hidden</td><td>溢出部分恒不可见</td></tr><tr><td>scroll</td><td>不论是否溢出，均提供滚动条，当溢出时可以通过滚动条查看溢出内容</td></tr><tr><td>auto</td><td>仅当溢出时，会在溢出方向提供滚动条，可以通过滚动条查看溢出内容</td></tr><tr><td>inherit</td><td>继承父元素的 overflow 设置值</td></tr></tbody></table><p>显然 scroll 比较蠢，需要滚动条的时候用 auto 比较好</p><p>还可以通过 overflow-x 和 overflow-y 来分别设置 x 方向的溢出和 y 方向的溢出如何处理</p><p>注意，当设置了滚动条时，如果内容超出设定范围，虽然会提供滚动条以查看溢出内容，但其余内容只会显示在第一视角，不会自动填充到溢出范围</p><p>讲完盒子整体，来重点讲讲盒子里具体的内容</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>一般用来放置文字，故而此处主要讲文字</p><p>文字常用属性如下</p><table><thead><tr><th>属性</th><th>用途</th></tr></thead><tbody><tr><td>font-family</td><td>设置字体</td></tr><tr><td>font-size</td><td>设置文字大小，可选单位 px、em、rem、%、vw、vh</td></tr><tr><td>color</td><td>设置文字颜色，可用单词、rgba、hsla、#十六进制色号</td></tr><tr><td>letter-spacing</td><td>字符间距</td></tr><tr><td>line-height</td><td>行高</td></tr><tr><td>text-align</td><td>常取值 center，文本居中</td></tr><tr><td>vertical-align</td><td>与同行元素对齐，指定对齐的基线<br>取决于当前字体下 x 的高度</td></tr><tr><td>white-space</td><td>指示空格和换行符的处理方式<br>常取值 nowrap，表示即使遇到空格和换行符，也不换行</td></tr></tbody></table><h1 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h1><p>是一个距离度量，表示自身 border 到自身内容区域之间的距离</p><p>可能的值：</p><ol><li>length（固定的px、pt、em等值</li><li>%（使用百分比边距，相对于最近的有设置宽度的父元素的宽度</li></ol><h1 id="border"><a href="#border" class="headerlink" title="border"></a>border</h1><p>常用属性如下</p><table><thead><tr><th>属性</th><th>用途</th></tr></thead><tbody><tr><td>border-style</td><td>必填，设置边框类型，常用 solid，共有 8 种</td></tr><tr><td>border-width</td><td>设置边框宽度，常用单位 px</td></tr><tr><td>border-color</td><td>设置边框颜色，可用单词、rgba、hsla、#十六进制色号</td></tr><tr><td>border-radius</td><td>设置边框弧度，可以填 4 个值，表示 4 个对角方向分别的弧度<br>常用单位 %、px</td></tr><tr><td>box-shadow</td><td>设置边框阴影，可以设置 x、y 方向的阴影距离，模糊情况与色号</td></tr><tr><td>border-image</td><td>设置用来填充 border 的图片</td></tr></tbody></table><h1 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h1><h2 id="margin-表现"><a href="#margin-表现" class="headerlink" title="margin 表现"></a>margin 表现</h2><p>是一个距离度量，用以清除周围元素区域</p><p>没有背景颜色，完全透明</p><p>可能的值：</p><ol><li>auto（依赖于浏览器</li><li>length（固定的px、pt、em等值</li><li>%（使用百分比边距，相对于最近的有设置宽度的父元素的宽度</li></ol><p>外边距的直观表现就是与相邻元素的距离会拉开，比如有如下 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"first"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"second"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>且有如下 CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以观察到如图景象</p><p><img src="https://pic.ringoer.com/css-summary-5.png" alt=""></p><p>现在我们对第一个盒子加入 margin-left</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.first</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.ringoer.com/css-summary-6.png" alt=""></p><p>就可以观察到第一个盒子向左，也就是 body 的左边框离开了 10 px，也就是向右移动了 10 px，连带着影响到第二个盒子也向右移动了 10 px（文档流）</p><p>如果对第二个盒子也加上 <code>margin-left: 10px;</code> ，那第二个盒子也会变得向第一个盒子离开了 10 px</p><p><img src="https://pic.ringoer.com/css-summary-7.png" alt=""></p><p>显然，margin 是决定相隔距离的</p><p>但是，margin 是会重叠的！！！！！！</p><h2 id="margin-重叠"><a href="#margin-重叠" class="headerlink" title="margin 重叠"></a>margin 重叠</h2><p>margin 重叠有一个前提：重叠的两个元素的 display 属性必须都是 block，不可以是 inline-block 或 inline</p><p>当满足前提时，会发生在如下情况下：</p><ol><li><p>不同行，但相邻的兄弟元素，上面元素的下外边距会和下面元素的上外边距重叠</p><p><img src="https://pic.ringoer.com/css-summary-8.png" alt=""></p></li><li><p>父元素中第一个子元素的上外边距会和父元素的上外边距重叠</p><p><img src="https://pic.ringoer.com/css-summary-9.png" alt=""></p><p><img src="https://pic.ringoer.com/css-summary-10.png" alt=""></p></li><li><p>父元素中最后一个子元素的下外边距会和父元素的下外边距重叠</p><p><img src="https://pic.ringoer.com/css-summary-11.png" alt=""></p><p><img src="https://pic.ringoer.com/css-summary-10.png" alt=""></p></li></ol><p>当满足以上条件，且 margin 被设置了值（而且不是 auto）时，margin 会发生重叠，重叠时：</p><ol><li>两个 margin 都是正数，保留较大值</li><li>一正一负，作差</li><li>两个均为负值，保留绝对值较大的值</li></ol><p>如果想要取消父子重叠，可以令父元素具有以下特征</p><ol><li>令父元素成为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">BFC 块级格式化上下文</a></li><li>父元素设置 border 或 padding</li><li>父元素和第一个或最后一个子元素之间用 inline 或 inline-block元素隔开</li></ol><p>很神奇吧，记得亲自尝试一下</p><p>什么，你问我为什么会这样？CSS 没有为什么（</p><h2 id="负-margin"><a href="#负-margin" class="headerlink" title="负 margin"></a>负 margin</h2><p>外边距还有一招神奇的招式，叫做负外边距，主要用来实现居中布局和平均布局，会在 <a href="https://ringoer.com/frontend/css-layout" target="_blank" rel="noopener">CSS 布局</a> 一文中介绍</p><p>我们知道可以用 background 属性为盒子设置背景色，那么看到这里可能有人会问，背景色会不会覆盖边框或者内容呢？</p><h1 id="盒子分层"><a href="#盒子分层" class="headerlink" title="盒子分层"></a>盒子分层</h1><p>一个盒子的分层自顶向下大致如下</p><ol><li>inline 和 inline-blcok 子元素</li><li>float 元素</li><li>block 子元素</li><li>border</li><li>background</li></ol><p>如何验证呢？通过调整对 border 的着色的透明度，就可以验证</p><p>那如何超越这个分层呢？可以使用 z-index 属性</p><h1 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h1><p>对于一个已经定位的盒子（即其 <code>position</code> 属性值不是 <code>static</code>，这里要注意的是 CSS 把元素看作盒子），<code>z-index</code> 属性指定：</p><ol><li>盒子在当前堆叠上下文中的堆叠层级。</li><li>盒子是否创建一个本地堆叠上下文。</li></ol><p>默认的 z-index 是 auto，符合上述分层模型</p><p>当 z-index 相同时，按照元素在文档流中的出现顺序决定元素的遮挡关系，后出现的遮挡先出现的</p><p>虽然 auto 的解析值是 0，但是直接令 z-index = 0 和令 z-index = auto，是不一样的</p><p>当你为某元素设置了一个不是 auto 的 z-index，世界就改变了</p><p>刚才在分层模型中说到</p><ol><li>内联子元素是在最高层</li><li>这里又提到默认的 z-index 是 auto</li></ol><p>那就可以推断出，最高层的内联子元素，在解析后 z-index = 0，那么它就会比 z-index 大于 0 的元素要低！！就会被这样的元素覆盖了！！</p><p>同理可以推断，z-index 小于 0 的元素，会被 background 覆盖，因为 background 的解析值也是 0</p><p>于是可以大致得出结论，z-index 数值大的会遮挡数值小的元素</p><p>但这也不是绝对的，两个元素是否满足 z-index 决定的遮挡关系，还要看其所在环境，这个环境叫做 层叠上下文</p><h1 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h1><p>层叠上下文是一个小世界，必须要同等级的小世界之间，才可以互相比较 z-index</p><p>设有如下的 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"z-index: 1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"z-index: 3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"z-index: 2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按说，z-index = 3 的 div 应当遮挡住 z-index = 2 的 div，但实际上并不是，因为 z-index = 3 的 div 与 z-index = 2 的 div 并不同级，他只能与 z-index = 1 的 div 中的其它元素进行比较</p><p>而因为 z-index = 1 的 div 恒低于 z-index = 2 的 div，所以 z-index = 3 的 div 也恒低于 z-index = 2 的 div</p><p>如果都没有父元素设置 z-index，那么他们共同的层叠上下文是 html 根元素</p><p>如何创建层叠上下文？请查询 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">层叠上下文</a></p><p>知道了一个盒子自己内部的事情，现在来了解一下文档流中盒子是怎么布局的</p><h1 id="position"><a href="#position" class="headerlink" title="position"></a>position</h1><p>顾名思义，影响盒子的位置</p><p>一般有 5 个取值</p><ol><li>static（默认，属于文档流</li><li>relative（属于文档流</li><li>absolute（脱离文档流</li><li>fixed（脱离文档流</li><li>sticky（看情况</li></ol><p>static 作为默认值，就不多介绍了，介绍一下其它的</p><h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><p>在文档流中所占的位置是默认位置，常作为 absolute 元素的父元素的属性</p><p>可以使用 left、right、top、bottom 等 4 个属性来调整自己相对于原本位置的偏移距离</p><h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><p>相对于最近的已定位父元素（不能是 static）进行定位</p><p>可以使用 left、right、top、bottom 等 4 个属性来调整自己相对于最近的已定位父元素的偏移距离</p><h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><p>在视口上绝对定位，不随窗口滚动而移动</p><p>可以使用 left、right、top、bottom 等 4 个属性来调整自己相对于视口的偏移距离</p><h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><p>粘性定位，超出视口前表现为 relative，超出后表现为 fixed</p><p>在变为 fixed 时，会粘在还是 relative 时最后的位置</p><p>如上，CSS 与盒子有关的常用部分就是这样了，谢谢观看</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 的知识点太多了，本文只讲一些重要的、和盒子有关的知识点&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>HTML重要标签</title>
    <link href="http://yoursite.com/frontend/html-tags/"/>
    <id>http://yoursite.com/frontend/html-tags/</id>
    <published>2020-11-19T14:21:00.000Z</published>
    <updated>2020-12-10T15:19:35.539Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍一些前端常用且重要的标签</p><a id="more"></a><p>首先给出索引</p><ol><li><a href="#table">table</a></li><li><a href="#form">form</a></li><li><a href="#a">a</a></li><li><a href="#img">img</a></li><li><a href="#video">video</a></li><li><a href="#audio">audio</a></li><li><a href="#canvas">canvas</a></li><li><a href="#svg">svg</a></li></ol><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>table，表格标签，用于制表，包含以下子标签</p><table><thead><tr><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>thead</td><td>表头</td></tr><tr><td>tbody</td><td>表体</td></tr><tr><td>tfoot</td><td>表脚</td></tr><tr><td>tr</td><td>行</td></tr><tr><td>th</td><td>表头子项</td></tr><tr><td>td</td><td>表体子项</td></tr></tbody></table><p>表格示例代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>时间<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>事件<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>7点<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>起床<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>8点<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>早饭<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>12点<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>午饭<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>13点<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>午休起床<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>17点<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>晚饭<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>23点<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>休息<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>总共24小时<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>总共6件事情<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是，此时你会发现表格十分之难看，间距很大，对齐也不正常</p><p>我们可以用三个常用的表格属性来调整</p><table><thead><tr><th>属性</th><th>含义</th><th>默认值</th><th>建议值</th></tr></thead><tbody><tr><td>table-layout</td><td>表格布局</td><td>auto（自动分配</td><td>fixed（如果有指定宽度则等分</td></tr><tr><td>border-collapse</td><td>边框隔离</td><td>separated（分隔</td><td>collapsed（合并</td></tr><tr><td>border-spacing</td><td>边框间距</td><td>0</td><td>0</td></tr></tbody></table><h1 id="form"><a href="#form" class="headerlink" title="form"></a>form</h1><p>form，表单标签，常用于提交请求</p><p>主要功能全部体现在其属性上，故此处先讲属性</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>action</td><td>提交表单的地址，可以是相对路径或绝对路径，留空则为当前页面。提交后当前页面会刷新</td></tr><tr><td>method</td><td>可选 GET 或 POST，默认 GET，详见 HTTP 动词</td></tr><tr><td>target</td><td>常用 _blank，表示在新标签页打开，默认值为 _self，表示在当前页面打开。若有 iframe 嵌套，则还可以使用 _parent 或 _top 来控制打开位置</td></tr><tr><td>autocompete</td><td>可选 on 或 false，当值为 on 时会依据用户历史提供下拉填充选项，默认值取决于浏览器</td></tr></tbody></table><p>当表单提交时，触发其 onsubmit 事件，并将所有数据组织为 <code>[name]=[value]</code> 形式的 formdata，发送到 action 指定的地址</p><p>可以通过 js 拦截该 onsubmit 事件，提供一些诸如先验的操作</p><p>可用以下子标签作为 form 的子元素</p><table><thead><tr><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>input[type=”text”]</td><td>单行文本框</td></tr><tr><td>input[type=”password”]</td><td>单行文本框，但不可直接看见</td></tr><tr><td>textarea</td><td>多行文本框</td></tr><tr><td>input[type=”submit”]</td><td>提交按钮，触发所在表单的 submit 事件</td></tr><tr><td>button</td><td>按钮，触发所在表单的 submit 事件</td></tr><tr><td>input[type=”radio”]</td><td>单选框</td></tr><tr><td>input[type=”checkbox”]</td><td>复选框</td></tr><tr><td>input[type=”file”]</td><td>用于选择文件</td></tr><tr><td>input[type=”email”]</td><td>用于输入邮箱</td></tr><tr><td>input[type=”tel”]</td><td>用于输入电话</td></tr><tr><td>input[type=”hidden”]</td><td>一个隐藏的输入框，用于为 js 脚本保存数据</td></tr><tr><td>select</td><td>下拉选框</td></tr><tr><td>option</td><td>下拉选框子项</td></tr><tr><td>label</td><td>为输入框添加描述</td></tr></tbody></table><h2 id="专有属性"><a href="#专有属性" class="headerlink" title="专有属性"></a>专有属性</h2><p>此处专有属性并非指字段名专有，而是指意义专有</p><table><thead><tr><th>标签</th><th>属性</th><th>是否取值</th><th>含义</th></tr></thead><tbody><tr><td>[all]</td><td>required</td><td>否</td><td>任意允许用户输入的标签，都可以使用该属性来强制要求用户输入，否则无法提交表单</td></tr><tr><td>[all]</td><td>autofocus</td><td>否</td><td>自动聚焦到该元素</td></tr><tr><td>[all]</td><td>disabled</td><td>否</td><td>令用户不能编辑该元素</td></tr><tr><td>input[type=”text”]、textarea</td><td>placeholder</td><td>是</td><td>指定当文本框为空时，显示的提示文本</td></tr><tr><td>input[type=”text”]、textarea</td><td>maxlength</td><td>是</td><td>指定文本框可以接受的最大文本长度</td></tr><tr><td>textarea</td><td>style&gt;resize</td><td>是</td><td>默认情况下可以拖动改变文本框大小，当该属性指定为 none 时不可改变大小</td></tr><tr><td>input[type=”radio”]</td><td>name</td><td>是</td><td>指定若干个 input 为同一组</td></tr><tr><td>input[type=”radio”]</td><td>checked</td><td>否</td><td>指定同一组 input 中的默认选择</td></tr><tr><td>input[type=”checkbox”]</td><td>name</td><td>是</td><td>指定若干个 input 为同一组</td></tr><tr><td>input[type=”checkbox”]</td><td>checked</td><td>否</td><td>指定同一组 input 中的默认选择</td></tr><tr><td>input[type=”file”]</td><td>multiple</td><td>否</td><td>令该文件输入框可以选择多个文件</td></tr><tr><td>button</td><td>type</td><td>是</td><td>在表单中若不指定，则为 submit，指定为其它值则不会触发提交</td></tr><tr><td>option</td><td>value</td><td>是</td><td>选项的实际值，该值区别于用户能看到的值，由 js 处理</td></tr></tbody></table><p>显然，input 元素的表现非常复杂，且主要负责输入，那么有以下 3 个主要事件来控制 input 的输入</p><table><thead><tr><th>事件</th><th>适合元素</th><th>触发时机</th></tr></thead><tbody><tr><td>onchange</td><td>input[type=”text”]、textarea</td><td>文本改变</td></tr><tr><td>onfocus</td><td>input[type=”text”]、textarea</td><td>获得焦点</td></tr><tr><td>onblur</td><td>input[type=”text”]、textarea</td><td>失去焦点</td></tr></tbody></table><p>在项目中一般不使用 form 直接提交数据，而使用 js 拦截提交事件，然后用 ajax 提交，故现在 form 标签更多仅作为一个表示而已</p><h1 id="a"><a href="#a" class="headerlink" title="a"></a>a</h1><p>a，超链接标签，常用于跳转页面，没有专属的子标签</p><p>重要属性如下</p><table><thead><tr><th>属性</th><th>是否取值</th><th>含义</th></tr></thead><tbody><tr><td>href</td><td>是</td><td>指定超链接的地址，一般是<br>1. 网络上的路径，使用 http 或 https 协议，或不指定协议<br>2. 本站相对路径<br>3. 伪协议路径，一般是 javascript、mailto、tel 三种伪协议之一<br>4. 页内锚点，通过 #[id] 指定</td></tr><tr><td>target</td><td>是</td><td>常用 _blank，表示在新标签页打开，默认值为 _self，表示在当前页面打开。若有 iframe 嵌套，则还可以使用 _parent 或 _top 来控制打开位置，或直接指定为 iframe 的 name</td></tr><tr><td>download</td><td>否</td><td>此时 a 标签的动作不再是打开新页面，而是下载新页面</td></tr><tr><td>rel</td><td>是</td><td>当使用 target=”_blank” 时，要加上 rel=”noopener” 以防止钓鱼攻击</td></tr></tbody></table><p>也可以设置一个用于触发 JavaScript 方法，其余什么也不做的 a 标签</p><p>此处使用 javascript 伪协议，代码如下</p><p><code>&lt;a href=&quot;javascript:;&quot;&gt;点击我什么也没发生&lt;/a&gt;</code></p><h1 id="img"><a href="#img" class="headerlink" title="img"></a>img</h1><p>img，图片标签，用于通过 GET 请求来引入图片，没有专属的子标签</p><p>重要属性如下</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>src</td><td>指定图片来源，可以是网络地址或相对路径，可以通过 js 改变指向</td></tr><tr><td>alt</td><td>指定当图片无法加载时的提示内容</td></tr><tr><td>width</td><td>指定图片的宽度，此时高度会根据比例调整</td></tr><tr><td>height</td><td>指定图片的高度，此时宽度会根据比例调整</td></tr><tr><td>style&gt;max-width</td><td>指定图片的最大宽度，当设为 100% 时，最大不会超过视口大小</td></tr></tbody></table><p>重要事件如下</p><table><thead><tr><th>事件</th><th>触发时机</th><th>用法</th></tr></thead><tbody><tr><td>onload</td><td>图片加载成功</td><td>统计图片访问量</td></tr><tr><td>onerror</td><td>图片加载失败</td><td>补救失败图片</td></tr></tbody></table><p>使用 img 标签，要遵循以下规则</p><ol><li>img 的大小应该不超过 300 kb，否则严重影响加载速度</li><li>永远不要在不合比例的情况下同时指定 height 和 width，否则图片将严重变形</li><li>最好只使用 width 来修改图片尺寸</li></ol><h1 id="video"><a href="#video" class="headerlink" title="video"></a>video</h1><p>video，视频标签，用于引入视频</p><p>有以下重要属性</p><table><thead><tr><th>属性</th><th>是否取值</th><th>含义</th></tr></thead><tbody><tr><td>src</td><td>是</td><td>指定视频来源</td></tr><tr><td>controls</td><td>否</td><td>提供一些用户操作</td></tr><tr><td>preload</td><td>是</td><td>指示视频是否应该被缓存</td></tr></tbody></table><p>其余部分请查看 mdn</p><h1 id="audio"><a href="#audio" class="headerlink" title="audio"></a>audio</h1><p>audio，音频标签，用于引入音频</p><p>重要属性与 video 相同</p><h1 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h1><p>canvas，为用户提供一张画布</p><p>具体的比较难以说明，建议查看以下画图板范例，或 mdn</p><p><a href="https://github.com/Ringoer/Toy/blob/main/22/canvas.html" target="_blank" rel="noopener">https://github.com/Ringoer/Toy/blob/main/22/canvas.html</a></p><h1 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h1><p>svg，矢量图形，一般要用的时候直接去网上找一个 svg 库，然后引用他们的 svg 即可</p><p>常用 svg 库如下</p><p><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">Iconfont-阿里巴巴矢量图标库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍一些前端常用且重要的标签&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>HTML入门</title>
    <link href="http://yoursite.com/frontend/html-introduction/"/>
    <id>http://yoursite.com/frontend/html-introduction/</id>
    <published>2020-11-19T10:10:00.000Z</published>
    <updated>2020-11-19T14:59:58.163Z</updated>
    
    <content type="html"><![CDATA[<p>HTML入门</p><a id="more"></a><p>阅读本文，建议使用的编辑器为 VSCODE</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HTML的英文全称是 Hyper Text Markup Language，即超文本标记语言</p><p>HTML是由Web的发明者 Tim Berners-Lee于1990年创立的一种标记语言</p><h1 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h1><p>首先来看看HTML板子长什么样子</p><p>打开 VSCODE，新建一个 html 文件，在其中打入一个英文的感叹号 <code>!</code>，会弹出一个选框，选择一个感叹号的选项。如果选了三个感叹号的选项，只会给出文档头</p><p>自动打板后效果如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是此时还不够完善，让我们先去改了默认的板子</p><h2 id="修改默认打板"><a href="#修改默认打板" class="headerlink" title="修改默认打板"></a>修改默认打板</h2><p>上面不够完善的部分，是 meta 标签中的 content 部分</p><p>先不要管起了什么作用，改完了再说</p><p>修改步骤如下</p><ol><li>打开 VSCODE 所在目录，进入 <code>./resources/app/extensions/emmet/dist/node</code> 目录</li><li>打开 <code>emmetNodeMain.js</code> 文件，搜索 <code>meta:vp</code></li><li>如无意外，会有两个设置项，两个引用项。确定两个设置项</li><li>设置项形如 <code>&quot;meta:vp&quot;:&quot;meta[name=viewport content=&#39;width=${1:device-width}, initial-scale=${2:1.0}&#39;]&quot;</code></li><li>改为 <code>&quot;meta:vp&quot;:&quot;meta[name=viewport content=&#39;width=${1:device-width}, initial-scale=${2:1.0}, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&#39;]&quot;</code></li></ol><p>改完后重新打板，效果如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="底板解释"><a href="#底板解释" class="headerlink" title="底板解释"></a>底板解释</h2><ol><li><p>第一行是文档声明，声明该文档为 html 文档</p><p>注意感叹号是英文感叹号，DOCTYPE 大写，html 小写</p></li><li><p>第二行是根元素，含有 lang 属性，用于指定文档语言</p></li><li><p>第三行是文档头，包含了表示元数据的 meta 标签和表示页面标题的 title 标签</p></li><li><p>文档头之后是文档体，用于书写页面正文</p></li><li><p>meta:vp 是什么？</p><p>是 meta 的默认配置，具体含义如下</p></li></ol><table><thead><tr><th>属性</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>charset</td><td>UTF-8</td><td>指定页面使用 UTF-8 编码</td></tr><tr><td>name</td><td>viewport</td><td>指定根据视口大小的设置</td></tr><tr><td>content&gt;width</td><td>device-width</td><td>视口大小等于设备大小</td></tr><tr><td>content&gt;initial-scale</td><td>1.0</td><td>初始大小与视口同大</td></tr><tr><td>content&gt;minimum-scale</td><td>1.0</td><td>最小缩小比例与视口同大</td></tr><tr><td>content&gt;maximum-scale</td><td>1.0</td><td>最大放大比例与视口同大</td></tr><tr><td>content&gt;user-scalable</td><td>no</td><td>禁止用户手动放大页面</td></tr></tbody></table><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><h2 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h2><table><thead><tr><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>html</td><td>根元素</td></tr><tr><td>head</td><td>文档头</td></tr><tr><td>body</td><td>文档体</td></tr><tr><td>title</td><td>页面标题</td></tr><tr><td>meta</td><td>元数据</td></tr><tr><td>link</td><td>链接外部资源</td></tr><tr><td>style</td><td>内部样式</td></tr><tr><td>script</td><td>内部脚本或链接到外部脚本</td></tr></tbody></table><h2 id="文章标签"><a href="#文章标签" class="headerlink" title="文章标签"></a>文章标签</h2><p>最早，HTML是用来在网上展示文章信息的，所以有了如下文章标签</p><table><thead><tr><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>article</td><td>文章</td></tr><tr><td>section</td><td>章节</td></tr><tr><td>h[1…6]</td><td>标题</td></tr><tr><td>p</td><td>段落</td></tr><tr><td>header</td><td>头部</td></tr><tr><td>footer</td><td>脚部</td></tr><tr><td>main</td><td>主要内容</td></tr><tr><td>aside</td><td>分支内容</td></tr><tr><td>div</td><td>块</td></tr></tbody></table><h2 id="内容标签"><a href="#内容标签" class="headerlink" title="内容标签"></a>内容标签</h2><p>有了文章结构，自然还要写文章内容，于是又有了内容标签</p><p>但是有的标签相当重要，需要单独说明，故而会在下个章节给出</p><table><thead><tr><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>ol</td><td>有序列表</td></tr><tr><td>ul</td><td>无序列表</td></tr><tr><td>li</td><td>列表项</td></tr><tr><td>dl</td><td>描述列表</td></tr><tr><td>dt</td><td>描述标题</td></tr><tr><td>dd</td><td>描述项</td></tr><tr><td>pre</td><td>预览</td></tr><tr><td>code</td><td>代码</td></tr><tr><td>q</td><td>引用（此项为内联元素</td></tr><tr><td>blockquote</td><td>引用（此项为块级元素</td></tr><tr><td>em</td><td>斜体（语气上强调</td></tr><tr><td>strong</td><td>粗体（实际上重要</td></tr><tr><td>hr</td><td>分隔线</td></tr><tr><td>br</td><td>换行符</td></tr></tbody></table><h2 id="重要标签"><a href="#重要标签" class="headerlink" title="重要标签"></a><span id="important">重要标签</span></h2><p>此处仅给出这些标签，具体的部分请点击超链接查看</p><table><thead><tr><th>标签</th><th>含义</th></tr></thead><tbody><tr><td><a href="https://ringoer.com/frontend/html-tags#table" target="_blank" rel="noopener">table</a></td><td>表格</td></tr><tr><td><a href="https://ringoer.com/frontend/html-tags#form" target="_blank" rel="noopener">form</a></td><td>表单</td></tr><tr><td><a href="https://ringoer.com/frontend/html-tags#a" target="_blank" rel="noopener">a</a></td><td>超链接</td></tr><tr><td><a href="https://ringoer.com/frontend/html-tags#img" target="_blank" rel="noopener">img</a></td><td>图片</td></tr><tr><td><a href="https://ringoer.com/frontend/html-tags#video" target="_blank" rel="noopener">video</a></td><td>视频</td></tr><tr><td><a href="https://ringoer.com/frontend/html-tags#audio" target="_blank" rel="noopener">audio</a></td><td>音频</td></tr><tr><td><a href="https://ringoer.com/frontend/html-tags#canvas" target="_blank" rel="noopener">canvas</a></td><td>画图</td></tr><tr><td><a href="https://ringoer.com/frontend/html-tags#svg" target="_blank" rel="noopener">svg</a></td><td>矢量图</td></tr></tbody></table><h2 id="其余标签"><a href="#其余标签" class="headerlink" title="其余标签"></a>其余标签</h2><p>其余标签并不是很重要，有兴趣的话可以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5/HTML5_element_list" target="_blank" rel="noopener">点我查看</a></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>刚才说到根元素有 lang 属性，用于指明文档语言</p><p>显然不同的标签有共通属性，也有专有属性</p><h2 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h2><table><thead><tr><th>属性名</th><th>是否取值</th><th>含义</th></tr></thead><tbody><tr><td>class</td><td>是</td><td>css 类</td></tr><tr><td>hidden</td><td>否</td><td>visible=hidden，此时有渲染，但无事件</td></tr><tr><td>id</td><td>是</td><td>声明全局唯一 id，但需要程序员手动控制</td></tr><tr><td>style</td><td>是</td><td>内联样式</td></tr><tr><td>tabindex</td><td>是</td><td>指定 tab 的顺序，使用正整数，越小越优先；=0则最后；=-1则不会被 tab 访问</td></tr><tr><td>title</td><td>是</td><td>指定所在元素的说明，在鼠标放置在该元素上时会显示浮窗</td></tr><tr><td>contenteditable</td><td>是</td><td>指定所在元素是否（true/false）可以被用户编辑</td></tr></tbody></table><h2 id="专有属性"><a href="#专有属性" class="headerlink" title="专有属性"></a>专有属性</h2><p>请前往 <a href="#important">重要标签</a> 查看，或查阅 MDN</p><p>谢谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML入门&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
</feed>
