<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ringo&#39;s Coding Life</title>
  
  <subtitle>OI to ACM</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-11T07:02:42.028Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ringoer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Welcome to No. 68 Floating Island</title>
    <link href="http://yoursite.com/uncategorized/mainpage/"/>
    <id>http://yoursite.com/uncategorized/mainpage/</id>
    <published>2332-12-31T16:00:00.000Z</published>
    <updated>2019-03-11T07:02:42.028Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"><b><font size="6">Are You Going To Scarborough Fair ?</font></b></p><br><img src="http://pic.ringoer.com/id63819688.png" alt="id=63819688" title="id=63819688"><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;b&gt;&lt;font size=&quot;6&quot;&gt;Are You Going To Scarborough Fair ?&lt;/font&gt;&lt;/b&gt;&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;http://pic.ringoer.com/id63819688
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>UI 框架-顶边栏</title>
    <link href="http://yoursite.com/project/ui-framework-topnav/"/>
    <id>http://yoursite.com/project/ui-framework-topnav/</id>
    <published>2021-02-20T12:04:00.000Z</published>
    <updated>2021-02-20T15:04:01.579Z</updated>
    
    <content type="html"><![CDATA[<p>显然顶边栏比较好做，且首页和文档页都需要它，那让我们先做好顶边栏</p><a id="more"></a><hr><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>首先，在 <code>components</code> 文件夹下，新建一个 vue 组件，就叫 <code>Topnav.vue</code> 吧，然后打板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>建议使用 scss 书写所有 css，下略</p><p>以后所有 vue 组件，无特殊说明的话，均沿用此初始化模板，下略</p><h1 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h1><p>分析顶边栏的结构，显然，有以下成分</p><table><thead><tr><th>成分</th><th>位置</th><th>默认</th><th>小于 500px</th></tr></thead><tbody><tr><td>首页跳转入口</td><td>左侧</td><td>可见</td><td>居中</td></tr><tr><td>文档页跳转入口</td><td>右侧</td><td>可见</td><td>不可见</td></tr><tr><td>展开菜单按键</td><td>左侧</td><td>不可见</td><td>可见</td></tr></tbody></table><p>容易得到以下页面结构</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"topnav"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line">            首页</span><br><span class="line">        <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/document"</span>&gt;</span></span><br><span class="line">            文档页</span><br><span class="line">        <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">            菜单</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是，未来有可能变更需求，在右侧出现不只一个文档页跳转入口，所以应该做一个列表，以备未来扩展</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"topnav"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span></span><br><span class="line">            首页</span><br><span class="line">        <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/document"</span>&gt;</span></span><br><span class="line">                    文档页</span><br><span class="line">                <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"toggleMenu"</span>&gt;</span></span><br><span class="line">            菜单</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>先分析需要的控制元素</p><p>显然，顶边栏中的弹出菜单按键，可以在引入它的组件中，被设置是否可见，那么应当有一个 Boolean 类型的变量来控制可见</p><p>且需要提供一个方法，控制菜单本体是否可见</p><p>但是，现在又犯难了——菜单本体是属于文档页的，而不是属于顶边栏的。如何跨组件控制呢？</p><p>回顾需求分析可得，通过弹出菜单按键，以及视口宽度，共同控制菜单是否可见</p><p>其中，视口宽度显然是一个全局属性，那么理应在 <code>App.vue</code> 中控制</p><p>于是我们在 <code>App.vue</code> 中定义其是否可见，并通过 <code>provide/inject</code> API 暴露给子组件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue script</span></span><br><span class="line"><span class="keyword">import</span> &#123; provide, ref &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">"App"</span>,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> width = ref(<span class="built_in">document</span>.documentElement.clientWidth);</span><br><span class="line">        <span class="keyword">const</span> menuVisible = ref(width.value &gt; <span class="number">500</span> ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">window</span>.onresize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            width.value = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">            <span class="keyword">if</span> (width.value &gt; <span class="number">500</span>) &#123;</span><br><span class="line">                menuVisible.value = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                menuVisible.value = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        provide(<span class="string">"menuVisible"</span>, menuVisible);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化时根据视口宽度决定顶边栏的弹出菜单按键是否可见，并监听视口大小变化，根据视口宽度自动更新控制变量</p><p>然后编写 <code>Topnav.vue</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Topnav.vue script</span></span><br><span class="line"><span class="keyword">import</span> &#123; inject, Ref &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        toggleMenuButtonVisible: &#123;</span><br><span class="line">            <span class="keyword">type</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> menuVisible = inject&lt;Ref&lt;<span class="built_in">boolean</span>&gt;&gt;(<span class="string">"menuVisible"</span>);</span><br><span class="line">        <span class="keyword">const</span> toggleMenu = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            menuVisible.value = !menuVisible.value;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            toggleMenu,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，此处的 <code>inject</code> 需要注明变量的类型。因为 <code>menuVisible</code> 声明的时候是 <code>ref(true|false)</code>，所以其类型为 <code>Ref&lt;boolean&gt;</code></p><p>将暴露出的变量引回模板</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"topnav"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span></span><br><span class="line">            首页</span><br><span class="line">        <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/document"</span>&gt;</span></span><br><span class="line">                    文档页</span><br><span class="line">                <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-if</span>=<span class="string">"toggleMenuButtonVisible"</span> <span class="attr">class</span>=<span class="string">"toggleAside"</span> @<span class="attr">click</span>=<span class="string">"toggleMenu"</span>&gt;</span></span><br><span class="line">            菜单</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h1><p>此处为了美观，选用线性渐变来做到下边一条分割线的效果</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color</span>: <span class="number">#fe9acf</span>;</span><br><span class="line"><span class="selector-class">.topnav</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$color</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">background</span>: linear-gradient(</span><br><span class="line">    <span class="number">180deg</span>,</span><br><span class="line">    rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>) <span class="number">0%</span>,</span><br><span class="line">    rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>) <span class="number">97%</span>,</span><br><span class="line">    <span class="number">#ffb5dc</span> <span class="number">97%</span>,</span><br><span class="line">    <span class="number">#ffb5dc</span> <span class="number">100%</span></span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">32px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">20</span>;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  &gt; <span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">6em</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">  &gt; <span class="selector-class">.menu</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap;</span><br><span class="line">    &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">1em</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &gt; <span class="selector-class">.toggleAside</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">32px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">32px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translateY(-<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">media</span> (max-width: 500px) &#123;</span><br><span class="line">    &gt; <span class="selector-class">.menu</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">    &gt; <span class="selector-class">.logo</span> &#123;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    &#125;</span><br><span class="line">    &gt; <span class="selector-class">.toggleAside</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: inline-block;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入 <code>App.vue</code> 看看效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;Topnav /&gt;</span><br><span class="line">    &lt;router-view /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; provide, ref &#125; from &quot;vue&quot;;</span><br><span class="line">import Topnav from &quot;./components/Topnav.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Topnav,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const width = ref(document.documentElement.clientWidth);</span><br><span class="line">    const menuVisible = ref(width.value &gt; 500 ? true : false);</span><br><span class="line">    window.onresize = () =&gt; &#123;</span><br><span class="line">      width.value = document.documentElement.clientWidth;</span><br><span class="line">      if (width.value &gt; 500) &#123;</span><br><span class="line">        menuVisible.value = true;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        menuVisible.value = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    provide(&quot;menuVisible&quot;, menuVisible);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">$max-width: 1200px;</span><br><span class="line">.app &#123;</span><br><span class="line">  max-width: $max-width;</span><br><span class="line">  margin-left: calc(50vw - 600px);</span><br><span class="line">  position: relative;</span><br><span class="line">  @media (max-width: $max-width) &#123;</span><br><span class="line">    margin-left: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="https://pic.ringoer.com/laby-ui-1.png" alt="效果图"></p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;显然顶边栏比较好做，且首页和文档页都需要它，那让我们先做好顶边栏&lt;/p&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://yoursite.com/categories/project/"/>
    
    
      <category term="ui-framework" scheme="http://yoursite.com/tags/ui-framework/"/>
    
  </entry>
  
  <entry>
    <title>UI 框架-起步</title>
    <link href="http://yoursite.com/project/ui-framework-start/"/>
    <id>http://yoursite.com/project/ui-framework-start/</id>
    <published>2021-02-20T12:00:00.000Z</published>
    <updated>2021-02-20T12:08:02.843Z</updated>
    
    <content type="html"><![CDATA[<p>先宣传一下我自己的 UI 框架 <a href="https://ringoer.gitee.io/laby-ui/index.html#/" target="_blank" rel="noopener">Laby UI - 一个基于Vue3的UI框架</a></p><p>既然是一个 UI 框架，总要有展示的地方吧</p><p>让我们先搭一个官网</p><a id="more"></a><hr><h1 id="设计选型"><a href="#设计选型" class="headerlink" title="设计选型"></a>设计选型</h1><p>从零自己想一个官网也太难了，还是参考一下别人的官方文档设计</p><p>本 UI 框架参考了 <a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener">element UI</a> 的设计风格</p><p>大致提供了如下页面</p><ol><li>顶边栏</li><li>首页</li><li>文档页<ol><li>侧边栏</li><li>内容区域</li></ol></li></ol><p>然后选择一个自己的风格，既然 element 选择了蓝色风格，我就选择粉色的风格吧</p><p>绝对不是什么个人恶趣味，而是来自 <a href="https://www.elwiki.net/w/Laby/zh-hans" target="_blank" rel="noopener">艾尔之光 - 娜薇</a>，2333</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><table><thead><tr><th>位置</th><th>特性</th></tr></thead><tbody><tr><td>布局</td><td>两侧留白，内容在中间<br>最大宽度 1200px，小于 1200px 时，宽度 100%<br>小于 500px 时，变为手机版</td></tr><tr><td>顶边栏</td><td>左侧是通往首页的跳转链接，右侧是通往文档页的跳转链接<br>视口小于 500px 时，只显示前往首页的跳转</td></tr><tr><td>首页</td><td>分为两部分，视觉效果部分和特点介绍部分</td></tr><tr><td>首页-视觉</td><td>粉色极光背景，中间放置两个跳转链接，一个前往 github 查看代码，另一个前往文档页</td></tr><tr><td>首页-特点</td><td>包含3个特点，分别是<br>1. 使用了 vue3 新特性<br>2. 使用 ts<br>3. 代码易读</td></tr><tr><td>文档页</td><td>文档页实际由顶边栏和本体构成，本体包含侧边栏和内容区域</td></tr><tr><td>顶边栏-文档页</td><td>小于 500px 时，在左侧额外显示弹出侧边栏的按键，并使得侧边栏不可见</td></tr><tr><td>侧边栏</td><td>默认可见，选中高亮，但视口宽度小于 500px 时，默认不可见<br>包含两个部分：指南和组件，各自有子级跳转</td></tr><tr><td>内容区域</td><td>根据侧边栏中选中的链接，显示 md 内容或组件范例内容</td></tr></tbody></table><h1 id="搭建官网"><a href="#搭建官网" class="headerlink" title="搭建官网"></a>搭建官网</h1><p>可以通过 <code>vite</code> 新建一个 vue3 项目</p><p>此处将项目命名为 <code>laby-ui</code></p><p>运行以下命令即可创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir laby-ui</span><br><span class="line"><span class="built_in">cd</span> laby-ui</span><br><span class="line">cva .</span><br></pre></td></tr></table></figure><p>然后运行以下命令，进行初始化，并启动应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>现在，就可以在 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 预览项目了</p><p>然后照抄淘宝移动端的 <code>meta</code>，以便更好适配移动端</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，因为我们是 ts 项目，所以把 <code>main.js</code> 改为 <code>main.ts</code></p><p>这时候，ts 可能无法识别 vue 后缀文件，加一个 shims 就好了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shims.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.vue' &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; ComponentOptions &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">  <span class="keyword">const</span> componentOptions: ComponentOptions</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> componentOptions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当静态报错为”无法识别 vue 后缀的文件”时，打开该 ts，再返回原代码，即可解决红线报错</p><h1 id="整体布局设计"><a href="#整体布局设计" class="headerlink" title="整体布局设计"></a>整体布局设计</h1><p>根据需求分析，我们得到如下推论</p><p>首先，最大宽度等限制，是作用于整个 app 上的，所以这方面的样式应该写在 <code>app.vue</code> 上</p><p>其次，首页和文档页的顶边栏，其功能分别为</p><table><thead><tr><th>位置</th><th>功能</th></tr></thead><tbody><tr><td>首页</td><td>不可以弹出菜单</td></tr><tr><td>文档页</td><td>根据情况显示或隐藏菜单</td></tr></tbody></table><p>可见并不完全相同，也就是说不是同一个组件的复用，所以应该将顶边栏组件分别嵌入首页和文档页组件，而不是嵌入 <code>app.vue</code></p><p>然后，首页显然没有侧边栏，所以首页的内容直接写在其模板内即可，而文档页需要侧边栏和内容区域</p><p>但是文档页的侧边栏，实际上与弹出的顶部菜单是相同的内容，所以只需要编写一次，然后复用为侧边栏和顶部菜单即可</p><p>除此之外，文档页的内容区域，还要分别展示 markdown 内容和组件内容，所以内容区域要分成两种进行编写</p><p>综上，首页大致为上下结构，恒定不变；文档页大致为T字结构，小于 1200px 时为上下结构，附有弹出菜单的选项。图示可以参考 <a href="https://ringoer.gitee.io/laby-ui/index.html#/" target="_blank" rel="noopener">Laby UI</a></p><p>让我们先完成 App 整体的控制</p><p>先引入总控制的样式表 <code>index.scss</code>，记得删除旧的 <code>index.css</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span>,</span><br><span class="line"><span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">color</span>: inherit;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-tag">h3</span>,</span><br><span class="line"><span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-tag">h5</span>,</span><br><span class="line"><span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#1d2c40</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: -apple-system, <span class="string">"Noto Sans"</span>, <span class="string">"Helvetica Neue"</span>, Helvetica,</span><br><span class="line">    <span class="string">"Nimbus Sans L"</span>, Arial, <span class="string">"Liberation Sans"</span>, <span class="string">"PingFang SC"</span>, <span class="string">"Hiragino Sans GB"</span>,</span><br><span class="line">    <span class="string">"Noto Sans CJK SC"</span>, <span class="string">"Source Han Sans SC"</span>, <span class="string">"Source Han Sans CN"</span>,</span><br><span class="line">    <span class="string">"Microsoft YaHei"</span>, <span class="string">"Wenquanyi Micro Hei"</span>, <span class="string">"WenQuanYi Zen Hei"</span>, <span class="string">"ST Heiti"</span>,</span><br><span class="line">    SimHei, <span class="string">"WenQuanYi Zen Hei Sharp"</span>, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.icon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>; <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: -<span class="number">0.15em</span>;</span><br><span class="line">  fill: currentColor;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>main.ts</code> 中的引入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./index.scss'</span></span><br></pre></td></tr></table></figure><p>最后完成 <code>App.vue</code> 的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">$max-width: 1200px;</span><br><span class="line">.app &#123;</span><br><span class="line">  max-width: $max-width;</span><br><span class="line">  margin-left: calc(50vw - 600px);</span><br><span class="line">  position: relative;</span><br><span class="line">  @media (max-width: $max-width) &#123;</span><br><span class="line">    margin-left: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>通过 <code>background-color</code> 检查一下宽度，ok</p><p>注意使用 scss 需要安装 sass 依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D sass</span><br></pre></td></tr></table></figure><p>千万不要丢了 <code>-D</code>，否则就不是安装到开发环境了</p><h1 id="路由设计"><a href="#路由设计" class="headerlink" title="路由设计"></a>路由设计</h1><p>既然有多个页面，那肯定就要通过路由进行跳转</p><p>路由显然是使用 <code>vue-router</code>，首先安装它</p><p>要注意，默认安装的 <code>vue-router</code> 是 <code>3.x.x</code> 版本的，只能用于 vue2</p><p>要想用于 vue3，必须是 <code>4.x.x</code> 版本</p><p>通过 <code>npm info vue-router</code> 可以看到最新版（next 版本）是 <code>4.0.4</code>（如有变化，下载最新版即可），则我们通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router@4.0.4</span><br></pre></td></tr></table></figure><p>安装适合 vue3 的 <code>vue-router</code></p><p>然后设计路由，这个因人而异，这里给出我的路由设计如下</p><table><thead><tr><th>目标</th><th>路由</th></tr></thead><tbody><tr><td>首页</td><td>/</td></tr><tr><td>文档页</td><td>/document</td></tr><tr><td>文档页 - 介绍</td><td>/document/introduction</td></tr><tr><td>文档页 - 安装</td><td>/document/install</td></tr><tr><td>文档页 - 快速上手</td><td>/document/start</td></tr><tr><td>文档页 - [组件名]</td><td>/document/[componentName]</td></tr></tbody></table><p>至于 <code>router.ts</code> 的内容，因为现在暂无视图，所以我们先搁置，写一个空的引入就好</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/router.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createWebHistory, createRouter &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> history = createWebHistory()</span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">    history,</span><br><span class="line">    routes: [</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>然后在 <code>main.ts</code> 中引入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.scss'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line">createApp(App).use(router).mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><h1 id="其余部分"><a href="#其余部分" class="headerlink" title="其余部分"></a>其余部分</h1><p>篇幅所限，其余部分分开写了，请按顺序查看以下文章</p><p><a href="https://ringoer.com/project/ui-framework-topnav/" target="_blank" rel="noopener">UI 框架-顶边栏</a></p><p><a href="https://ringoer.com/project/ui-framework-views/" target="_blank" rel="noopener">UI 框架-首页和文档页</a></p><p><a href="https://ringoer.com/project/ui-framework-button/" target="_blank" rel="noopener">UI 框架-Button 组件</a></p><p><a href="https://ringoer.com/project/ui-framework-switch/" target="_blank" rel="noopener">UI 框架-Switch 组件</a></p><p><a href="https://ringoer.com/project/ui-framework-dialog/" target="_blank" rel="noopener">UI 框架-Dialog 组件</a></p><p><a href="https://ringoer.com/project/ui-framework-tabs/" target="_blank" rel="noopener">UI 框架-Tabs 组件</a></p><p><a href="https://ringoer.com/project/ui-framework-rollup/" target="_blank" rel="noopener">UI 框架-打包发布</a></p><p><a href="https://ringoer.com/project/ui-framework-improve/" target="_blank" rel="noopener">UI 框架-完善官网</a></p><p><a href="https://ringoer.com/project/ui-framework-code-improve/" target="_blank" rel="noopener">UI 框架-代码优化</a></p><p><a href="https://ringoer.com/project/ui-framework-deploy/" target="_blank" rel="noopener">UI 框架-完工部署</a></p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先宣传一下我自己的 UI 框架 &lt;a href=&quot;https://ringoer.gitee.io/laby-ui/index.html#/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Laby UI - 一个基于Vue3的UI框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;既然是一个 UI 框架，总要有展示的地方吧&lt;/p&gt;
&lt;p&gt;让我们先搭一个官网&lt;/p&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://yoursite.com/categories/project/"/>
    
    
      <category term="ui-framework" scheme="http://yoursite.com/tags/ui-framework/"/>
    
  </entry>
  
  <entry>
    <title>SCSS 简述</title>
    <link href="http://yoursite.com/frontend/css-scss/"/>
    <id>http://yoursite.com/frontend/css-scss/</id>
    <published>2021-02-17T03:47:00.000Z</published>
    <updated>2021-02-17T03:52:31.602Z</updated>
    
    <content type="html"><![CDATA[<p>SCSS 是 CSS 的超集</p><p>基于笔者自己的使用体验</p><a id="more"></a><hr><p>scss 完全兼容 css 语法，并在此上提供了一些新语法</p><ol><li>$ 变量名</li><li>嵌套层级</li><li>mixin</li><li>include</li></ol><h1 id="变量名"><a href="#变量名" class="headerlink" title="$ 变量名"></a>$ 变量名</h1><p>在 scss 中，可以声明 $ 开头的变量名，作为常量在下文中使用</p><p>示例如下</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color</span>: <span class="number">#ababab</span>;</span><br><span class="line"><span class="selector-id">#app</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以将 <code>#app</code> 的背景色设为 <code>#ababab</code></p><h1 id="嵌套层级"><a href="#嵌套层级" class="headerlink" title="嵌套层级"></a>嵌套层级</h1><p>在 scss 中，包含关系可以直接写在嵌套中，不需要像 css 一样全部写在根</p><p>设有如下 DOM 结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">            内容</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>则如果要分别设置 标题 和 内容 部分的样式，并给 <code>#app</code> 设置 hover 样式，在原生 css 中，要这么写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span>&gt;<span class="selector-class">.title</span>&#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#app</span>&gt;<span class="selector-class">.context</span>&#123;</span><br><span class="line">    yyy</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#app</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    zzz</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 scss 中，只需要这么写</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span>&#123;</span><br><span class="line">    &gt;<span class="selector-class">.title</span>&#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">    &gt;<span class="selector-class">.content</span>&#123;</span><br><span class="line">        yyy</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;:hover&#123;</span><br><span class="line">        zzz</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于子元素选择器，可以直接嵌套书写</p><p>对于伪元素、伪类，需要使用 <code>&amp;</code> 来作为当前层级的标识符</p><p>在上文中的 <code>&amp;:hover</code> 等效于 <code>#app:hover</code></p><h1 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h1><p>当有一套固定的模式 css 要适用于多种不同属性时，可以使用 <code>@mixin</code> 语法</p><p>类似于 css 中的 function</p><p>设有如下 mixin</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> layout(<span class="variable">$color</span>)&#123;</span><br><span class="line">    &amp;:hover&#123;</span><br><span class="line">        <span class="attribute">background-color</span>:<span class="variable">$color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则表示声明了一个函数 layout，要求传入一个变量，在函数中设为 hover 状态下的背景色</p><p>声明之后，使用 <code>include</code> 进行混入</p><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include</h1><p>设有上述 <code>mixin</code>，则可以按不同情况混入</p><p>比如要在 <code>.title</code> 和 <code>.content</code>，分别适配不同的背景色，则可以有如下写法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span>&#123;</span><br><span class="line">    &gt;<span class="selector-class">.title</span>&#123;</span><br><span class="line">        <span class="variable">$color</span>: blue;</span><br><span class="line">        @<span class="keyword">include</span> layout(<span class="variable">$color</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &gt;<span class="selector-class">.content</span>&#123;</span><br><span class="line">        <span class="variable">$color</span>: yellow;</span><br><span class="line">        @<span class="keyword">include</span> layout(<span class="variable">$color</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$color</span>: red;</span><br><span class="line">    @<span class="keyword">include</span> layout(<span class="variable">$color</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等效于写作</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span>&#123;</span><br><span class="line">    &gt;<span class="selector-class">.title</span>&#123;</span><br><span class="line">        &amp;:hover&#123;</span><br><span class="line">            <span class="attribute">background-color</span>: blue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &gt;<span class="selector-class">.content</span>&#123;</span><br><span class="line">        &amp;:hover&#123;</span><br><span class="line">            <span class="attribute">background-color</span>: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;:hover&#123;</span><br><span class="line">        <span class="attribute">background-color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，<code>mixin</code> 和 <code>include</code> 是搭配使用的，且使用效果为直接替换在原位</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SCSS 是 CSS 的超集&lt;/p&gt;
&lt;p&gt;基于笔者自己的使用体验&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Vue 3 新特性简述</title>
    <link href="http://yoursite.com/frontend/vue3-features/"/>
    <id>http://yoursite.com/frontend/vue3-features/</id>
    <published>2021-02-16T12:03:00.000Z</published>
    <updated>2021-02-17T03:51:52.693Z</updated>
    
    <content type="html"><![CDATA[<p>vue 都发布新版本 vue3 了，不跟上时代怎么可以</p><p>本文结合 ts，且根据笔者自己的使用体验</p><a id="more"></a><hr><p>目录大致如下</p><ol><li>构建</li><li>路由</li><li>构造选项</li><li>ref</li><li>钩子函数</li><li>标签属性</li><li>teleport</li><li>总结</li><li>参考文章</li></ol><h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><p>与 vue2 使用 webpack 不同，vue3 可以使用 vite 进行构建</p><blockquote><p>Vite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 rollup 打。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题。</p></blockquote><p>简单说就是，在生产环境使用模块，省略打包步骤，开发环境可以秒级启动</p><p>安装 vite，只需要执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g create-vite-app</span><br></pre></td></tr></table></figure><p>安装成功后，可以通过两个命令来构建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create-vite-app [projectName]</span><br><span class="line">// 或</span><br><span class="line">cva [projectName]</span><br></pre></td></tr></table></figure><p>即可在当前目录下构建一个基于 vite 的 vue3 新项目</p><p>之后通过命令行 <code>cd</code> 进入该项目目录，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>初始化 <code>node_modules</code> 之后，再运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>即可启动项目预览了，通常会启动在 3000 端口</p><p>但是，当在项目中使用 ts 时，ts 无法识别 vue 后缀的文件，这时候可以在项目的 <code>src</code> 目录下新建一个文件 <code>shims.d.ts</code> 来处理识别问题</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shims.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.vue' &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; ComponentOptions &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">  <span class="keyword">const</span> componentOptions: ComponentOptions</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> componentOptions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当静态报错为”无法识别 vue 后缀的文件”时，打开该 ts，再返回原代码，即可解决红线报错</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>先来看一个 vue2 的路由示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> login <span class="keyword">from</span> <span class="string">'@/components/others/login'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    mode: <span class="string">'history'</span>,</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">'/login'</span>,</span><br><span class="line">            name: <span class="string">'login'</span>,</span><br><span class="line">            component: login</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>可见，vue2 中声明一个路由，是使用 new 操作符来新建一个 <code>Router</code> 对象，并向其构造函数中传入 options 来达成的</p><p>现在再给出一个 vue3 的路由示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createWebHistory, createRouter &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./views/Home.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> history = createWebHistory()</span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: <span class="string">'/'</span>, component: Home &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>细节上，vue3 采用了 <code>createRouter</code> 函数来创建一个 <code>Router</code> 对象，对用户隐藏了内部细节，但仍然要求用户传入一个 options，且该 options 也主要包括 <code>mode</code> 和 <code>routes</code> 两个选项</p><p>同时，在 vue3 中，声明一个路由模式，由字符串改为了函数返回值，具体对应如下</p><table><thead><tr><th>vue2 写法</th><th>vue3 写法</th></tr></thead><tbody><tr><td>mode 字段</td><td>history 字段</td></tr><tr><td>mode: ‘hash’</td><td>history: createWebHashHistory()</td></tr><tr><td>mode: ‘history’</td><td>history: createWebHistory()</td></tr><tr><td>mode: ‘memory’</td><td>history: createMemoryHistory()</td></tr></tbody></table><p>整体上大同小异，使用时注意细节即可</p><h1 id="构造选项"><a href="#构造选项" class="headerlink" title="构造选项"></a>构造选项</h1><p>一个 vue2 的 script 标签写法，大致有如下格式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props:&#123;</span><br><span class="line">        a:&#123;</span><br><span class="line">            <span class="keyword">type</span>: <span class="built_in">String</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="string">'233'</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            ...data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// and other lifecycle</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        xxx()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诸如此类</p><p>但是在 vue3 中，除 <code>props</code> 写法照旧之外，其余均可以通过 <code>setup</code> 方法进行处理</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props:&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    setup()&#123;</span><br><span class="line">        <span class="keyword">const</span> a = ref(<span class="string">'233'</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>setup</code> 方法中，所有通过 <code>return</code> 暴露出的变量，都等效于 vue2 中 <code>data</code> 暴露的变量；所有通过 <code>return</code> 暴露出的函数，都等效于 vue2 中 <code>methods</code> 暴露的函数</p><p>而生命周期钩子，也可以直接写在 <code>setup</code> 中，如 <code>mounted</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue2</span></span><br><span class="line">mounted()&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue3</span></span><br><span class="line">setup()&#123;</span><br><span class="line">    onMounted(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// some code</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种类似于 DOM 事件中 <code>click -&gt; onClick</code> 的转化，将 <code>mounted</code> 转化为了 <code>onMounted</code>，此时 <code>onMounted</code> 接受一个函数作为参数</p><p>除此之外，要在 <code>setup</code> 中使用传递到组件上的参数，在 vue2 中只需要使用 <code>this.xxx</code> 就可以访问到，而在 vue3 中必须要在 <code>setup</code> 的形参列表中声明后才可以使用</p><p><code>setup</code> 接受两个参数，第一个是绑定参数 props，第二个是上下文 context</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setup(props, context)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;xxx&#125; = props</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等效于 vue2 中的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props:[<span class="string">'xxx'</span>],</span><br><span class="line">data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            xxx: <span class="keyword">this</span>.xxx</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，在 props 中未声明的绑定参数，都去哪了呢？</p><p>在 vue2 中，可以通过 <code>this.$attrs</code> 来访问到其余的参数</p><p>而在 vue3 中，要通过 <code>context.attrs</code> 来访问</p><p>注意：</p><ol><li>在父组件中绑定到子组件的事件，不会出现在 props 里</li><li>props不支持事件，支持其余属性，不在props里的都会到attrs里，但 props 要先声明</li><li>props里有多种类型，attrs只有字符串</li></ol><p>如果不希望子组件继承父组件给出的参数，也可以显式指定不继承</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    inheritAttrs: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>inheritAttrs: false</code> 选项<strong>不会</strong>影响 <code>style</code> 和 <code>class</code> 的绑定</p><p>综上，假如有一个需求是，父组件会向子组件中传入若干参数，而只希望绑定变量名为 <code>xxx</code> 以外的其余变量，那么可以有如下写法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setup(props, context)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;xxx, ...rest&#125; = context.attrs</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        rest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在模板中，要绑定的地方，写入 <code>v-bind=&quot;rest&quot;</code> 即可绑定所有参数</p><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p>细心的朋友应该已经注意到了，上面出现一个名为 <code>ref</code> 的用法，且用法形似一个函数</p><p>熟悉 ES6 的 proxy 的话，可以看出 <code>ref</code> 其实就是返回一个对传入数据的代理，这个代理拦截了 get 和 set 操作，并在 set 的时候通知视图更新</p><p>熟悉 react 的朋友，是不是感觉和 <code>useState</code> 很像？其实就是把 getter/setter 返回到同一个对象身上而已，2333</p><p>设在以下代码段中使用 <code>ref</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visible = ref([<span class="literal">true</span>,<span class="literal">true</span>])</span><br></pre></td></tr></table></figure><p>则有以下特点</p><ol><li><p>可以使用 const 声明代理对象，反正是这个对象不能变，不是里面的代理内容不能变</p></li><li><p>在 script 标签中读取数组内容时，必须使用 <code>visible.value</code> 才能取得数组，直接访问 <code>visible</code> 取得的是代理对象</p><p><strong>尽可能不要直接修改代理内容</strong></p></li><li><p>在 template 标签（模板）中读取数组内容时，直接访问 <code>visible</code> 即可得到数组内容</p></li><li><p>当模板中引用的代理对象的 set 代理，发现代理内容被更新时，会自动通知视图进行更新</p></li><li><p><code>ref</code> 代理自带 vue2 的 data 做不到的深度监听，比如修改数组项、或对象的字段</p></li></ol><h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><p>vue3 新增了一个重要的钩子函数 <code>watchEffect</code></p><p>当然，同时可以使用 vue2 的 watch 属性，不赘述了</p><p><code>watchEffect</code> 的主要效果是，注册一个侦听，该侦听会在声明时立刻执行，并在之后所有生命周期函数被调用前，或 <code>setup</code> 函数被调用时执行</p><p>一般写法如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// work</span></span><br><span class="line">    onInvalidate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>watchEffect</code> 接受两个参数，其中第一个参数必选，第二个参数可选</p><p>第一个参数是每次执行时的执行函数，该函数会提供一个入参，表示侦听执行失败时的善后函数，类似于 <code>catch</code> 语句块中的 <code>finally</code>。此处的入参 <code>onInvalidate</code> 也接受一个函数，表示善后时执行的内容</p><p>第二个参数表示 <code>watchEffect</code> 的配置，一般用于配置 <code>watchEffect</code> 执行的时机</p><p>例如以下代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// work</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    flush: <span class="string">'post'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>options</code> 中的字段 <code>flush</code>，默认值是 <code>&#39;pre&#39;</code>，表示在钩子函数执行之<strong>前</strong>就执行侦听，所以如果想在之后执行，就要手动设置为 <code>&#39;post&#39;</code></p><p>注意，会在所有生命周期函数被调用后执行，意味着它有可能在 <code>beforeCreate</code> 生命周期之前，或 <code>created</code> 之前就被执行，所以请注意控制其执行时机 </p><h1 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h1><p>也许有人觉得，写一个 <code>setup</code> 函数，和 vue2 好像没有什么本质差别</p><p>但是，vue3 可以在 script 标签上另加一个新属性： <code>setup</code> </p><p>当写一个 script 标签的时候，可以写作如下形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">xxx</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>此时 script 标签内部的所有内容，都被视为运行在 <code>setup</code> 函数中</p><p>那 <code>setup</code> 的两个参数怎么办呢？直接写在属性上就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup=&quot;props,context&quot;&gt;</span><br><span class="line">xxx</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样就可以在 script 标签中正常使用 <code>props</code> 和 <code>context</code> 了</p><p>那原来在 <code>setup</code> 中的 return 导出怎么办呢？答案是可以直接 export</p><p>例如原来有如下 <code>setup</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setup()&#123;</span><br><span class="line">    <span class="keyword">const</span> data=ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;data&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以直接写作如下模样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup=&quot;props,context&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    // 原有 vue 配置</span><br><span class="line">&#125;</span><br><span class="line">export const data = ref(0)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>之后的使用与上例相同，直接在模板中引用即可</p><p>但是，虽然看起来很装逼，不过该写法尚未得到广泛支持，反正到2021年2月16日为止，我在我的编辑器里是用不了，2333</p><h1 id="teleport"><a href="#teleport" class="headerlink" title="teleport"></a>teleport</h1><p>vue3 还有一个重要的新组件： <code>teleport</code></p><p>它用来将新建的渲染挂载到页面上的某个目标，而不是原定位置</p><p>考虑以下情况：我们需要制作一个弹窗功能，希望弹窗弹出后，其在 DOM 树的位置是 body 的直接子级</p><p>那么可以得到如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;template v-if=&quot;visible&quot;&gt;</span><br><span class="line">&lt;teleport to=&quot;body&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">                对话框内容</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/teleport&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>那么，上述模板在检测到 <code>visible</code> 变为 true 之后，要渲染内部的内容</p><p>内部第一层是 <code>teleport</code>，其 <code>to</code> 属性为 <code>body</code>，那么会将 <code>teleport</code> 内部的所有内容，挂载到 <code>body</code> 上，成为其最后一个子结点</p><p>发现了吧？其实 <code>teleport</code> 最重要的就是 <code>to</code> 属性，该属性接受一个 CSS 选择器，指定要挂载的位置</p><p>选择器重复怎么办？自己看看 JQuery 吧（</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>vue3 还是搞出来一些很好玩的东西，有空多研究一下</p><p>而且和 ts 相性很好，又吸收了 react 的优点，未来超过 react 不是没有可能</p><p>但是！！！太新的特性，使用的时候要先检查一下有没有得到支持了，不要改完代码才发现没支持，又要改回去</p><p>这里我要点名表扬 <code>git reset --hard [version]</code>，存档合理的话，这简直是神技，2333</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.zhihu.com/question/394062839/answer/1496127786" target="_blank" rel="noopener">如何看待 Web 开发构建工具 Vite？ - 阿里巴巴淘系技术</a></p><p><a href="https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#%E5%81%9C%E6%AD%A2%E4%BE%A6%E5%90%AC" target="_blank" rel="noopener">响应式计算和侦听 - watchEffect</a></p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue 都发布新版本 vue3 了，不跟上时代怎么可以&lt;/p&gt;
&lt;p&gt;本文结合 ts，且根据笔者自己的使用体验&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks</title>
    <link href="http://yoursite.com/frontend/react-hooks/"/>
    <id>http://yoursite.com/frontend/react-hooks/</id>
    <published>2021-01-09T10:53:00.000Z</published>
    <updated>2021-01-14T15:25:35.325Z</updated>
    
    <content type="html"><![CDATA[<p>在函数组件里天天 use 来 use 去，我也想自己整点</p><a id="more"></a><hr><h1 id="什么是-React-Hooks"><a href="#什么是-React-Hooks" class="headerlink" title="什么是 React Hooks"></a>什么是 React Hooks</h1><blockquote><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</p></blockquote><p>其实就是写类组件太麻烦了，函数组件有的功能又没有，所以就用 Hook 来实现所需的效果</p><p>平常见到的那些 useXXX 就是 Hook</p><h1 id="为什么需要-Hook"><a href="#为什么需要-Hook" class="headerlink" title="为什么需要 Hook"></a>为什么需要 Hook</h1><p>可以参看官方给出的 <a href="https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation" target="_blank" rel="noopener">Hook 简介 - 动机</a></p><p>简单说就是，写函数组件就是要用 Hook</p><h1 id="常用-Hooks"><a href="#常用-Hooks" class="headerlink" title="常用 Hooks"></a>常用 Hooks</h1><p>一般有以下 Hook 是常用的</p><ol><li>useState</li><li>useEffect / useLayoutEffect</li><li>useContext</li><li>useReducer</li><li>useMemo / useCallback</li><li>useRef</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在开始介绍 Hook 之前，需要先介绍一下注意事项</p><h3 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h3><p>react 要求在每次执行组件渲染的时候，都要执行相同的 Hook 序列，否则会认为代码出错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">2</span> === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [m, setM] = useState(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会触发 react 报错，因为每次执行时，有可能出现不一样的 Hook 序列</p><p>同样的，循环、嵌套函数也可能出现上述问题，请根据具体报错进行处理</p><h3 id="只在-React-函数中调用-Hook"><a href="#只在-React-函数中调用-Hook" class="headerlink" title="只在 React 函数中调用 Hook"></a>只在 React 函数中调用 Hook</h3><p>Hook 在别的函数中，是不起作用的，因为它只为函数组件服务</p><p>所以，Hook 的使用场景必须是以下两个条件之一</p><ol><li>在 react 函数组件中调用 Hook</li><li>在自定义 Hook 中调用其它 Hook</li></ol><p>关于自定义 Hook，下文中会有描述，可以通过目录快进</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>类组件可以通过 <code>this.state = {}</code> 来声明私有变量，但是函数组件不行，所以就需要 <code>useState</code>，其作用实际上就是创建一个变量</p><p>通常使用如下形式创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上述例子创建了一个变量，赋初始值为 0，并取得其 <code>getter/setter</code> API</p><p><code>useState</code> 接受一个传入参数，表示要创建的变量的初始值，之后返回一个具有两个值的数组</p><p>第一个值是该变量的 <code>getter</code>，第二个则是对应的 <code>setter</code></p><p>对于 <code>getter</code>，像普通变量一样使用即可，比如此时直接对 <code>n</code> 取值，就可以取到值 0</p><p>对于 <code>setter</code>，可以有两种调用方式</p><ol><li><p>传入一个新值，此时会完全覆盖旧值</p><p>当且仅当新值与旧值地址不同时，会触发 render</p></li><li><p>传入一个函数，取函数的返回值作为新值</p><p><code>setter</code> 会向这个函数传入一个参数，该参数的值是目标变量当前的最新值</p></li></ol><p>当使用方式 1，直接传入一个新值时，需要注意以下两点</p><ol><li><p>如果此时目标变量是一个对象且具有多个字段，则传入新对象时，不会同步旧有字段的值</p><p>例如，此时对象是 <code>{n: 0, m:1}</code>，通过 <code>setter</code> 设置新值为 <code>{n: 1}</code></p><p>则之后 <code>getter</code> 只能取到 <code>{n: 1}</code>，字段 m 会丢失</p></li><li><p>不要修改旧有的值再传入</p><p>例如，此时对象是 <code>{n: 0}</code>，先直接通过 <code>getter</code> 执行 <code>obj.n ++</code>，再通过 <code>setter</code> 设置新值为 <code>obj</code></p><p>则因为新值和旧值的地址相等，即使内部值变化了，react 也还是认为这个变量并没有发生变化，所以不会重新触发 render</p></li></ol><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p><code>useEffect</code> 最大的作用就是监听</p><p><code>useEffect</code> 要求传入两个参数，第一个参数是回调函数，第二个参数是一个数组，表示当数组中列出的对象变化后，执行回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 n 变化后，输出 'n changed'</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'n changed'</span>),[n])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅在函数组件初始化时，输出 'component start'</span></span><br><span class="line"><span class="comment">// 通常用于模拟生命周期钩子函数 componentDidMount</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'component start'</span>),[])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不论 state 中任意变量变化了，都输出 'something changed'</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'something changed'</span>))</span><br></pre></td></tr></table></figure><p>注意，此处所有的回调函数，都会在页面重绘后才执行</p><p><code>useEffect</code> 还有一个功能类似的函数，名为 <code>useLayoutEffect</code></p><p><code>useLayoutEffect</code> 会在 DOM diff 之后，页面重绘之前执行</p><p>但由于上述特点会浪费时间，阻碍用户看到新页面，所以一般不使用 <code>useLayoutEffect</code>，除非使用 <code>useEffect</code> 无法解决问题</p><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>提供组件上下文，让变量可以穿透组件，从父组件到达子组件</p><p>需要配合 <code>React.createContext</code> 使用</p><p>一个使用例如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">"#000000"</span>,</span><br><span class="line">    background: <span class="string">"#eeeeee"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">"#ffffff"</span>,</span><br><span class="line">    background: <span class="string">"#222222"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(themes.dark);</span><br><span class="line">  <span class="keyword">const</span> change = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setValue(themes.light)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;value&#125;&gt;</span><br><span class="line">      &lt;ThemedButton /&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;button onClick=&#123;change&#125;&gt;change&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ThemedButton(props) &#123;</span></span><br><span class="line"><span class="regexp">  const theme = useContext(ThemeContext);</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      I am styled by theme context!</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>先声明 <code>themes</code> 作为父子组件通用的内容</p><p>然后通过 <code>React.createContext</code> 创建上下文，此处返回的变量可以<strong>任意命名</strong></p><p>之后，在父组件中，通过 <code>useState</code> 创建一个响应式变量，用来存放当前提供给子组件的主题，并在模板中，使用一对 <code>ThemeContext.Provider</code> 标签，包裹住可以使用上下文的其它内容</p><p>此处允许子组件 <code>ThemedButton</code> 以及父组件中的一个 <code>button</code> 元素使用上下文</p><p>注意，不论你的上下文变量叫什么名字，此处的包裹标签都必须是 <code>.Provider</code> 形式</p><p>此时就可以在子组件中，通过 <code>useContext</code> 获取上下文，该 Hook 要求传入上下文变量作为参数，并返回此时父组件提供的具体内容，之后就可以在子组件的模板中使用了</p><p><code>useContext / createContext</code> 组合通常用来提供<strong>局部的全局变量</strong></p><p>之所以是全局变量，是因为其可以在父子组件之间通用</p><p>之所以又称为局部，是因为我们通常不希望有太多的变量污染全局空间，容易产生冲突，难以维护，所以最好不要放在主入口中</p><p>注意，上下文的修改不是响应式的，例如直接通过赋值语句修改上例中的 <code>value</code> 的话，并不会触发视图更新，所以上例采用了 <code>useState</code> 提供的响应式更新的方法</p><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>是一种 <code>useState</code> 的替代方案，使用方法类似于 VUE 的 VUEX，都是一个存放数据的地方，加上预先声明的若干操作，之后通过 <code>dispatch</code> 提交操作</p><p>通常使用如下模样使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><p>要求传入三个参数，按顺序分别是对数据的一组操作、数据初始值、初始化方法，其中第三个参数是可选的</p><p>该 Hook 的两个返回值，按顺序分别是数据的 <code>getter</code>，以及向对应数据提交操作的 <code>dispatch</code> 函数</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>一个使用例如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'decrement'</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'increment'</span> &#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>先声明要引入的初始值，一般命名为某种 state</p><p>然后以函数形式声明一组操作，该函数接受两个参数，按顺序分别是数据对象和 <code>dispatch</code> 提交上来的对象</p><p>按照约定，一般将操作类型放在 <code>type</code> 字段，将额外的操作数放在 <code>payload</code> 字段</p><p>在这组操作中，通过判断 <code>action.type</code>，来确定要执行的是哪种操作，然后返回一个新的对象，作为新的 <code>state</code></p><p>需要注意的是，此处的返回值不会与旧的 <code>state</code> 自动合并，在使用中需要手动使用 spread 语法进行展开赋值</p><p>从上例的模板可以看出，对 <code>state</code> 的读操作，其写法与直接读源数据相同；对于 <code>dispatch</code> 函数，要求传入一个对象，该对象在操作函数中作为 <code>action</code> 出现</p><h3 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h3><p>也可以采用函数式声明，进行惰性初始化，这么做可以将用于计算 state 的逻辑提取到 reducer 外部，也为将来对重置 state 的 action 做处理提供了便利</p><p>一个惰性初始化的例子如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">count</span>: initialCount &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> init(action.payload);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialCount, init);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'reset'</span>, <span class="attr">payload</span>: initialCount &#125;)&#125;&gt;</span><br><span class="line">          Reset</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'decrement' &#125;)&#125;&gt;-&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'increment'</span> &#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>显然，通过函数式初始化，可以对数据进行复杂的预处理，并且不会与 <code>reducer</code> 过耦合</p><p>但写法较为麻烦，实践中一般没什么必要，有需要的时候再重构吧</p><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>常见的 <code>useMemo</code> 格式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> fn(a, b), [a, b]);</span><br></pre></td></tr></table></figure><p>接受两个参数，返回一个缓存值</p><p>第一个参数是一个函数，该函数的传入参数为空，取该函数的返回值作为 <code>useMemo</code> 的返回值</p><p>第二个参数是一个监听数组，效果同 <code>useState</code></p><p>可以通过该 Hook 回避多余的渲染</p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>一般我们执行一个函数的时候，都需要传入参数，但是用 <code>useMemo</code> 第一个参数必须为空，所以就会变成这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (a,b) =&gt; fn(a, b), [a, b]);</span><br></pre></td></tr></table></figure><p>这是一个返回函数的函数，一看就很丑</p><p>所以有一个语法糖 <code>useCallback</code>，自带可选参数</p><p>格式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useCallback(<span class="function">(<span class="params">a,b</span>) =&gt;</span> fn(a, b), [a, b]);</span><br></pre></td></tr></table></figure><p>就是这样，与上面提到的 <code>useMemo</code> 的例子完全等效</p><h3 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h3><p>也可以通过 <code>React.memo</code> 函数，来缓存整个组件</p><p>其格式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果把 nextProps 传入 render 方法的返回结果与</span></span><br><span class="line"><span class="comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span></span><br><span class="line"><span class="comment">  否则返回 false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(MyComponent, areEqual);</span><br></pre></td></tr></table></figure><p>要求传入两个参数，返回缓存的组件</p><p>第一个参数是函数组件</p><p>第二个参数可选，是一个判断函数，通过该函数进行对于新旧 <code>props</code> 的判断，返回 <code>true / false</code> 分别表示认为 <code>props</code> 变化或没有变化 </p><p>当传递给 <code>MyComponent</code> 的 <code>props</code> 没有发生变化时，组件不会重新渲染</p><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>之前说过，react 的推荐思想之一就是<strong>对象不变性</strong></p><p>但是这样的话，每次都要产生一个新对象，各种开销不得不考虑</p><p>于是就有了 <code>useRef</code> 这个 Hook，用来在组件中产生一个唯一的引用，使其在每次重新渲染的时候都保持同一个引用</p><p>一般格式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure><p>传入一个初始值，该初始值可以是对象</p><p>之后返回一个唯一的引用，通过该对象的 <code>current</code> 字段，取得我们传入的数据</p><p>一个用例如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过创建一个初始值为空的引用，然后通过 <code>ref</code> 属性绑定到 DOM 元素上，之后该引用的 <code>current</code> 字段值就一直是该 DOM 元素</p><p>乍一看是不错，解决了重复产生多个对象的问题，但是又产生了另一个问题——当 ref 对象内容发生变化时，<code>useRef</code> 并<strong>不会</strong>通知你。变更 <code>current</code> 属性不会引发组件重新渲染</p><p>此时需要用户手动调用渲染函数，或采取如下的补救方法</p><h3 id="补救方法"><a href="#补救方法" class="headerlink" title="补救方法"></a>补救方法</h3><p>我们知道 <code>useState</code> 返回的 <code>setter</code> 可以刷新页面，那么我们就可以利用这个 Hook</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = useRef(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> [_, fresh] = useState(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        count.current++;</span><br><span class="line">fresh(<span class="built_in">Math</span>.random());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        &#123;count.current&#125;</span><br><span class="line">        &lt;button onClick=&#123;onButtonClick&#125;&gt;refresh&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>useState</code> 取得一个可以刷新页面的函数，之后每次在 <code>count.current</code> 更新时，传入保证不相同的随机数，就可以做到更新页面的效果了</p><h3 id="子组件传递-ref"><a href="#子组件传递-ref" class="headerlink" title="子组件传递 ref"></a>子组件传递 ref</h3><p>但是 ref 不能通过 props 传递，怎么办呢</p><p>可以通过 <code>React.forwardRef</code> 来包装一个子组件，并向下传递 ref</p><p><code>React.forwardRef</code> 函数接受一个函数组件作为内部组件，并向该内部组件提供两个参数</p><p>第一个参数是正常的 props，第二个参数则是绑定在当前包装器组件上的 ref</p><p>一个用例如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">        inputEl.current.focus();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        &lt;MyInput ref=&#123;inputEl&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">        &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyInput = React.forwardRef(<span class="function"><span class="keyword">function</span>(<span class="params">props, ref</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure><p>不过类组件就没有这个问题，毕竟有 this 指针</p><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>格式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure><p>将 ref 设置为 createHandle 的值，在依赖项变更的时候重新计算</p><p>其实就是起到一个设置 ref 的效果</p><p>但是修改 ref 有什么用呢？答案就是没什么用（</p><h1 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h1><p>这个就简单了，先给个例子吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useUpdate.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useUpdate = <span class="function">(<span class="params">fn, dep</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [flag, setFlag] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) fn();</span><br><span class="line">    <span class="keyword">else</span> setFlag(<span class="function"><span class="params">flag</span> =&gt;</span> <span class="literal">true</span>);</span><br><span class="line">  &#125;, [fn, dep, flag]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useUpdate;</span><br></pre></td></tr></table></figure><p>通过 react 原生的 <code>useState</code> 和 <code>useEffect</code>，来做到监听、回调与刷新</p><p>自定义 Hook 要求是必须命名为 <code>useXxx</code> 格式</p><p>除了本例的 <code>useUpdate</code>，也可以自定义一些别的对某些数据的操作，只要直接向外暴露读写接口即可</p><p>如果想要加强功能的话，甚至其余的 CURD 也可以一起写好暴露出去，2333</p><h1 id="过时的闭包"><a href="#过时的闭包" class="headerlink" title="过时的闭包"></a>过时的闭包</h1><p>英文说法为 stale closure</p><p>我们可以发现 react 的 <code>useState</code> 等功能，其实都是隐藏了真实目标，而向外暴露接口的形式，这就是一种闭包</p><p>但是大量使用闭包，也有显而易见的缺点，就是不利于内存的管理</p><p>所以 VUE 的作者尤雨溪认为这是一种”过时的闭包”</p><p>当然大家见仁见智吧，react 毕竟这么自由</p><p>但是！我去用 VUE 3.0 了，888888888888888</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在函数组件里天天 use 来 use 去，我也想自己整点&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 函数组件</title>
    <link href="http://yoursite.com/frontend/react-function-component/"/>
    <id>http://yoursite.com/frontend/react-function-component/</id>
    <published>2021-01-09T08:27:00.000Z</published>
    <updated>2021-01-14T15:19:33.412Z</updated>
    
    <content type="html"><![CDATA[<p>没什么特殊情况的话，一般还是用函数组件</p><a id="more"></a><hr><p>大部分内容其实是和类组件作出的对比</p><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setN(<span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;n&#125;</span><br><span class="line">      &lt;button onClick=&#123;add&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>好了，一个函数式组件的基本形完成了，比类组件简短很多吧</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>与类组件基本相同，react 会向组件提供 props 参数</p><p>只不过类组件是使用构造器来接收并初始化，函数组件是直接通过传入参数来取得</p><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>对于私有变量，类组件的方案是在构造器中声明</p><p>而在函数组件中，要使用 <code>useState</code> 来模拟 state 的效果</p><p><code>useState</code> 函数返回两个值，按顺序分别是目标变量的值和对于该变量的 setter</p><p>同时还接受一个传入参数，作为目标变量的初始值</p><p>可以通过解构赋值获得变量和 setter</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// n: 取决于传入值，此处是 number</span></span><br><span class="line"><span class="comment">// setN: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt; 此处的 number 同上</span></span><br></pre></td></tr></table></figure><h2 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h2><p>对于从 <code>useState</code> 中取得的 setter，一般可以直接写一个值，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setN(n + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>但是有复杂逻辑时，不免太过单薄，所以一般建议在 setter 中传入一个 function</p><p>setter 会向这个函数抛出一个参数，这个参数是操作数当前的值</p><p>这个函数应当返回一个值，作为操作数的新值</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>函数组件要求 return 一段 JSX 语段，起到类组件中 render 方法的效果</p><p>每当组件刷新时，都会再次执行函数组件中的语句</p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>好，现在发现一个很重要的问题——函数组件没有生命周期钩子函数！</p><p>但是 react 作者怎么可能没有想到这个呢？早就给你安排了模拟了</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>首先来了解一下 <code>useEffect</code> 函数，函数原型如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(fn[,target])</span><br></pre></td></tr></table></figure><p>第一个参数是监听的回调函数</p><p>第二个参数可不填，表示监听组件中的所有项目，或填入一个数组，数组中的每个元素都是监听的对象</p><p>一个用例如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render run'</span>)</span><br><span class="line">&#125;, [n])</span><br></pre></td></tr></table></figure><p>则每当 n 变化时，都会输出 render run</p><h2 id="模拟-constructor"><a href="#模拟-constructor" class="headerlink" title="模拟 constructor"></a>模拟 constructor</h2><p>构造器不需要模拟，在函数组件中，return 前的代码都可以认为是构造器</p><h2 id="模拟-componentDidMount"><a href="#模拟-componentDidMount" class="headerlink" title="模拟 componentDidMount"></a>模拟 componentDidMount</h2><p>根据上述定义，显然我们可以选择填入一个空数组，表示不需要监听任何变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>)</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p>好了，现在只有函数组件初始化的时候会执行这段输出</p><h2 id="模拟-componentWillUnmount"><a href="#模拟-componentWillUnmount" class="headerlink" title="模拟 componentWillUnmount"></a>模拟 componentWillUnmount</h2><p>上面说到 <code>useEffect</code> 的第一个参数应该是一个函数，我们可以通过返回值来控制组件消亡前的动作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件即将消亡'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上，return 一个函数即可，该函数将在组件即将消亡时被调用</p><h2 id="模拟-componentDidUpdate"><a href="#模拟-componentDidUpdate" class="headerlink" title="模拟 componentDidUpdate"></a>模拟 componentDidUpdate</h2><p>在如下这个例子中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render run'</span>)</span><br><span class="line">&#125;, [n])</span><br></pre></td></tr></table></figure><p>我们发现它会在 n 变动时打印输出，但在初始化的时候也打印了输出</p><p>如果要求不太高的话，其实已经可以就这样满足了</p><p>但我们怎么可以这么容易满足呢？我就是要让它在初始化的时候不打印，在更新的时候才打印！</p><p>那么容易想到使用一个控制变量来判断是不是第一次渲染</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'n changed'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'first render'</span>)</span><br><span class="line">        flag = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [n])</span><br></pre></td></tr></table></figure><p>但是一运行，发现一直都只能打印 first render，怎么回事？？</p><p>因为直接创建的变量并不会绑定到函数组件上，我们必须通过 <code>useState</code> 函数来创建才可以</p><p>那么可以得到如下改版</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [flag, setFlag] = useState(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'n changed'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'first render'</span>)</span><br><span class="line">        setFlag(<span class="function"><span class="params">flag</span> =&gt;</span> <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [n])</span><br></pre></td></tr></table></figure><p>现在可以正常实现我们的功能了，但是代码好丑</p><p>于是我们把这个代码段包装成一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useUpdate = <span class="function"><span class="params">dep</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [flag, setFlag] = useState(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'n changed'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'first render'</span>)</span><br><span class="line">            setFlag(<span class="function"><span class="params">flag</span> =&gt;</span> <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [dep])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剥离与组件中变量的依赖，改为只依赖传入的参数</p><p>然后在函数组件中通过 <code>useUpdate(n)</code> 进行调用</p><p>注意，此处的函数名必须满足 <code>\use.+\</code> 的格式，否则 react 会报错，认为这不是一个 react 组件或函数</p><p>但是还是不够灵活——我想传入我自己的处理函数，怎么办呢？</p><p>那么我们往这个函数中传入自己的 function</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useUpdate = <span class="function">(<span class="params">fn, dep</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [flag, setFlag] = useState(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            fn()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'first render'</span>)</span><br><span class="line">            setFlag(<span class="function"><span class="params">flag</span> =&gt;</span> <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [dep])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数组件中通过 <code>useUpdate(fn, n)</code> 进行调用即可</p><p>现在就还挺好看了，用法也和原生 useEffect 挺像</p><p>现在把这段逻辑抽离到单独的文件中，然后引入它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useUpdate.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useUpdate = <span class="function">(<span class="params">fn, dep</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [flag, setFlag] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) fn();</span><br><span class="line">    <span class="keyword">else</span> setFlag(<span class="function"><span class="params">flag</span> =&gt;</span> <span class="literal">true</span>);</span><br><span class="line">  &#125;, [fn, dep, flag]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useUpdate;</span><br></pre></td></tr></table></figure><p>之后就可以在任意文件中引入它了</p><p>注意，此处一般建议将 fn 和 flag 都放入监听数组中，否则 react 担心 fn 和 flag 一旦变化，会导致执行结果脱离预期，所以会引发警告（虽然警告一般都不重要）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是 react 函数组件的主要内容</p><p>结合类组件的内容，可以看出，react 在绝大多数地方都是推荐使用函数而不是直接赋值，并且大部分时候是通过组合各种功能来实现新功能，而不是依赖继承</p><p>如果用不习惯的话，vue 也不错，2333</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没什么特殊情况的话，一般还是用函数组件&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 类组件</title>
    <link href="http://yoursite.com/frontend/react-class-component/"/>
    <id>http://yoursite.com/frontend/react-class-component/</id>
    <published>2021-01-08T08:26:00.000Z</published>
    <updated>2021-01-09T10:55:38.386Z</updated>
    
    <content type="html"><![CDATA[<p>复杂的类组件</p><a id="more"></a><hr><p>那么还是用我们的 +1 功能作为 demo</p><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>大家都知道 js 有个 class 关键字，其实就是基于原型链的语法糖</p><p>那么类组件的声明就很明显了</p><p>我们先写一个展示 n 的功能，后面再来填充</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.n&#125;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; alert(<span class="keyword">this</span>.state.n)&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是一个 react 类组件的基本写法</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>借助上述 demo，我们先来了解一下 react 类组件的基本概念</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>类组件主要有两种参数</p><ol><li>props，来源于父级的传入</li><li>state，绑定在 this 上，而不是原型</li></ol><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>例如，在 <code>index.js</code> 中，对 App 传入参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">"myReactApp"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>然后在构造函数中获得 props，并通过父类构造函数初始化 props，之后就可以在 App 中访问 <code>this.props.name</code> 来取得这个参数值</p><p>一般不建议在子组件中修改 props，因为给出 props 的值的一定是父组件，所以 props 是属于父组件的，应当只能由父组件来修改，便于代码维护</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>state 是当前 App 的私有变量，不在原型上</p><p>一般在构造函数中，通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来赋予一个对象</p><p>要取值时，也是一样通过 <code>this.state.xxx</code> 来取值</p><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>类组件通过 render 函数来进行渲染，return 一段 JSX 就行</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>类比于 vue 的生命周期，react 也有自己的生命周期</p><p>首先是最重要的函数，所有类组件都必须实现的，render 函数！</p><p>render 函数负责将组件渲染到页面上</p><p>其余常用生命周期钩子函数的对照表如下</p><table><thead><tr><th>react</th><th>vue</th></tr></thead><tbody><tr><td>constructor</td><td>created</td></tr><tr><td>componentDidMount</td><td>mounted</td></tr><tr><td>componentDidUpdate</td><td>updated</td></tr><tr><td>componentWillUnmount</td><td>beforeDestroy</td></tr></tbody></table><p>不常用的也给出参考</p><table><thead><tr><th>react</th><th>vue</th></tr></thead><tbody><tr><td>shouldComponentUpdate</td><td>beforeUpdate</td></tr><tr><td>UNSAFE_componentWillMount</td><td>beforeMount</td></tr><tr><td>UNSAFE_componentWillUpdate</td><td>beforeUpdate</td></tr></tbody></table><p>可以令 <code>shouldComponentUpdate</code> 函数返回 false 来阻止 render 的执行</p><p>更多请看 <a href="https://zh-hans.reactjs.org/docs/react-component.html#the-component-lifecycle" target="_blank" rel="noopener">React.Component 生命周期</a></p><h1 id="魔改"><a href="#魔改" class="headerlink" title="魔改"></a>魔改</h1><p>现在修改 onClick，使其具有 +1 的功能</p><p>首先想到，写一个 add 方法，然后 +1 行不行</p><p>试试看</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  add() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state.n += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.n&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.add&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>运行一下，发现报错，说找不到 state</p><p>为什么呢？因为此处事件绑定的机制，实际上是这样的</p><p>假设我们令 onClick=fn，其中 fn 是一个函数</p><p>那么经过 webpack 转换后，实际上变成了 onclick = fn.call(window)，这时候 add 里的 this 指针就变成了指向全局的了！</p><p>那怎么办？容易想到一开始就绑定一个 this</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.add.bind(<span class="keyword">this</span>)&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>运行，发现页面没有变化</p><p>emmm，让我们加个输出看看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state.n += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，发现输出是正常的，+1 正常执行了</p><p>那么应该就是要我们手动 render 一下</p><p>但是用前文说过的那种，也太麻烦了，有没有什么好办法呢</p><p>答案是有，react 内置了另一种通知页面更新的办法，那就是 setState</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">n</span>: <span class="keyword">this</span>.state.n + <span class="number">1</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以修改 state 中的内容，并且自动通知页面进行更新</p><p>现在得到了一个简陋的 +1 demo</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  add() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state.n++</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="keyword">this</span>.state)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.n&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.add.bind(<span class="keyword">this</span>)&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>接下来一起优化它吧！</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>首先就是这个 onClick，用 bind 也太丑了，有没有好办法呢</p><p>刚才说到，实际绑定的 this 会变成全局的 this，所以我们才用 bind 指定了当前对象的 this</p><p>那么显然还有一种方法——不支持 this 的箭头函数！</p><p>但是现在的 add 写法，是挂载到原型上的，不能写成 <code>add: ()=&gt;{}</code> 这个样子的箭头函数</p><p>所以要挂载到对象上，那么容易想到在构造函数中挂载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.state.n++</span><br><span class="line">        <span class="keyword">this</span>.setState(<span class="keyword">this</span>.state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这样，在 button 中就可以不使用 bind 了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.add&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>但是这样的话，构造函数未免太长了</p><p>于是 ECMA 说好，我再给你个糖，用等号吧</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.state.n++</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="keyword">this</span>.state)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.n&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.add&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>该写法完全等价于将 add 在构造函数中声明，都是挂载到对象上的</p><p>现在就有了一个看起来很完美的 +1 demo！</p><h2 id="对象不变性"><a href="#对象不变性" class="headerlink" title="对象不变性"></a>对象不变性</h2><p>但是只是看起来完美，实际上还不够完美</p><p>假如我们要后退到某一个历史呢？在这个例子中可以直接 -1，但是要是逻辑复杂了，显然不能直接得到历史结果</p><p>那么我们应该尽量使得每次 state 的变化都被保存，便于用户在后退操作中引用</p><p>容易想到这样的写法来保存 state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state)</span><br><span class="line">    <span class="keyword">const</span> n = <span class="keyword">this</span>.state.n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; n &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>显然，我们用一个新的 state 取代了旧的 state，并且在发生变更前进行了存档</p><h2 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h2><p>现在我们想要看看保存下来的新值是什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state)</span><br><span class="line">    <span class="keyword">const</span> n = <span class="keyword">this</span>.state.n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; n &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>发现两次输出竟然是一样的，都是输出了旧的 state！</p><p>可是页面明显发生更新了啊，怎么回事</p><p>这是因为 setState 的更新是异步的，类似于 setTimeout</p><p>所幸，setState 可以接收第二个参数，作为其成功回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state)</span><br><span class="line">    <span class="keyword">const</span> n = <span class="keyword">this</span>.state.n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; n &#125;, () =&gt; <span class="built_in">console</span>.log(<span class="keyword">this</span>.state))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，打印就正常了</p><h1 id="追加更新"><a href="#追加更新" class="headerlink" title="追加更新"></a>追加更新</h1><p>+1 demo 不够用啊，复杂一点吧</p><h2 id="2"><a href="#2" class="headerlink" title="+2"></a>+2</h2><p>让我们做一个 +2 功能</p><p>容易想到直接 +2 就行，但是我偏要执行两次 +1！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">n</span>: <span class="keyword">this</span>.state.n + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">n</span>: <span class="keyword">this</span>.state.n + <span class="number">1</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一运行，发现不行，实际上只加了 1！</p><p>原因如上文中提到的异步，实际上两次取 <code>this.state.n</code> 都取到了相同的值，所以最后等效于 +1</p><p>不过 react 已经考虑到了这个问题——setState 可以接受一个函数作为参数！</p><p>setState 如果发现传入的是一个函数，那么会向该函数抛出两个参数，按顺序分别是 <code>this.state</code> 和 <code>this.props</code></p><p>那么容易得到如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">n</span>: state.n + <span class="number">1</span> &#125;))</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">n</span>: state.n + <span class="number">1</span> &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就可以正常 +2 了</p><p>注意，此处不可以写作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; (&#123; <span class="attr">n</span>: <span class="keyword">this</span>.state.n + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>因为 react 会缓冲更新，此时访问 <code>this.state</code> 并不能第一时间获取最新值</p><h2 id="多参数"><a href="#多参数" class="headerlink" title="多参数"></a>多参数</h2><p>state 只有一个参数也太惨了，我想多搞点，就多一个 m 吧</p><p>假设点击 button 会让 n+=1 且 m 不变</p><p>可以得到如下代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      n: <span class="number">0</span>,</span><br><span class="line">      m: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">n</span>: state.n + <span class="number">1</span> &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;n : &#123;<span class="keyword">this</span>.state.n&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;m : &#123;this.state.m&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.add&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了上述功能</p><p>但是感觉不对啊，setState 不应该是完全替换了 state 吗，可是新的 state 中并没有声明 m 啊，为什么 m 不会变成 undefined 呢</p><p>其实 react 在这里会自动比对新旧两个 state 的区别，然后只落实有提及部分，没提及的部分会保持原样</p><h2 id="嵌套对象"><a href="#嵌套对象" class="headerlink" title="嵌套对象"></a>嵌套对象</h2><p>那我想更新一个嵌套对象，怎么办呢</p><p>假设现在 state 中有一个 obj 和一个 n，obj 中有 name 和 age，点击 button 会增加 age 的值</p><p>容易得到如下代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      n: <span class="number">0</span>,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        name: <span class="string">'ringoer'</span>,</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">obj</span>: &#123; <span class="attr">age</span>: state.obj.age + <span class="number">1</span> &#125; &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;n : &#123;<span class="keyword">this</span>.state.n&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;obj.name : &#123;this.state.obj.name&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;obj.age : &#123;<span class="keyword">this</span>.state.obj.age&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.add&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>点击 button 后，发现 name 字段丢失了！</p><p>为什么呢？明明 n 字段没有丢失，不是说好 react 会自动对比，保留旧的吗</p><p>其实这里的自动保留，只是一个浅拷贝，只能作用于第一层，不能向下深入</p><p>这时候一般我们要使用 spread 语法手动展开对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">        obj: &#123;</span><br><span class="line">            ...state.obj,</span><br><span class="line">            age: state.obj.age + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在 age 变动的时候就不会导致 name 被置空了</p><h2 id="忽悠渲染器"><a href="#忽悠渲染器" class="headerlink" title="忽悠渲染器"></a>忽悠渲染器</h2><p>不行，渲染器这么智能，我就想让它不智能一把</p><p>我如果在 add 的时候，先 +1 再 -1 呢？渲染器这么聪明，应该知道不用渲染吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">n</span>: state.n + <span class="number">1</span> &#125;))</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">n</span>: state.n - <span class="number">1</span> &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是不行……渲染器虽然会合并渲染，只渲染一次，但还是发生了渲染</p><p>这时候一般有两种办法</p><p>可以通过生命周期中的 <code>shouldComponentUpdate</code> 函数，来判断前后 state 是否相等，若相等则不更新</p><p>但是太麻烦了，所以就有了懒人方案——改继承！</p><p>改成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span></span></span><br></pre></td></tr></table></figure><p>即可实现自动判断的效果</p><p>PureComponent 会在 render 之前对比新 state 和旧 state 的每一个 key，以及新 props 和旧 props 的每一个 key</p><p>如果所有 key 的值全都一样，就不会 render</p><p>如果有任何一个 key 的值不同，就会 render</p><p>但是只不过只一个浅对比，深层的话，还是要手写了2333</p><h1 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h1><p>于是我们得到了 +1 demo 的最终解决方案</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">n</span>: state.n + <span class="number">1</span> &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.n&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.add&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>鼓掌！！</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复杂的类组件&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 起步</title>
    <link href="http://yoursite.com/frontend/react-start/"/>
    <id>http://yoursite.com/frontend/react-start/</id>
    <published>2021-01-07T08:25:00.000Z</published>
    <updated>2021-01-12T03:36:54.654Z</updated>
    
    <content type="html"><![CDATA[<p>耦合度爆炸（划掉）函数式编程思想的具现化——React 框架</p><a id="more"></a><hr><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>有</p><ol><li>CDN 引入</li><li>本地安装</li><li>脚手架构建</li></ol><p>共三种方法</p><h2 id="CDN-引入"><a href="#CDN-引入" class="headerlink" title="CDN 引入"></a>CDN 引入</h2><p>在 html 模板中引入至少三个 <code>script</code> 标签，示例如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载 React。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意: 部署时，将 "development.js" 替换为 "production.min.js"。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@17/umd/react.development.js"</span> <span class="attr">crossorigin</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@17/umd/react-dom.development.js"</span> <span class="attr">crossorigin</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 加载我们的 React 组件。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"like_button.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h2><p>运行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g react react-dom</span><br></pre></td></tr></table></figure><p>即可安装必要的两个包</p><p>在使用时通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br></pre></td></tr></table></figure><p>即可引入</p><h2 id="脚手架构建"><a href="#脚手架构建" class="headerlink" title="脚手架构建"></a>脚手架构建</h2><p>推荐使用该方法，但记得换源，不然就等着小时为单位的 installing 吧</p><p>换源命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>可以通过以下命令检查是否换源成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>返回值是现在的源的路径</p><p>然后运行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure><p>然后移动到 react 项目目录下，运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app demo</span><br></pre></td></tr></table></figure><p>即可创建一个 demo 文件夹，内含全套 react 项目</p><p>或是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app .</span><br></pre></td></tr></table></figure><p>即可在当前目录下初始化一个 react 项目</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>安装完成后，通过命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>即可启动 react app，不出意外的话会自动打开 localhost:3000 并显示 react 默认页面</p><p>自带的热更新效果有限，想查看最新效果，最好还是手动刷新一下</p><p>打开 <code>src/index.js</code> 就可以看到主入口代码</p><p>暂时不需要考虑太多，只需要知道</p><ol><li><p><code>ReactDOM.render</code> 函数负责渲染页面</p></li><li><p><code>React.StrictMode</code> 标签是一个占位符，不会渲染到页面上，实际渲染的部分只有该占位符内部的部分</p></li><li><p><code>React.createElement</code> 函数可以创建一个 react 元素</p></li><li><p>原则上模板必须是一个整体，不能是两个或多个并列的元素，但是可以使用 <code>React.Fragment</code> 标签做到整体的效果</p><p>但是写 <code>React.Fragment</code> 也太多字母了，所以 react 提供了缩写 <code>&lt;&gt;</code>，与上述等效</p><p>其对应的闭合标签是 <code>&lt;/&gt;</code></p></li></ol><p><code>ReactDOM.render</code> 的格式如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(template, target)</span><br></pre></td></tr></table></figure><p>第一个参数填写要渲染的模板</p><p>第二个参数填写模板要挂载到页面上的哪个位置</p><p><code>React.createElement</code> 的格式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(type, props, text)</span><br></pre></td></tr></table></figure><p>第一个参数表示创建的类型，如 <code>&#39;div&#39;</code></p><p>第二个参数表示该标签持有的属性，如 <code>{className: &#39;container&#39;}</code></p><p>第三个参数表示该标签内部的文本</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>与 vue 的构造选项不同，react 采用独特的 JSX 语法来书写模板</p><p>在 <code>index.js</code> 中，我们可以看到，<code>ReactDOM.render</code> 函数实际渲染的部分是 <code>&lt;App /&gt;</code> 标签，该标签通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br></pre></td></tr></table></figure><p>来引入 App 模块</p><p>那么我们打开 <code>src/App.js</code>，可以看到该 js 通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>向外暴露了一个名为 App 的 function，该 function 返回一段形似 HTML 的语段，这个语段所采用的语法就是 JSX</p><p>JSX 语法要注意的地方有 3 个</p><ol><li><p>总体上沿用 HTML 语法</p></li><li><p>需要使用 js 来表示的地方（如变量或函数），使用花括号 <code>{}</code> 来表示</p><p>与 vue 不同，vue 是使用双花括号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p>来表示</p></li><li><p>可以添加任意自定义参数，但要注意有的参数有细微变化</p><ol><li>原参数名 class，现在变为 className</li><li>原参数名 onclick，现在变为 onClick，其余事件同理</li><li>一般有断句的部分，都要同 2 一样变成驼峰，用到的话请查一下文档</li></ol></li></ol><p>需要注意的是，js 中的 return 后如果留空，则实际等效于 <code>return undefined</code>，所以要用一对圆括号来占这一行的位置，然后折行写 JSX</p><h1 id="魔改"><a href="#魔改" class="headerlink" title="魔改"></a>魔改</h1><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现 +1"></a>实现 +1</h2><p>现在魔改一下 App 中的 JSX，来做一个简单的 +1 功能</p><p>显然，+1 需要一个变量来承载值，一个 button 来触发事件</p><p>容易得到以下 JSX</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;n&#125;</span><br><span class="line">      &lt;button onClick=&#123;n += <span class="number">1</span>&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>但是这时候发现，无论如何点击 button，n 都不会变化！</p><p>这是因为 react 和 vue 不同，不会自动监听数据变化并刷新视图</p><p>如果想要刷新视图，需要手动调用 render 函数</p><p>那么容易得到以下变体</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  n += <span class="number">1</span>;</span><br><span class="line">  render((</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;n&#125;</span><br><span class="line">      &lt;button onClick=&#123;add&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  ), <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;n&#125;</span><br><span class="line">      &lt;button onClick=&#123;add&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>现在点击页面上的 button，可以正常 +1 并重新渲染了，但是这也太丑了吧？！</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>那么我们可以使用一个变量来保存我们的模板</p><p>容易得到以下变体</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> template = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;n&#125;</span><br><span class="line">    &lt;button onClick=&#123;add&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  n += <span class="number">1</span>;</span><br><span class="line">  render(template, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>但是现在发现 +1 坏掉了！</p><p>为什么？因为 template 在声明的时候，就已经是一个静态的常量了，计算好了 n 的值，之后不会重新取得 n 的值</p><p>那延后 n 的取值行不行？容易想到用函数来装载模板，但是 JSX 支持吗？</p><p>答案是支持！render 函数的第一个参数可以是</p><ol><li><p>一段 JSX 语段</p></li><li><p>一个返回 JSX 语段的函数，此时会自动执行函数取返回值</p><p>但是此时 render 第一个参数必须写成标签形式</p></li></ol><p>那么箭头函数就可以满足我们的目标</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> template = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;n&#125;</span><br><span class="line">    &lt;button onClick=&#123;add&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  n += <span class="number">1</span>;</span><br><span class="line">  render(<span class="xml"><span class="tag">&lt;<span class="name">template</span> /&gt;</span>, document.getElementById('root'))</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function App() &#123;</span></span><br><span class="line"><span class="xml">  return template;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default App;</span></span><br></pre></td></tr></table></figure><p>这时发现——为什么控制台报错，页面不显示了！</p><p>答案是，我们向外暴露的是 App 函数，而 App 函数返回一个函数，在 index.js 中被调用时没有正常返回一段 JSX</p><p>于是我们把 JSX 移动到 App 中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;n&#125;</span><br><span class="line">    &lt;button onClick=&#123;add&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  n += <span class="number">1</span>;</span><br><span class="line">  render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'))</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default App;</span></span><br></pre></td></tr></table></figure><p>成功了！注意，此时 App 一般是用作标签写法，所以最好是大写开头</p><p>现在我们得到了 +1 的功能和一段好看的代码</p><p>于是又带来了另一个问题——看起来似乎 render 的时候更新的是整个 template，真的吗？</p><h2 id="部分重新渲染"><a href="#部分重新渲染" class="headerlink" title="部分重新渲染"></a>部分重新渲染</h2><p>显然 n 是变化的，但是 button 的逻辑似乎没有变化，这样不会过度渲染吗？</p><p>我们可以用开发者工具在页面上给 button 加一个 id，然后再点击一下试试，发现 button 还是带有 id！</p><p>那么我们就可以得到一个结论—— react 知道哪些要改，哪些不用改，在重新渲染的时候只会更新有变化的部分</p><p>可是 react 是怎么知道的呢？这就涉及虚拟 DOM 和 DOM diff 算法了</p><p>大致就是，react 将页面上的真实 DOM 解析到内存中，建立了一棵内存中的 DOM 树，然后每次重新渲染的时候都会先在内存中比较（其实 vue 也是这么做的）</p><p>此处不展开讲，有兴趣的话可以搜搜本站的文章，不过我可能还没写</p><h1 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>现在我想自动检测 n 是奇数还是偶数，怎么办呢</p><p>容易想到在 App 中加入条件判断</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;n&#125;</span><br><span class="line">    &#123;n % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">'偶数'</span> : <span class="string">'奇数'</span>&#125;</span><br><span class="line">    &lt;button onClick=&#123;add&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样就可以了</p><p>什么，你说想要 vue 那种，也可以吧</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> fragment;</span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    fragment = <span class="string">'偶数'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fragment = <span class="string">'奇数'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;n&#125;</span><br><span class="line">      &#123;fragment&#125;</span><br><span class="line">      &lt;button onClick=&#123;add&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  n += <span class="number">1</span>;</span><br><span class="line">  render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'))</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default App;</span></span><br></pre></td></tr></table></figure><p>此时 App 兼有了更复杂的功能，一般称为函数组件</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>想展示一个数组，又该怎么办呢</p><p>假设有以下数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'ringoer'</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'enatsu'</span>, <span class="attr">age</span>: <span class="number">21</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'pecco'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以得到以下 JSX</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'ringoer'</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'enatsu'</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'pecco'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;array.map(<span class="function">(<span class="params">person, index</span>) =&gt;</span> &lt;li&gt;&#123;<span class="string">`第<span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>位：name = <span class="subst">$&#123;person.name&#125;</span>, age = <span class="subst">$&#123;person.age&#125;</span>`</span>&#125;&lt;<span class="regexp">/li&gt;)&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>注意，此时我们要循环得到多个 li 标签，所以要先用 <code>{}</code> 来进行 js 循环</p><p>然后在 return 的 li 标签中，又是新的 JSX 语法作用域，可以继续使用 <code>{}</code> 来取值</p><p>显示结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· 第1位：name = ringoer, age = 22</span><br><span class="line">· 第2位：name = enatsu, age = 21</span><br><span class="line">· 第3位：name = pecco, age = 20</span><br></pre></td></tr></table></figure><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>上文中提到了函数组件，但并未详细说明</p><p>实际上，react 组件一般使用类组件和函数组件，其中又以函数组件为最方便且常用的写法</p><p>敬请期待吧</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;耦合度爆炸（划掉）函数式编程思想的具现化——React 框架&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Vue Vuex</title>
    <link href="http://yoursite.com/frontend/vue-vuex/"/>
    <id>http://yoursite.com/frontend/vue-vuex/</id>
    <published>2021-01-01T15:53:00.000Z</published>
    <updated>2021-01-03T15:19:17.217Z</updated>
    
    <content type="html"><![CDATA[<p>我想让用户感受快一点，localstorage 又太 low 了，那数据缓存怎么做呢</p><a id="more"></a><hr><p>依然还是祭出我们的 <a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">官方文档</a> 和 <a href="https://github.com/Ringoer/Myzone-Vue/blob/master/src/store/index.js" target="_blank" rel="noopener">myzone 项目代码</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>可以使用 npm 进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><p>在一个模块化的打包系统中，必须显式地通过 <code>Vue.use()</code> 来安装 Vuex</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><p>同 <code>vue-router</code>，在配置文件和 main.js 中均需要显式引入</p><h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><p>首先要介绍一下 vuex 的基本原理（如图）</p><p><img src="https://vuex.vuejs.org/vuex.png" alt=""></p><p>vuex 有三个重要部分</p><ol><li>actions，用来标识用户的动作，比较宏观，可能涉及多个数据</li><li>mutations，针对单个数据的变化规则</li><li>state，存放数据之地</li></ol><p>并有 3 个动作</p><ol><li>dispatch，分发外部事件到代码事件</li><li>commit，提交事务到 mutations</li><li>mutate，落实数据变更</li></ol><p>为什么不直接修改数据，而是要这样一层层控制呢？因为数据不是随便的人！！</p><p>咳咳，不是，是数据不能随便改</p><p>如果人人都能随便改数据的话，那要是数据出了事情，比如虚空置 0，那谁来负责？</p><p>所以要一层层处理，先分发任务，然后提交事务，再修改，中间配合日志系统，未来万一出错了才方便溯源</p><p>这也和 spring 什么的是一样的，为什么 controller 不能直接负责所有代码？因为业务复杂，数据要保证足够的安全性，所以先 dispatch 到 service 层，再 commit 到 dao 层，dao 层再去使用 mapper 层提供的接口来修改数据</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>那么给一个 vuex 配置的范例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    isLogin: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    setIsLogin (state, isLogin) &#123;</span><br><span class="line">      state.isLogin = isLogin</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    setIsLogin (context, isLogin) &#123;</span><br><span class="line">      context.commit(<span class="string">'setIsLogin'</span>, isLogin)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><p>然后在 main.js 中引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/index'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  store,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在外部代码中，就可以使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'setIsLogin'</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>在模板中不用写 this，不过相信大家都知道（</p><p>上文实现了在用户登录成功之后，分发参数到指定 actions 方法，actions 再提交到 mutations 等等的流程</p><p>上述 dispatch 和 commit，调用式都符合如下模样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[dispatch | commit]([methodName], ...args)</span><br></pre></td></tr></table></figure><p>显式指定要触发的方法名称，然后传入一个展开的参数列表</p><p>之后的接收方法，都符合以下模样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[methodName]([context | state], ...args)</span><br></pre></td></tr></table></figure><p>第一个参数是固定的</p><p>如果触发的是 dispatch，那么第一个就是对 mutations 的操作，要对上下文 context 进行 commit</p><p>如果触发的是 commit，那么第一个就是数据本身，直接取其字段进行修改即可</p><p>最后，再给上述流程补上日志记录，ok，状态管理完成了！</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>其它其实平时没什么用，也就一个热重载有用吧emmm</p><p>不过 myzone 没用到，请各位自行查看官方文档（</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我想让用户感受快一点，localstorage 又太 low 了，那数据缓存怎么做呢&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 路由</title>
    <link href="http://yoursite.com/frontend/vue-router/"/>
    <id>http://yoursite.com/frontend/vue-router/</id>
    <published>2021-01-01T15:52:00.000Z</published>
    <updated>2021-01-03T15:19:20.509Z</updated>
    
    <content type="html"><![CDATA[<p>总是需要分发路由的，不然难道让用户在同一个路径下反复横跳？</p><a id="more"></a><hr><p>本文将结合 <a href="https://router.vuejs.org/zh/installation.html" target="_blank" rel="noopener">官方文档</a> 和 <a href="https://github.com/Ringoer/Myzone-Vue/blob/master/src/router/index.js" target="_blank" rel="noopener">myzone 项目代码</a> 进行介绍</p><p>但是只是立即上手的方法，并不包含一些高级技法或者底层实现，所以还是以项目代码为主（</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>可以通过 npm 安装 vue-router</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure><p>如果在一个模块化工程中使用，需要显式引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure><p>不仅是 /router/index.js 这个配置文件要引用，main.js 也是要引用</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><p>首先要指明什么路由指向什么组件</p><p>myzone 中采用下例路由规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> login <span class="keyword">from</span> <span class="string">'@/components/others/login'</span></span><br><span class="line"><span class="keyword">import</span> verify <span class="keyword">from</span> <span class="string">'@/components/others/verify'</span></span><br><span class="line"><span class="keyword">import</span> index <span class="keyword">from</span> <span class="string">'@/components/others/index'</span></span><br><span class="line"><span class="keyword">import</span> userInfo <span class="keyword">from</span> <span class="string">'@/components/others/userInfo'</span></span><br><span class="line"><span class="keyword">import</span> message <span class="keyword">from</span> <span class="string">'@/components/message/message'</span></span><br><span class="line"><span class="keyword">import</span> messageView <span class="keyword">from</span> <span class="string">'@/components/message/messageView'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'*/verify'</span>,</span><br><span class="line">      name: <span class="string">'verify'</span>,</span><br><span class="line">      components: &#123;</span><br><span class="line">        verify: verify</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/login'</span>,</span><br><span class="line">      name: <span class="string">'login'</span>,</span><br><span class="line">      components: &#123;</span><br><span class="line">        login: login</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'index'</span>,</span><br><span class="line">      component: index</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/user/info'</span>,</span><br><span class="line">      name: <span class="string">'userInfo'</span>,</span><br><span class="line">      component: userInfo</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/message'</span>,</span><br><span class="line">      name: <span class="string">'message'</span>,</span><br><span class="line">      component: message</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/message/:messageId'</span>,</span><br><span class="line">      name: <span class="string">'messageView'</span>,</span><br><span class="line">      component: messageView</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于每个项，通过 <code>name</code> 属性指出该路由规则的名称，通过 <code>path</code> 属性指明当是何种路径时触发该路由，并通过 <code>component</code> 属性指示路由标的是哪个组件</p><p>在本例中使用了通配符 * 表示匹配以 verify 结尾的任意路径，以及通配符 : 表示匹配任意数字</p><p>还可以使用嵌套路由以降低耦合度，不过 myzone 比较简单，所以没有这么做</p><p>写好路由规则后，配置一下 main.js，就可以使用了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router/index'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由出口"><a href="#路由出口" class="headerlink" title="路由出口"></a>路由出口</h2><p>在 myzone 中，为 app.vue 这个页面主体，指定了如下 template</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"!this.$store.state.isLogin"</span> <span class="attr">name</span>=<span class="string">"login"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"!this.$store.state.isLogin"</span> <span class="attr">name</span>=<span class="string">"register"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"this.$route.path.endsWith('verify')"</span> <span class="attr">name</span>=<span class="string">"verify"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"this.$store.state.isLogin"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sideBar</span> <span class="attr">id</span>=<span class="string">"sideBar"</span> <span class="attr">v-show</span>=<span class="string">"this.$store.state.isSideBar"</span>&gt;</span><span class="tag">&lt;/<span class="name">sideBar</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mainBody"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sideHeader</span> <span class="attr">class</span>=<span class="string">"sideHeader"</span> <span class="attr">v-if</span>=<span class="string">"this.$store.state.isLogin"</span>&gt;</span><span class="tag">&lt;/<span class="name">sideHeader</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"mainContent"</span> <span class="attr">v-if</span>=<span class="string">"this.$store.state.isLogin &amp;&amp; this.isRouterAlive"</span> <span class="attr">name</span>=<span class="string">"default"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sideFooter</span> <span class="attr">class</span>=<span class="string">"sideFooter"</span> <span class="attr">v-if</span>=<span class="string">"this.$store.state.isLogin"</span>&gt;</span><span class="tag">&lt;/<span class="name">sideFooter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实质上，主要使用 <code>router-view</code> 标签指示路由出口</p><p>显然，<code>router-view</code> 标签需要一个 name 参数来指示传递给该出口的是哪个路由</p><p>本例中通过 <code>v-if</code> 来控制用户登录与否时看到的页面情况</p><p>配置好路由出口后，还要配置路由的入口</p><h2 id="路由入口"><a href="#路由入口" class="headerlink" title="路由入口"></a>路由入口</h2><p>在命名路由（具有 name 属性的路由）情况下，可以使用 <code>router-link</code> 标签实现路由跳转，其功能约等于 a 标签</p><p>如上例，要跳转到 <code>/message/123</code> 页面下的话，可以在模板中写入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name: 'messageView', params: &#123; messageId: 123 &#125;&#125;"</span>&gt;</span>message<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为该标签绑定 to 属性以实现路由目标的指定</p><p>也可以在模板代码中实现跳转</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$router.push(&#123; <span class="attr">name</span>: <span class="string">'messageView'</span>, <span class="attr">params</span>: &#123; <span class="attr">messageId</span>: <span class="number">123</span> &#125;&#125;)</span><br></pre></td></tr></table></figure><p>或者手动写入路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$router.push(<span class="string">'/message/123'</span>)</span><br></pre></td></tr></table></figure><p>在非模板位置，记得写 this</p><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>一般有三种模式，各有特点</p><ol><li>memory</li><li>hash</li><li>history</li></ol><p>memory 是基于 localstorage 的本地存储，换一台机器就无法同步正在浏览的页面</p><p>hash 是基于 # 符号进行的分片，所有内容都是在用户端进行的变化，不会传递给服务器，同时也不能进行前进和后退</p><p>history 可以没有 # 号，基于访问路径进行索引，是常见的模式，可以前进和后退，但是所有请求都会到达服务器（指 nginx 或 apache），请确保服务器已经正确配置</p><p>在 myzone 中采用了 history 模式</p><h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><p>只需要改变 import 时的动作，其余什么都不需要改变</p><p>例如，要加载 <code>/user/info</code> 时，可以写成如下形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/others/userInfo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/user/info'</span>,</span><br><span class="line">      name: <span class="string">'userInfo'</span>,</span><br><span class="line">      component: userInfo</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总是需要分发路由的，不然难道让用户在同一个路径下反复横跳？&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 模板指令</title>
    <link href="http://yoursite.com/frontend/vue-v-directives/"/>
    <id>http://yoursite.com/frontend/vue-v-directives/</id>
    <published>2020-12-23T15:50:00.000Z</published>
    <updated>2020-12-29T16:07:25.123Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 设计了很多自创的 v- 指令，来了解一下吧</p><a id="more"></a><hr><h1 id="模板输出"><a href="#模板输出" class="headerlink" title="模板输出"></a>模板输出</h1><p>首先要知道，最基本的输出到模板的方法</p><p>假设 script 中的 vue 实例的 data 包含以下字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双大括号语法"><a href="#双大括号语法" class="headerlink" title="双大括号语法"></a>双大括号语法</h2><p>通过在 template 模板中使用双大括号语法可以将 data 中的值插入到模板，如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>渲染后可以得到最终显示结果 0</p><p>当 n 变化时会自动重渲染到页面上（响应式）</p><h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><p>效果与双大括号语法一样，用法上略有区别</p><p>如上例，在此处应改为如下模样</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"n"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意此处 v-text 后的字符串表示一个 javascript 表达式，而不是单纯字符串</p><p>本语法与双大括号语法一样，都不会显示空值，即如果 n 是 undefined 或者 null，则渲染后不会有任何显示</p><h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><p>用于向模板中插入 html 字符串，例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"&lt;img src=xx.png /&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>路径正确的话会显示对应的图片</p><h2 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h2><p>被 v-pre 标记的元素会跳过编译，当有大量连续的没有指令的元素时，建议使用 v-pre 加快编译</p><p>示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时不会显示 n 的值，而是原封不动显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;n&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h1><p>有时候希望用户看得见或看不见某些部分，比如 SPA 中切换页面</p><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>可以使用 v-if 来控制元素是否编译</p><p>假设 data 中有 number 型数据 n</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"n===0"</span>&gt;</span>n is 0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 n 为 0 时编译该 div</p><p>可以使用 else 或 else if 来控制多条件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"n&gt;0"</span>&gt;</span>n is bigger than 0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"n===0"</span>&gt;</span>n is 0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>n is smaller than 0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>字面意思，不解释了</p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>仅控制当前元素满足条件时显示或不显示，无法实现上例中的复杂逻辑控制</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"n===0"</span>&gt;</span>n is 0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>乍一看似乎差不多，但还是有区别的</p><p>v-if 控制的是编译过程，所以一旦 v-if 判断不通过，那么该元素<strong>不会出现在 DOM 树上</strong></p><p>v-show 其实仅控制 CSS，所以 v-show 判断不通过时，元素仍然会出现在 DOM 树上，但是<strong>display: none</strong></p><p>显然 v-if 具有更高的切换开销（重构 DOM 树），v-show 具有更高的初始开销（一开始就要渲染），所以选择用哪个，还是要看具体的业务需求</p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>当使用 ul 之类列表的时候，经常要批量渲染一个数组之类</p><p>假设 data 中有如下数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        fruits: [<span class="string">'apple'</span>,<span class="string">'banana'</span>,<span class="string">'orange'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则可以使用 v-for 指令来循环渲染</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in fruits"</span>&gt;</span></span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者如下写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in fruits"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-for 提供两个参数，按顺序分别是数组中的 value 和 key</p><p>在模板中可以也使用 v-text 来取值</p><p>一般建议采用绑定 key 的写法，否则 vue 可能会报错</p><p>此处 key 必须是不重复的值，所以一般取索引作为 key</p><h1 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h1><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>一般需要从内存到页面绑定一组关系，此时可以使用 v-bind 指令</p><p>例如，要为一个 img 绑定一个图片路径，可以使用如下写法</p><p>设有如下 script</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        src: <span class="string">'xxx.png'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后模板写法如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"src"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>当 data 中的 src 变化时，页面上的图片也会变化</p><p>v-bind 指令可以缩写为仅一个冒号，示例如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"src"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>注意，此时如果通过开发者工具修改 src，并不会同步到内存中的 src，因为 v-bind 只是单向绑定</p><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>可以为 button 或者 a 标签绑定自定义事件</p><p>假设有如下 script</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    add(x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x) n+=x</span><br><span class="line">        <span class="keyword">else</span> n++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>且此时模板如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"add"</span>&gt;</span>点我+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>则一开始 n 会显示 0，之后每次点击 button 都会调用 add 函数，可以写，也可以不写括号</p><p>如果要传参数，除形参列表外，还可以传递一个事件信息参数，命名为 $event</p><p>例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"add(2,$event)"</span>&gt;</span>点我+2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-on 可以缩写为 @</p><p>例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>点我+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，当用在原生 DOM 事件上时，只能监听原生 DOM 事件</p><p>当用在自定义元素组件上时，也可以监听自定义事件</p><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>只有 v-bind 单向绑定怎么够用？所以就有了 v-model 双向绑定</p><p>一般用于表单中的 input 元素，以同步页面上的变动和内存中的变动</p><p>例如设有模板如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时 data 如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        username: <span class="string">''</span>.</span><br><span class="line">        password: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当页面上的 username 变动时，内存中的也会随之变动，显式表现为 p 标签中内容会随着 input 中内容变动而变动</p><p>反之，内存变动也会同步显示到页面上</p><p>其中原理约等于</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"username"</span> @<span class="attr">change</span>=<span class="string">"usernameChange"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>监听 change 事件，然后在 change 的时候修改 username</p><h1 id="其余指令"><a href="#其余指令" class="headerlink" title="其余指令"></a>其余指令</h1><h2 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h2><p>被该指令标记的元素只会编译一次，当任意绑定发生更新时，均不会更新该元素</p><p>例如，假设有 n=0，且模板如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>则第一次渲染时，会呈现 n 的值 0</p><p>之后不论 n 的值如何变化，此处都不会再次更新</p><h2 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h2><p>用于 vue 插槽的指令，也许以后会专门写一篇讲插槽</p><p>使用形如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>来声明一个名为 header 的具名插槽</p><p>并使用形如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>来声明一个出口为 header 的插槽内容</p><p>此时会渲染为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若声明的是匿名插槽，则名称为 default</p><p>此时插槽模板中所有未使用 v-slot 指令的内容都会被作为 default 插槽内容</p><p>例如模板结构如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时插槽内容声明如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以具体声明为 default 插槽内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不论何种，都会渲染为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h2><p>一个仅在编译期有效的标记，常与 CSS 属性选择器共同使用</p><p>例如同时有以下 CSS 和 模板</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[v-cloak]</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直到编译结束，该 div 都不会显示</p><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><p>一般只需要了解如下修饰符</p><table><thead><tr><th>修饰符示例</th><th>限用</th><th>功能</th></tr></thead><tbody><tr><td>@click .stop=”myEvent”</td><td>v-on</td><td>阻止事件冒泡</td></tr><tr><td>@click .prevent=”myEvent”</td><td>v-on</td><td>阻止事件默认动作</td></tr><tr><td>@keypress.enter=”myEvent”</td><td>v-on</td><td>当按下回车时执行</td></tr><tr><td>:money.sync=”myAttr”</td><td>v-bind</td><td>组件之间的响应式更新</td></tr><tr><td>v-model.lazy=”myAttr”</td><td>v-model</td><td>缓冲 input 的变化直到 input 失去焦点</td></tr><tr><td>v-model.number=”myAttr”</td><td>v-model</td><td>自动转换输入为合法的数字</td></tr><tr><td>v-model.trim=”myAttr”</td><td>v-model</td><td>自动去除输入的首尾空白</td></tr></tbody></table><p>注意，修饰符可以连续施与，例如同时要取消一个事件的冒泡和默认动作，可以这么写</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop.prevent</span>=<span class="string">"mySubmit"</span>&gt;</span>点我提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中仅 .sync 需要单独讲解</p><h2 id="sync"><a href="#sync" class="headerlink" title=".sync"></a>.sync</h2><p>在父子组件通信中，有时候需要在父子组件之间共享一个属性</p><p>但是 provide/inject 方法不能同步子组件的修改到父组件</p><p>v-model 又会造成父子组件对属性的修改没有区别，无法区分是谁做出的修改</p><p>此时就需要通过 .sync 修饰符来在父子组件之间共享属性</p><p>例如父组件中，现在有一子组件 text-document，希望在父子组件之间共享父组件的 title 属性</p><p>则模板如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind:title.sync</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时子组件可以通过以下语句来显式触发事件 <code>update:title</code> 以修改 title 的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:title'</span>, newTitle) <span class="comment">// newTitle 为子组件中传出的新值</span></span><br></pre></td></tr></table></figure><p><strong>该事件必须有 update 前缀</strong></p><p>而父组件修改不需要这么做，直接改就可以了</p><p>这样就可以区分开这个属性此时发生的修改究竟是父组件还是子组件所触发的</p><p>但 .sync 其实只是一个语法糖，其原理如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"title"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:update:title</span>=<span class="string">"title = $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在子组件传出变更的新值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:title'</span>, $event.target.value)</span><br></pre></td></tr></table></figure><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 设计了很多自创的 v- 指令，来了解一下吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 响应式原理</title>
    <link href="http://yoursite.com/frontend/vue-reactivity/"/>
    <id>http://yoursite.com/frontend/vue-reactivity/</id>
    <published>2020-12-23T15:47:00.000Z</published>
    <updated>2020-12-23T14:58:03.205Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 最重要的部分，就是响应式原理了</p><a id="more"></a><hr><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">点我查看官方讲解</a></p><h1 id="data"><a href="#data" class="headerlink" title="data"></a>data</h1><p>众所周知，给 vue 实例设置数据一般是这么写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            n: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在改写一下上述代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rawData = &#123;</span><br><span class="line">    n: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> rawData</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(rawData)</span><br></pre></td></tr></table></figure><p>有什么不同呢？在第一个例子中你不能观测到 vue 对 data 返回的对象做了些什么，因为这个对象是个匿名对象</p><p>现在你发现，打印出来的 rawData 变了！它不再是个单纯的 <code>{n:0}</code>，而是变成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;__ob__: _e&#125;</span><br><span class="line">    n: (...)</span><br><span class="line">    __ob__: _e &#123;value: &#123;…&#125;, dep: oe, vmCount: 1&#125;</span><br><span class="line">    get n: ƒ ()</span><br><span class="line">    set n: ƒ (e)</span><br><span class="line">    __proto__: Object</span><br></pre></td></tr></table></figure><p>类似上述模样，n 不再是一个单纯的 0 —— 尽管你访问 rawData.n 的时候，还是可以取到 0</p><p>这是怎么回事呢？？</p><p>原来 vue 在通过 data 取得实例数据之后，立即对实例数据进行了包装，将实例对象内的所有值都通过 <code>Object.defineProperty</code> 转化为了一组 <code>getter/setter</code>，然后拦截其 set 事件，获取更新消息，及时刷新视图</p><h1 id="新增字段"><a href="#新增字段" class="headerlink" title="新增字段"></a>新增字段</h1><p>上面提到，当在视图中使用了 data 中的数据，且该数据已经设置了监听时，数据更新会触发视图更新</p><p>但是这个自动设置监听的事件，是发生在生命周期的 beforeCreate 到 created 阶段执行的，简称为初始化阶段完成了数据监听的设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123;a&#125;&#125;&#123;&#123;b&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a: <span class="string">'x'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.b = <span class="string">'b'</span></span><br></pre></td></tr></table></figure><p>如上代码，视图上只会显示字符串 x，字段 b 因为是后加入的字段，所以没有设置监听</p><p>那不是初始化阶段添加的数据，要怎么渲染呢</p><p>一般有两种办法</p><ol><li>预先设置占位符</li><li>使用 vue 提供的设置方法</li></ol><p>对于占位符法，非常简单，只需要先定义好 b 就行了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123;a&#125;&#125;&#123;&#123;b&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a: <span class="string">'x'</span>,</span><br><span class="line">            b: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.b = <span class="string">'b'</span></span><br></pre></td></tr></table></figure><p>这样就会刷新视图</p><p>但是一般不知道未来会有多少字段，所以一般用 vue 提供的设置方法 <code>Vue.set</code></p><p>定义如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.set( target, propertyName/index, value )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用例</span></span><br><span class="line">Vue.set(vm, <span class="string">'b'</span>, <span class="string">'233'</span>)  <span class="comment">// 令 vm.b = '233'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以设置到子对象</span></span><br><span class="line">Vue.set(vm.obj, <span class="string">'n'</span>, <span class="number">0</span>)  <span class="comment">// 令 vm.obj.n = 0</span></span><br></pre></td></tr></table></figure><p>第一个参数是要设置的目标，第二个是字段名，第三个是字段值</p><p>上例中为 vm 这个实例设置字段 b，并将其值设置为字符串 233</p><p>通过这种方法添加的字段，自动带有监听器，更新时可以触发视图刷新</p><p>当 vue 实例是具名实例（如 vm）时，也可以使用 <code>vm.$set</code> 来设置字段，使用方法同 <code>Vue.set</code>，因为 <code>vm.$set</code> 就是 <code>Vue.set</code> 的一个别名</p><h1 id="数组变异方法"><a href="#数组变异方法" class="headerlink" title="数组变异方法"></a>数组变异方法</h1><p>需要注意的是，虽然数组定义约等于对象定义，但是 <code>Vue.set</code> 或 <code>vm.$set</code> 不可以为数组内元素添加监听器</p><p>为了监听数组的变化，vue 提供了 7 个基于 Array 的变异方法</p><ul><li>push</li><li>pop</li><li>shift</li><li>unshift</li><li>splice</li><li>sort</li><li>reverse</li></ul><p>之所以称之为”变异方法”，是因为 vue 实际上是对原方法进行了代理，除了正常调用原方法外，还会额外将数组变化通知给 vue 示例，从而在通过以上 7 个方法操作数组的时候，视图也会更新</p><h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h1><p>刚才虽然说，不通过 <code>Vue.set</code> 添加的属性，是没有监听器，不能渲染到页面上的</p><p>但是还是有特例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123;a&#125;&#125;&#123;&#123;b&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a: <span class="string">'x'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.a = <span class="string">'a'</span></span><br><span class="line">vm.b = <span class="string">'b'</span></span><br></pre></td></tr></table></figure><p>本来 b 应该说是后加入且没有监听器的，所以 b 理论上不会出现在视图上</p><p>但实际情况是，字符串 a 和 b 都出现在了视图上，也就是说两句赋值都成功了</p><p>这是怎么回事呢</p><p>结合之前学习的 javascript 事件循环，原来 vue 会缓冲在一次操作中涉及的视图变化，在当前宏任务中不会渲染视图，而是在下一个事件循环开始前才渲染视图</p><p>所以此处发生的情况如下</p><ol><li><p>改变了 vm.a，且 vm.a 有设置监听器，所以 vue 收到通知，将在下一个事件循环开始前渲染视图</p></li><li><p>当前事件循环还没结束，又对 vm.b 进行了赋值，所以现在 vm 上也有了数据字段 b</p><p>此时 b 上虽然没有监听器，但是监听器的作用就是触发视图渲染，而视图渲染已经被 a 触发了，所以 b 是躺赢2333</p><p>当然，此处是先改变 a，如果后改变 a，效果也是一样的，只要触发渲染，就会出现 b</p></li><li><p>当前事件循环结束，渲染视图，b 搭上了便车</p></li></ol><p>所以，有时候会因为某些后添加的变量搭上了便车，而造成一种这个变量也设置了监听的错觉，会引发一些潜在的 bug</p><p>出于面试需要，了解这个搭便车就可以了，实际写码的时候建议使用 <code>Vue.set</code></p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 最重要的部分，就是响应式原理了&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 构造选项</title>
    <link href="http://yoursite.com/frontend/vue-options/"/>
    <id>http://yoursite.com/frontend/vue-options/</id>
    <published>2020-12-22T15:46:00.000Z</published>
    <updated>2020-12-25T07:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<p>new Vue()传入的参数，都有哪些呢</p><a id="more"></a><hr><p>可以查看 <a href="https://cn.vuejs.org/v2/api/#data" target="_blank" rel="noopener">官方文档</a> 获取详细解释</p><p>常用的有以下组分</p><table><thead><tr><th>数据</th><th>DOM</th><th>生命周期钩子</th><th>资源</th><th>组合</th></tr></thead><tbody><tr><td>data</td><td>el</td><td>created / beforeCreate</td><td>components</td><td>mixins</td></tr><tr><td>props</td><td>template</td><td>mounted / …</td><td>directives</td><td>extends</td></tr><tr><td>computed</td><td></td><td>updated / …</td><td></td><td>provide / inject</td></tr><tr><td>methods</td><td></td><td>destroyed / …</td><td></td><td></td></tr><tr><td>watch</td><td></td><td>activated / deactivated</td><td></td></tr></tbody></table><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>写作一个对象或一个函数，指明所属的 vue 实例所具有的变量值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    n: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论是以上哪种，一旦设置，n 立刻就会被 getter/setter 所代理，且访问 vm.n 就可以访问到 data 中所设置的 n</p><p>其中，在 vue 组件的定义中，只接受函数形式</p><p>而且对象形式有如下 bug</p><p>假设有一个 vue 组件，其 data 写作对象形式 n: 0</p><p>在 app.vue 中，import 了上述组件，假设命名为 demo</p><p>当 app.vue 渲染了两个 demo 时，这两个组件使用的是同一个对 n 的引用</p><p>一旦其中一个 n 变化，另一个也会同步</p><p>综上，建议 data 恒使用函数形式</p><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>用于向子组件传入参数</p><p>设有子组件有如下 props</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'props-demo-simple'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'size'</span>, <span class="string">'myMessage'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>则父组件在通过 html template 渲染子组件时，可以为该子组件传入 size 或 myMessage 属性，子组件可以像使用 data 一样直接使用 size 或 myMessage</p><p>可以为子组件的参数设置配置，参考配置如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'props-demo-advanced'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 检测类型</span></span><br><span class="line">    height: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 检测类型 + 其他验证</span></span><br><span class="line">    age: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">0</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>计算属性，用于快速求出一个值</p><p>假设当前 vue 实例有以下组分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        n: <span class="number">0</span>,</span><br><span class="line">        m: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">    mulNandM()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.n*<span class="keyword">this</span>.m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 mulNandM 尽管看起来像个方法，但是其结果会被缓存，并在其依赖的变量上设置监听</p><p>当该计算属性再次被访问时会直接返回对应结果，除非其监听的变量发生了变化</p><p>在计算属性外部，可以直接像访问成员变量一样访问计算属性</p><p>！！！注意！！！</p><p>computed 等内容严重依赖 this 指针，所以尽量不要使用箭头函数，因为箭头函数没有自己的 this 指针</p><p>下同，只要依赖 this 指针的，都强烈建议不要使用箭头函数</p><h2 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h2><p>顾名思义，就是 vue 实例的成员方法</p><p>上例中的计算属性也可以写作 methods</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    mulNandM()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.n*<span class="keyword">this</span>.m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就必须加上括号，以方法形式调用，且不会缓存</p><p>一般用于执行复杂逻辑，简单的取值之类的建议使用计算属性</p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>监视属性，用于监视当前实例上的 data 的变化</p><p>例如，某 vue 实例有以下组分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        n: <span class="number">0</span>,</span><br><span class="line">        m: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line">    n(newval,oldval)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`n changed from <span class="subst">$&#123;oldval&#125;</span> to <span class="subst">$&#123;newval&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则当 n 变化的时候就会打印调试语句</p><p>若要在初始化时就执行 watch 选项，可以使用 immediate 参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        n: <span class="number">0</span>,</span><br><span class="line">        m: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line">    n: &#123;</span><br><span class="line">        handler: <span class="function"><span class="keyword">function</span>(<span class="params">newval,oldval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`n changed from <span class="subst">$&#123;oldval&#125;</span> to <span class="subst">$&#123;newval&#125;</span>`</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        immediate: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要监听对象字段，可以用字符串显式指定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        obj: &#123;</span><br><span class="line">            n: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        m: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line">    <span class="string">'obj.n'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newval,oldval</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`obj.n changed from <span class="subst">$&#123;oldval&#125;</span> to <span class="subst">$&#123;newval&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接监听对象的话，其中字段值的改变不会触发监听函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        obj: &#123;</span><br><span class="line">            n: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        m: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line">    obj: <span class="function"><span class="keyword">function</span>(<span class="params">newval,oldval</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`obj changed from <span class="subst">$&#123;oldval&#125;</span> to <span class="subst">$&#123;newval&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vm.obj.n = <span class="number">1</span>  <span class="comment">// 不会触发对 obj 的监听</span></span><br></pre></td></tr></table></figure><p>因为对基本类型的 === 判断，是基于值的，而对象的判断是基于地址的</p><p>此时 obj 指向的地址没有改变，所以 vue 认为 obj 没有更新</p><p>如果要在修改其中字段时，也触发对 obj 的监听，可以使用 deep 参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        obj: &#123;</span><br><span class="line">            n: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        m: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">        handler: <span class="function"><span class="keyword">function</span>(<span class="params">newval,oldval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`obj changed from <span class="subst">$&#123;oldval&#125;</span> to <span class="subst">$&#123;newval&#125;</span>`</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        deep: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vm.obj.n = <span class="number">1</span>  <span class="comment">// 会触发对 obj 的监听</span></span><br></pre></td></tr></table></figure><p>更多用法请看官方文档</p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="el"><a href="#el" class="headerlink" title="el"></a>el</h2><p>用于指示当前 vue 实例在页面上的挂载目标</p><p>通常 el 可以</p><ol><li>接受一个字符串作为其值，该字符串是一个 CSS 选择器</li><li>接受一个 HTMLElement 实例作为其值</li></ol><p>也可以不指定该参数，而是通过 export default 暴露给父组件，让父组件决定自己所在的位置</p><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>提供一个字符串模板作为 Vue 实例的标识使用</p><p>模板将会<strong>替换</strong>挂载的元素，挂载元素的内容都将被忽略，除非模板的内容有分发插槽。</p><p>例如如下配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">233</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>但是在 vue 组件中，一般不在 script 部分指定该参数，而是在 HTML template 部分直接写 HTML 模板</p><h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><p>官方文档提供了下图作为标准的生命周期图示</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="vue 生命周期"></p><p>通过图片可以看出，所谓”钩子”，和 aop 编程中的”切点”概念相仿，都是指某个范围的切入口</p><p>此处即是两个过程交接之处，类似于绿皮火车相邻两节车厢之间是用钩子连接的</p><p>通过图示，可以发现 vue 实例挂载到页面是在 created 阶段后，beforeMount 阶段前完成的</p><p>此时判断 vue 实例有没有指示 el 选项</p><ul><li>若有 el 选项，则直接挂载并继续编译</li><li>若无，则暂停当前实例的编译，直到显式挂载到页面上后才会继续编译</li></ul><p>继续判断有没有 template 选项，此处将 template 选项和 HTML template 模板分别称为内部和外部 template</p><p>若有内部，则内部的优先级高，否则使用外部模板</p><p>若都没有，则报错</p><p>除此之外，update 的两个钩子也要注意，当且仅当发生了重新渲染的时候，也就是页面上内容要改变的时候，才会触发 update 相关的两个钩子</p><p>若仅修改数据而对页面没有影响，不会触发这两个钩子</p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><h2 id="components"><a href="#components" class="headerlink" title="components"></a>components</h2><p>可以通过 components 选项引入子组件</p><p>示例如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sideBar <span class="keyword">from</span> <span class="string">'./components/common/sidebar'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    sideBar</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此时可以在 template 中使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sideBar</span>&gt;</span><span class="tag">&lt;/<span class="name">sideBar</span>&gt;</span></span><br></pre></td></tr></table></figure><p>来引入子组件的 template 进行渲染</p><h2 id="directives"><a href="#directives" class="headerlink" title="directives"></a>directives</h2><p>用于自定义当前实例可用的模板指令</p><p>例子如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 focus 指令，当插入到页面中执行对应的函数，之后可以在模板中使用 v-focus</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般有 5 种钩子可选</p><ul><li>bind，绑定到元素时调用</li><li>inserted，插入到元素时调用</li><li>update，所在组件的虚拟结点更新时调用，但可能在更新前被调用</li><li>componentUpdated，所在组件及其子组件全部更新后调用</li><li>unbind，解除绑定时调用</li></ul><p>上述 5 种钩子，会被按顺序传入以下参数</p><ol><li><p>el，绑定的元素</p></li><li><p>binding，该事件的具体数据</p><p>假设现在有 <code>v-on:click=&quot;hello&quot;</code>，其中 hello 是一个方法</p><ol><li><p>name，指令名，不包括 <code>v-</code> 前缀</p><p>本例中 <code>binding.name === on</code></p></li><li><p>value，指令的绑定值</p><p>本例中 <code>binding.value === hello</code></p><p>若绑定的内容是可以立即求值的，则绑定其值</p><p>如 <code>v-on:click=&quot;1+1&quot;</code>，value 就取值 2，而不是表达式 1+1</p></li><li><p>oldValue，指令绑定的前一个值，仅在发生更新时，即 update 或 componentUpdated 钩子中传入</p></li><li><p>expression，字符串形式的指令表达式</p><p>沿用 2 中的例子，分别取 <code>hello</code> 和 <code>1+1</code></p></li><li><p>arg，传给指令的参数</p><p>本例中 <code>binding.arg === &#39;click&#39;</code></p></li><li><p>modifiers，一个包含修饰符的对象</p><p>例如在 <code>v-my-directive.foo.bar</code> 中，有</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">binding.modifiers === &#123;</span><br><span class="line">    foo: <span class="literal">true</span>,</span><br><span class="line">    bar: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>vnode，所在的虚拟结点</p></li><li><p>oldVnode，上一个虚拟结点</p><p>仅在发生更新时，即 update 或 componentUpdated 钩子中传入</p></li></ol><p>主要用于减少 DOM 操作</p><p>每个指令都可以绑定专有的钩子函数，详见 <a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">文档</a></p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><h2 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h2><p>将待混入的对象混入到 vue 实例中，相同的属性会智能合并，即</p><ul><li>对于 data，覆盖相同的，保留不同的</li><li>对于 methods 和生命周期钩子函数等，全部保留</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>) &#125;,</span><br><span class="line">  mixins: [mixin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上例，最终两个 created 阶段的 function 都会在 vm 实例的 created 阶段执行，输出 1和2</p><p>记得加方括号</p><h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>与 mixins 类似，使得当前实例继承另一个实例的所有值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompA = &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在没有调用 `Vue.extend` 时候继承 CompA</span></span><br><span class="line"><span class="keyword">const</span> CompB = &#123;</span><br><span class="line">  extends: CompA,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例，CompA 的所有内容会在 CompB 内被展开</p><h2 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a>provide / inject</h2><p>由父组件提供（provide）一个对象或方法，并注入（inject）到子组件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    provide () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            reload: <span class="keyword">this</span>.reload</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            isRouterAlive: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        reload () &#123;</span><br><span class="line">            <span class="keyword">this</span>.isRouterAlive = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.isRouterAlive = <span class="literal">true</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，父组件提供了一个 reload 方法实现局部刷新</p><p>然后在子组件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    inject: [<span class="string">'reload'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就成功向子组件注入了 reload 方法，在子组件中也可以通过 this.reload() 来实现局部刷新了</p><p>注意，此处传递依然遵循 JS 传递规则，即 3 个基本类型传值，其余传引用</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;new Vue()传入的参数，都有哪些呢&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 起步</title>
    <link href="http://yoursite.com/frontend/vue-start/"/>
    <id>http://yoursite.com/frontend/vue-start/</id>
    <published>2020-12-22T03:47:00.000Z</published>
    <updated>2020-12-22T14:04:24.096Z</updated>
    
    <content type="html"><![CDATA[<p>前端三大框架中相对最简单的 Vue 框架，该怎么上手呢</p><a id="more"></a><hr><p>Vue 这么大名头，就不赘述什么了2333</p><p>直接上 <a href="https://cn.vuejs.org/index.html" target="_blank" rel="noopener">官方文档</a></p><p>因为作者是中国人，所以中文文档很有参考价值，就直接贴中文文档了（</p><h1 id="快速创建-vue-项目"><a href="#快速创建-vue-项目" class="headerlink" title="快速创建 vue 项目"></a>快速创建 vue 项目</h1><p>点击官方文档首页上的 起步，可以来到介绍</p><p>通常有以下方法来创建一个 vue 项目</p><h2 id="script-标签-cdn"><a href="#script-标签-cdn" class="headerlink" title="script 标签+cdn"></a>script 标签+cdn</h2><p>通过</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以在 html 页面上引入 vue 内容，推荐小型项目使用</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>通过命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue</span><br></pre></td></tr></table></figure><p>可以安装 vue 最新稳定版，推荐大型项目使用</p><h2 id="vue-脚手架"><a href="#vue-脚手架" class="headerlink" title="vue 脚手架"></a>vue 脚手架</h2><p>可以使用官方提供的 <code>@vue/cli</code> 快速构建 vue 项目</p><p>官方介绍如下</p><blockquote><p>它为现代前端工作流提供了 batteries-included 的构建设置。只需要几分钟的时间就可以运行起来并带有热重载、保存时 lint 校验，以及生产环境可用的构建版本。</p></blockquote><p>可以查阅 cli 对应的 <a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">官网</a></p><p>具体使用方法如下</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli-service-global</span><br></pre></td></tr></table></figure><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-world</span><br></pre></td></tr></table></figure><p>此时 vue 会询问你，是否采用默认的配置，建议新手选”是”</p><p>选否的话，vue 会询问你具体的各个配置的选项，此时使用方向键的上下来选择选项，并通过空格选定</p><p>注意，此时按回车的话会直接决定这个询问的结果，进入下个询问</p><p>当然你后悔的话，ctrl+c 就可以了，2333</p><p>在询问完所有配置后，vue 会询问你是否保存上述配置为默认配置，这里一般也建议选否</p><p>命令行不习惯的话，也可以用图形化界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure><p>通过上述命令可以打开一个浏览器窗口以显示图形化界面来操作 vue</p><h2 id="codesandbox-io"><a href="#codesandbox-io" class="headerlink" title="codesandbox.io"></a>codesandbox.io</h2><p>什么？我一句命令行也不想打？可以！</p><p>可以访问 <a href="https://codesandbox.io/" target="_blank" rel="noopener">codesandbox.io</a> 来创建 vue 项目</p><p>注意，此时不要登录，登录会有创建数量限制，不登录则无限</p><p>打开页面后直接访问右上角的 create sandbox，在新弹出的菜单中选择 vue 即可创建一个 vue 项目</p><p>codesandbox 提供了在线的热更新，但因为是在线的，所以会略有延迟</p><p>为了解决这个延迟，codesandbox 也提供了下载到本地的方法：</p><ol><li>找到代码编辑界面左上角的 file 选项</li><li>选择 export to zip</li></ol><p>ok！你下载了一个 zip，解压就可以得到你的 vue 项目了，方便快捷</p><p>其效果类似于用 idea 创建 spring boot 项目的时候的 spring assistant，什么都不用做就有一个 helloworld 了2333</p><p>（不过命令行还是要学，不亏</p><h1 id="vue-不同版本"><a href="#vue-不同版本" class="headerlink" title="vue 不同版本"></a>vue 不同版本</h1><h2 id="有哪些版本"><a href="#有哪些版本" class="headerlink" title="有哪些版本"></a>有哪些版本</h2><p>在刚才的介绍中，完全没提及使用 vue 的哪个版本，其实各自有各自默认的版本</p><p>vue 有 2x2=4 种主要版本——完整版/非完整版+开发版/生产版</p><p>非完整版一般也称作仅运行版本（runtime only）</p><p>对应的文件名如下</p><table><thead><tr><th></th><th>完整版</th><th>非完整版</th></tr></thead><tbody><tr><td>开发版</td><td>vue.js</td><td>vue.runtime.js</td></tr><tr><td>生产版</td><td>vue.min.js</td><td>vue.runtime.min.js</td></tr></tbody></table><p>具体特点如下</p><ol><li>完整版，有完整完全的功能</li><li>非完整版，没有编译模板的功能，只支持渲染函数，体积比完整版小 30%</li><li>开发版，包含警告等内容</li><li>生产版，不含有警告，且体积比开发版更小，旨在让用户下载最少的 js</li></ol><h2 id="完整版和非完整版的区别"><a href="#完整版和非完整版的区别" class="headerlink" title="完整版和非完整版的区别"></a>完整版和非完整版的区别</h2><p>假设有如下 html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在意图在 app 中显示一个数字，并提供一个 button 使得点击后可以改变这个数字</p><p>如果你使用完整版，只需要这样写即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123;n&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="comment">// 此处通过 cdn 引入完整版 vue </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 js 中写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        n: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        add()&#123;</span><br><span class="line">            <span class="keyword">this</span>.n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者 html 的 app 中不写内容，而是写在 new Vue 内</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        n: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;n&#125;&#125;</span></span><br><span class="line"><span class="string">        &lt;button @click="add"&gt;+1&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        add()&#123;</span><br><span class="line">            <span class="keyword">this</span>.n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意，此处的 template 需要包裹在同一个 div 中</p><p>就可以实现点击按钮后自增，并同步到页面上</p><p>但是如果用非完整版，就不能这样写</p><p>首先 html 要改成这样</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="comment">// 此处通过 cdn 引入非完整版 vue </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 js 中写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        n: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    render(h)&#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">'div'</span>, [<span class="keyword">this</span>.n, h(<span class="string">'button'</span>, &#123;</span><br><span class="line">            on: &#123;<span class="attr">click</span>: <span class="keyword">this</span>.add&#125;</span><br><span class="line">        &#125;, <span class="string">'+1'</span>)])</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        add()&#123;</span><br><span class="line">            <span class="keyword">this</span>.n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>vue 提供的 render 方法接受一个参数，是 vue 封装好向开发者传来的渲染函数，一般命名为 h（因为文档里就是 h）</p><p>在上例中，h 函数接收 2 个或 3 个参数</p><p>如果只有两个参数，第一个表示其所属的 html 元素类型，第二个参数表示其显示文本</p><p>如果有三个参数，第一个参数同上，第二个参数表示其属性配置，第三个表示其显示文本</p><h2 id="非完整版的意义"><a href="#非完整版的意义" class="headerlink" title="非完整版的意义"></a>非完整版的意义</h2><p>既然非完整版这么麻烦，有什么价值呢？</p><p>答案就是大小和独立</p><p>在完整版中，vue 的参数直接侵入了模板 html，一旦发生修改，则全部都要改，在实际开发中很难同步；而采用 template 参数的话，又导致在 js 中混入了奇怪的不属于 js 的部件</p><p>在非完整版中，所有的局部配置都依赖于同一个 js，当发生修改的时候，只需要修改当前 js</p><p>最重要的是，非完整版支持 vue 组件化！便于控制不同部分的代码</p><p>综上，实际项目中，应该优先使用非完整版（为了更小体积），并且开发中使用开发版，发布的时候使用生产版</p><h1 id="vue-组件"><a href="#vue-组件" class="headerlink" title="vue 组件"></a>vue 组件</h1><p>创建 vue 项目后，就可以发现核心文件 main.js 和 app.vue</p><p>其中 app.vue 就是项目的主组件，并可以以类似逻辑创建 .vue 后缀的文件作为项目的新的 vue 组件</p><p>每个 vue 组件都包含以下 3 部分</p><ol><li><p>template，指示该组件的 html 模板，在需要填充时将该部分填充到 app.vue 的对应位置</p></li><li><p>script，指示该组件使用的 vue 实例的配置</p></li><li><p>style scoped，指示该组件使用的样式</p><p>注意，此处一般要注明 scoped 以使得样式只应用于当前组件，否则会应用到全局</p></li></ol><p>在用户访问时，router 组件会选择 component 并返回</p><p>当在 app.vue router-view 中选择 name=”default” 时，router 里不需要写对象，直接写目标组件即可</p><p>当选择 name=”xxx” 时，router 返回的 component 必须是对象，且包含你指定的 name 字段，该字段值是目标组件对象</p><h1 id="vue-与-SEO"><a href="#vue-与-SEO" class="headerlink" title="vue 与 SEO"></a>vue 与 SEO</h1><p>众所周知 vue 是单页应用，从上面的说明也看出了 vue 的特点：主页只有一个 div#app，没有别的东西，这样搜索引擎怎么知道你这个页面和什么有关系呢</p><p>可以在模板里写 meta 标签来指示本网站相关内容，或是在 div#app 中写入内容（反正会被 vue 渲染替换）</p><p>但是仍然治标不治本，SEO 效果仍然很差，这时候就需要——服务端渲染（SSR）</p><p>不过 SSR 已经远超本章内容了，就不描述了</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端三大框架中相对最简单的 Vue 框架，该怎么上手呢&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>20201222 本站写作方法</title>
    <link href="http://yoursite.com/diary/20201222/"/>
    <id>http://yoursite.com/diary/20201222/</id>
    <published>2020-12-22T03:30:00.000Z</published>
    <updated>2020-12-22T03:48:09.393Z</updated>
    
    <content type="html"><![CDATA[<p>昨天被 yuli 问了这回事，写一下吧</p><a id="more"></a><hr><h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><p>首先是打开 <code>hexo s</code> 然后新建一篇文章</p><p>新建之前，需要想好两点</p><ol><li>文章标题</li><li>文章分类</li></ol><p>因为 hexo 不会上传 markdown 源文件，所以在本地需要有个办法管理这些源文件，我在此处加个前缀</p><p>比如说，当文章是 others 或 diary 分类的时候（比如本文），就直接用日期作为前缀</p><p>再比如一篇 frontend 分类的文章，就用”前端”当前缀，如”前端-webpack 入门 1”</p><p>创建之后，因为 admin 会自动进入编辑页面，所以我也就顺手在编辑页面做一些设定</p><h1 id="文章初始化"><a href="#文章初始化" class="headerlink" title="文章初始化"></a>文章初始化</h1><p>主要在 admin 提供的编辑页面做如下工作：</p><ol><li><p>在文章 title 处去除前缀，只保留文件名上的前缀</p></li><li><p>在右侧设置一下文章的目录和标签</p></li><li><p>写一下文章的缩略语和 more 注释，例如本文就写以下部分</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">昨天被 yuli 问了这回事，写一下吧</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure></li></ol><p>这样，在 admin 上的部分就完成了，现在关掉本地服务器，改用 typora 写文章</p><h1 id="准备写文章"><a href="#准备写文章" class="headerlink" title="准备写文章"></a>准备写文章</h1><p>用 typora 打开文章后，需要做以下工作</p><ol><li>打开源代码模式，为本文附加一个 id（为了部署后文章路径好看）</li><li>回到渲染模式，全程使用渲染模式写文章</li><li>在 more 注释后加上分割线，在结尾处也加上分割线</li><li>拟定文章目录，先写好目录再填充内容</li></ol><h1 id="文章内联资源"><a href="#文章内联资源" class="headerlink" title="文章内联资源"></a>文章内联资源</h1><p>一篇文章内一般会有各种其它资源，比如图片，比如下载</p><p>我采取的策略如下</p><ol><li>能不能使用代码段表示？能就仅使用代码段</li><li>不能做到 1，那能不能使用图片表示？能就仅使用图片</li><li>最后才选择提供下载</li></ol><p>在使用图片的时候，我一般采取以下方案</p><ol><li><p>在专门的图片文件夹 “hexo 图片” 下新建一个图片文件夹，该文件夹名字与当前文章的 id 一致</p></li><li><p>当前文章所涉及的新图片都保存到该文件夹下，每个图片都命名为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`<span class="subst">$&#123;id&#125;</span>-<span class="subst">$&#123;index&#125;</span>.(png|jpg)`</span></span><br></pre></td></tr></table></figure><p>然后通过 markdown 图片引入的方式先插进文章中以便浏览</p></li><li><p>当文章完成后，将所需图片都上传到 cdn，再 ctrl+r 替换文章中对图片的引用路径</p></li><li><p>检查文章，提交</p></li></ol><p>若是提供下载，则是先预留超链接位置，写完文章后执行与图片第 3、第 4 步相同的步骤</p><p>以上</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天被 yuli 问了这回事，写一下吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="diary" scheme="http://yoursite.com/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>Webpack 入门 4</title>
    <link href="http://yoursite.com/frontend/webpack-4/"/>
    <id>http://yoursite.com/frontend/webpack-4/</id>
    <published>2020-12-18T14:55:00.000Z</published>
    <updated>2020-12-20T15:50:21.001Z</updated>
    
    <content type="html"><![CDATA[<p>天天 file 协议，我受够了，来个 server！Webpack 其之四</p><a id="more"></a><hr><p><a href="https://download.ringoer.com/webpack-demo-4.rar" target="_blank" rel="noopener">点我下载本章代码</a></p><h1 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h1><p>查看 <a href="https://www.webpackjs.com/guides/development/#%E4%BD%BF%E7%94%A8-webpack-dev-server" target="_blank" rel="noopener">webpack 官方文档</a>，发现有一个东西叫做 webpack-dev-server，而且也就它带一个 server 单词，试试看！</p><p>先安装它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure><p>然后照抄一下官方给的配置，发现是在 module.exports 下新增以下字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">'./dist'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及在 node 配置中新增以下字段</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"start": "webpack-dev-server --open"</span><br></pre></td></tr></table></figure><p>意思是当运行 <code>npm run start</code> 的时候，执行其值对应的命令行，其中 <code>--open</code> 的意思是自动打开默认浏览器</p><p>抄进我们的配置，start 一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>发现报错了……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Cannot find module &apos;webpack-cli/bin/config-yargs&apos;</span><br></pre></td></tr></table></figure><p>搜索发现，是默认安装的 webpack-cli 版本太高了，以至于和 webpack-dev-server 不兼容</p><p>这时候需要重装 webpack-cli 为合适的版本</p><p>依次运行下述命令可以重装 webpack-cli 为 3 版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall webpack-cli</span><br><span class="line">npm install webpack-cli@3 --save-dev</span><br></pre></td></tr></table></figure><p>现在再试试 start，发现成功打开了浏览器！</p><p>此时坐标 localhost:8080，默认根路径 / 就是我们指定的输出 index.html 的位置</p><p><img src="https://pic.ringoer.com/webpack-4-0.png" alt=""></p><p>尝试修改一下 style，比如背景色改成 blue</p><p>发现随着你在本地保存，浏览器里的页面也会自动更新</p><p>不只是 http 协议，webpack-dev-server 也支持热更新！</p><h1 id="不同的配置"><a href="#不同的配置" class="headerlink" title="不同的配置"></a>不同的配置</h1><p>但是这个 server 再怎么 server，终究还是个 dev，它在编译的时候就应该使用 development mode 而不是 production</p><p>让我们复制一下原来的 config，保存成两份</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js 默认使用 development 模式</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'My App'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].[contenthash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">        <span class="comment">// use: [</span></span><br><span class="line">        <span class="comment">//   'style-loader',</span></span><br><span class="line">        <span class="comment">//   'css-loader'</span></span><br><span class="line">        <span class="comment">// ]</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'file-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.prod.js 使用 production 模式</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'My App'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].[contenthash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'file-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候，我们直接 <code>npm run build</code> 的话，会使用默认的 development 模式的配置，怎么办呢</p><p>答案是修改 node 脚本配置，其中 build 字段改为如下值</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"build": "rimraf ./dist &amp;&amp; webpack --config ./webpack.config.prod.js"</span><br></pre></td></tr></table></figure><p>通过 –config 来指示此时使用哪个配置文件进行构建</p><p>现在再次 <code>npm run build</code>，也不会用错配置文件了！</p><h1 id="管理配置"><a href="#管理配置" class="headerlink" title="管理配置"></a>管理配置</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>配置分开后，我们又发现了新的问题：配置内容重复不少</p><p>重复可是编程一大弊病，必须要避免，容易想到抽出一个公共的配置</p><p>现在让我们把目录变成这样</p><ul><li>webpack.config.js，保存公共配置</li><li>webpack.config.dev.js，保存开发配置</li><li>webpack.config.prod.js，保存部署配置</li></ul><p>然后修改 node 脚本的 start 字段</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"start": "webpack-dev-server --config ./webpack.config.dev.js --open"</span><br></pre></td></tr></table></figure><p>接下来提取刚才两个配置文件中的公共部分</p><h2 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h2><p>显然除了模式、dev-server 有关配置外，其余部分基本一致</p><p>那么把共有部分提取一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js 共有部分配置</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'My App'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].[contenthash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">        <span class="comment">// use: [</span></span><br><span class="line">        <span class="comment">//   'style-loader',</span></span><br><span class="line">        <span class="comment">//   'css-loader'</span></span><br><span class="line">        <span class="comment">// ]</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'file-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.dev.js 使用 development 模式</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.prod.js 使用 production 模式</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在怎么引入呢</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>既然结尾是 js，那这个配置就是按照 js 的引入办法，通过 require 引入</p><p>插播一下，在 webpack 配置这边，遵循的是 AMD 规范，使用 require</p><p>而平时的 node 代码是遵循 CommonJS 规范，使用 import</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.dev.js 使用 development 模式</span></span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...base,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.prod.js 使用 production 模式</span></span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...base,</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处使用 spread 语法展开引入的 base，base 就是 require 的模块里的 <code>module.exports</code> 的值</p><p>现在就可以使得两个不同 mode 的配置，都继承同样的公共配置了</p><p>但是注意，现在不能随便覆写字段，比如我要在 dev mode 新增一个 loader 处理 scss</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...base,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          loader: <span class="string">"sass-loader"</span> <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果这样写，会导致覆写了从 base 引入的 loader，让 css loader 和 file loader 都消失，只有 sass loader</p><p>所以要引入新的专有 loader 的话，还要再应用一次 spread 语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    ...base.module,</span><br><span class="line">    rules: [</span><br><span class="line">        ...base.module.rules,</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"sass-loader"</span> <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有这样才可以保证不会覆写掉共有部分引入的 loader</p><p>其余部分的覆写也要注意这一点</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>手动引入还要注意使用 spread 语法以及避免错误覆写，有没有更方便的呢？有</p><p>搜索 webpack merge，找到其 github 项目主页</p><p>发现要安装，那就安装一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-merge --save-dev</span><br></pre></td></tr></table></figure><p>刚才 dev 的文件已经用了，现在就用 prod 的文件吧</p><p>先引入 merge</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br></pre></td></tr></table></figure><p>注意此处要使用解构赋值，否则引入后还要取模块的 merge 字段才行</p><p>然后连接 base 和新的配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = merge(base, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [&#123;</span><br><span class="line">        loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">"sass-loader"</span> <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>ok！最终效果和使用 spread 语法手动展开是一样的</p><p>merge 这个方法起如下的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    a: [<span class="number">11</span>],</span><br><span class="line">    b: <span class="number">45</span>,</span><br><span class="line">    c: <span class="number">1919</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    a: [<span class="number">514</span>],</span><br><span class="line">    b: <span class="number">114514</span>,</span><br><span class="line">    d: <span class="number">810</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = merge(a,b)</span><br></pre></td></tr></table></figure><p>最终 result 结果如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result === &#123;</span><br><span class="line">    a: [<span class="number">114</span>,<span class="number">514</span>],</span><br><span class="line">    b: <span class="number">114514</span>,</span><br><span class="line">    c: <span class="number">1919</span>,</span><br><span class="line">    d: <span class="number">810</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组取合并，相同取新值，不同均保留</p><p>就是这样~~</p><h1 id="感言"><a href="#感言" class="headerlink" title="感言"></a>感言</h1><p>Webpack 入门系列就到这里了，有兴趣深入的同学，可以查看 webpack 官方文档以及各个插件的官方文档</p><p>学好这几章提及的 webpack 基本原理，对于深入理解 vue 和 react 框架的打包机制是很有必要的（正是基于 webpack）</p><p>勘误可以联系我，谢谢！</p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天天 file 协议，我受够了，来个 server！Webpack 其之四&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 入门 3</title>
    <link href="http://yoursite.com/frontend/webpack-3/"/>
    <id>http://yoursite.com/frontend/webpack-3/</id>
    <published>2020-12-18T14:54:00.000Z</published>
    <updated>2020-12-20T15:50:11.893Z</updated>
    
    <content type="html"><![CDATA[<p>现代互联网，资源摩多摩多！Webpack 其之三</p><a id="more"></a><hr><h1 id="扩展CSS-loader"><a href="#扩展CSS-loader" class="headerlink" title="扩展CSS loader"></a>扩展CSS loader</h1><p>既然已经加载了 CSS，就拿 CSS 的三个变种试试手吧</p><p>以下三个变种，都支持默认的 CSS 语法，也就是说直接拿一个 CSS 去改名，就是合法的三种文件</p><h2 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h2><p>在官方文档的 loader 中找到 sass-loader 章节</p><p>文档要求我们安装，那就先安装一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sass-loader dart-sass webpack --save-dev</span><br></pre></td></tr></table></figure><p>注意，文档要求我们安装的是 node-sass，但是这个已经过时了，应该安装更新的 dart-sass</p><p>安装完成后，照抄一下示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"sass-loader"</span> <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合我们在加载 CSS 时候的经验，可以看出 test 是检验文件后缀是否是 .scss</p><p>然后按顺序从后向前调用 loader</p><h2 id="less-和-stylus"><a href="#less-和-stylus" class="headerlink" title="less 和 stylus"></a>less 和 stylus</h2><p>一模一样.jpg</p><p>先安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev less-loader less</span><br><span class="line">npm install --save-dev stylus-loader stylus</span><br></pre></td></tr></table></figure><p>然后引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"less-loader"</span> <span class="comment">// 将 Less 编译成 CSS</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"stylus-loader"</span> <span class="comment">// 将 Stylus 编译成 CSS</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完事了，是不是特别简单？</p><h1 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h1><p>显然图片也是重要的一环</p><p>从上面的 loader 示例中，可以发现 loader 的格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[&#123;</span><br><span class="line">        test: [regex], <span class="comment">// 通过正则表达式识别后缀</span></span><br><span class="line">        use: [&#123;</span><br><span class="line">            loader: <span class="string">"xxx-loader"</span> <span class="comment">// 对应的 loader</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 js 文件中 import 即可引入</p><p>那我们可以试着编写一下图片的 loader 格式</p><p>假设有一张 image.png，我们可以推测 loader 是这样的配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[&#123;</span><br><span class="line">        test: <span class="regexp">/\.png$/</span>, <span class="comment">// 通过正则表达式识别后缀</span></span><br><span class="line">        use: [&#123;</span><br><span class="line">            loader: <span class="string">"image-loader"</span> <span class="comment">// 对应的 loader</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 image-loader 看起来很合理，但是告诉你个坏消息：没有这个 loader</p><p>那怎么办呢？用 file-loader 就可以了</p><p>所以 loader 配置就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[&#123;</span><br><span class="line">        test: <span class="regexp">/\.png$/</span>, <span class="comment">// 通过正则表达式识别后缀</span></span><br><span class="line">        use: [&#123;</span><br><span class="line">            loader: <span class="string">"file-loader"</span> <span class="comment">// 对应的 loader</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在要怎么插入到页面呢？</p><p>首先要知道这时候你在 js 中引入的话，获得了什么呢？是二进制码还是？</p><p>答案是这个图片的一个相对路径</p><p>然后通过 img 标签的 src 进行插入即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> url <span class="keyword">from</span> <span class="string">'./image.png'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">img.src = url</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img)</span><br></pre></td></tr></table></figure><p>其余图片也可以使用类似的方法</p><p>什么？你说还有其它文件怎么办？看文档啊（</p><h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><p>有时候并不想图片什么的一上来就加载，可不可以控制呢？</p><p>答案是可以</p><p>我们注意到，loader 处理后的文件，必须在 import 处理后才可以正常使用，那我们动态延后 import 不就可以了？</p><p>容易想到通过一个 button 之类的元素，来触发某个事件，然后异步加载</p><p>用什么可以异步加载呢？可以使用 js 的 import() 方法来动态加载一个模块，这个方法返回一个 Promise，其成功回调返回一个模块，需要通过 module.default 才能取得其默认值</p><p>那么假设在页面上有一个 button#btn，容易得到以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">'./image.png'</span>).then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="built_in">module</span>.default</span><br><span class="line">        <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">        img.src = url</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(img)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就可以实现页面上图片的懒加载</p><h1 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h1><p>file 协议也太野蛮了，我要 http 协议</p><p><a href="https://ringoer.com/frontend/webpack-4/" target="_blank" rel="noopener">点我查看下集</a></p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代互联网，资源摩多摩多！Webpack 其之三&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 入门 2</title>
    <link href="http://yoursite.com/frontend/webpack-2/"/>
    <id>http://yoursite.com/frontend/webpack-2/</id>
    <published>2020-12-18T14:53:00.000Z</published>
    <updated>2020-12-20T13:56:17.320Z</updated>
    
    <content type="html"><![CDATA[<p>也不能总是只搞 js 吧，我三剑客另两位呢？Webpack 其之二</p><a id="more"></a><hr><p><a href="https://download.ringoer.com/webpack-demo-2.rar" target="_blank" rel="noopener">点我下载本章代码</a></p><h1 id="HTML-插件"><a href="#HTML-插件" class="headerlink" title="HTML 插件"></a>HTML 插件</h1><p>首先先搞一个能看的页面出来</p><p>那当然是选择我们的 HTML</p><p>因为 webpack 只能把资源处理成 js，所以要想得到 HTML，我们就要使用 plugin</p><p>在官方文档的 plugin 中找到 html，发现有这么一个插件</p><p><strong>html-webpack-plugin</strong></p><p>点开之后可以得到其引导，让我们先安装它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure><p>该插件将为你生成一个 HTML5 文件， 其中包括使用 <code>script</code> 标签的 body 中的所有 webpack 包。</p><p>向 module.exports 写入字段 plugins，大致变为如下模样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> HtmlWebpackPlugin()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后试试构建！</p><p>可以发现 dist 目录下产生了新的 js 和一个 html，并为这个 html 自动绑定了 js</p><p><img src="https://pic.ringoer.com/webpack-2-0.png" alt=""></p><p>但是这个页面也太白板了，能不能指定一些个性化设置呢</p><p>查看 <a href="https://github.com/jantimon/html-webpack-plugin#configuration" target="_blank" rel="noopener">插件文档</a> 可以发现有这么一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: <span class="string">'My App'</span>,</span><br><span class="line">        filename: <span class="string">'assets/admin.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>抄进来试试构建！</p><p>发现 dist 目标文件夹变成了这样</p><p><img src="https://pic.ringoer.com/webpack-2-1.png" alt=""></p><p>可以看到 title 被我们成功定制了，但是路径错了？！为什么多了一个 assets？？</p><p>我们发现配置中有 assets 的部分是 filename 字段，想到之前配置中的 output 也有 filename 字段，是指示输出的文件名用的，所以结合构建结果来看插件中的配置应该也同理</p><p>但是这样还是太单薄了，能不能再丰富一点？</p><h1 id="HTML-模板"><a href="#HTML-模板" class="headerlink" title="HTML 模板"></a>HTML 模板</h1><p>答案是可以！</p><p>继续查看插件文档，有一个地方的代码引起了我们的注意</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(), <span class="comment">// Generates default index.html</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;  <span class="comment">// Also generate a test.html</span></span><br><span class="line">        filename: <span class="string">'test.html'</span>,</span><br><span class="line">        template: <span class="string">'src/assets/test.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>注释是说，如果配置了两个 HtmlWebpackPlugin 实例，那么两个实例都会被构建</p><p>其中第二个实例指定了一个新字段，template，翻译是模板，那我们可以猜测这个东西是指示入口 html 文件的</p><p>正好我们目录下有个 index.html，个性化一下先</p><p><img src="https://pic.ringoer.com/webpack-2-2.png" alt=""></p><p>然后指定 template 的路径到这个 html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: <span class="string">'My App'</span>,</span><br><span class="line">        filename: <span class="string">'index.html'</span>,</span><br><span class="line">        template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后再构建一下，发现 dist 结果现在变成了这样</p><p><img src="https://pic.ringoer.com/webpack-2-3.png" alt=""></p><p>虽然构建成功了，自动使用我们提供的模板，并引入了 main.js</p><p>但是我们配置的 title 没有覆盖模板的 title，并且里面自带的 index.js 还留着</p><p>可以猜测配置多余的 title 是没用的，并且不应该自带 js</p><p>现在去掉模板里的 title 和 js 引用再试试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>构建！</p><p>得到的新 dist 变成这样</p><p><img src="https://pic.ringoer.com/webpack-2-4.png" alt=""></p><p>虽然 js 确实自动插进去了，但是……我的 title 呢！！！</p><p>怎么办怎么办，看看插件文档吧</p><p>正好下一节就提出了一个类似 jsp 的语法</p><p><code>&lt;%= htmlWebpackPlugin.options.title %&gt;</code></p><p>将这个语句写在模板中，可以在构建的时候自动获取配置中的 title</p><p>来试试</p><p><img src="https://pic.ringoer.com/webpack-2-5.png" alt=""></p><p>构建！</p><p><img src="https://pic.ringoer.com/webpack-2-6.png" alt=""></p><p>发现成功插入了新的 title！可以推知其它配置也可以采用类似的方法</p><h1 id="css-loader"><a href="#css-loader" class="headerlink" title="css loader"></a>css loader</h1><p>但是这样的页面好丑……我要加 CSS</p><p>看看插件文档怎么说的</p><p>直接在插件文档中搜 css</p><p>发现官方文档里这么说</p><blockquote><p>If you have any CSS assets in webpack’s output (for example, CSS extracted with the <a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="noopener">mini-css-extract-plugin</a>) then these will be included with <code>&lt;link&gt;</code> tags in the HTML head.</p></blockquote><p>意思就是如果要 CSS，你去用 mini-css-extract-plugin 吧</p><p>这也太麻烦了，我想简单点，回头看看 webpack 文档</p><p>在指南中的 加载 CSS 章节发现了这么一段</p><p><img src="https://pic.ringoer.com/webpack-2-7.png" alt=""></p><p>先安装，然后把配置抄过来看看</p><p>然后加个 style.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ol</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 index.js 中引入这个 css</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![webpack<span class="number">-2</span><span class="number">-8</span>](https:<span class="comment">//pic.ringoer.com/webpack-2-8.png)import './style.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(string)</span><br></pre></td></tr></table></figure><p>试试构建，完成后用 file 协议打开 index.html 看看</p><p><img src="https://pic.ringoer.com/webpack-2-8.png" alt=""></p><p>发现成功引入了 css，而且自动化作 style 标签插在了 document.head 中</p><p>此时的 main.xxx.js 变成了复杂的一大串 js 代码，这其实就是 loader 的效果——将其它内容转换为 js</p><p>查看配置，发现用到了两个 loader，根据名称，我们可以推测，任何以 .css 结尾的文件，都会通过 test 的测试，然后从后向前依次调用 loader处理</p><p>先调用 css-loader 将 css 内容转化为 webpack 能理解的 js 内容，再调用 style-loader 将 js 内容中的样式部分化作 style 标签插入到 document.head 上</p><p>那如果我有多个 css 呢？试试看！</p><p>新建一个 style2.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ol</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 index.js 中引入它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style2.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(string)</span><br></pre></td></tr></table></figure><p>然后构建！刷新页面发现变成了这样</p><p><img src="https://pic.ringoer.com/webpack-2-9.png" alt=""></p><p>多个 css 文件会化作多个 style 标签被插入</p><h1 id="css-抽取"><a href="#css-抽取" class="headerlink" title="css 抽取"></a>css 抽取</h1><p>但是如果我 css 多了，插作 style 标签的话，不方便管理，也会加大页面代码冗余</p><p>能不能抽成 css 文件呢？可以！</p><p>我们知道 webpack 基本功能是提取内容变为 js，刚才的 loader 也是这个功能，那现在要提取作非 js 的 css 文件了，肯定需要的是 plugin</p><p>想起刚才 html 的时候，他让我们去用 mini-css-extract-plugin，那我们就去看看</p><p>先安装这个插件</p><p><code>npm install --save-dev mini-css-extract-plugin</code></p><p>然后我们发现了这么一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> MiniCssExtractPlugin()],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>抄下来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'My App'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin()</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后好像没说什么别的了，试试构建吧</p><p><img src="https://pic.ringoer.com/webpack-2-10.png" alt=""></p><p>构建之后发现！！js 文件变简单了，css 也自动抽成了 main.css，还自动在 index.html 中引入了</p><p>不过为什么仅仅是 main.css？我的哈希呢？</p><p>根据之前猜测的 filename 指示输出文件名，来试试修改配置</p><p>将 plugins 中的 filename 改成如下模样，再试试构建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: <span class="string">'[name].[contenthash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>得到了如下结果</p><p><img src="https://pic.ringoer.com/webpack-2-11.png" alt=""></p><p>现在我们的 CSS 也有每次不同的文件名了！并且也不再依赖于 js 的引入</p><h1 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h1><p>更多其它的内容怎么办呢？只有三剑客可不足以撑起现代互联网！</p><p><a href="https://ringoer.com/frontend/webpack-3/" target="_blank" rel="noopener">点我查看下集</a></p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也不能总是只搞 js 吧，我三剑客另两位呢？Webpack 其之二&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 入门 1</title>
    <link href="http://yoursite.com/frontend/webpack-1/"/>
    <id>http://yoursite.com/frontend/webpack-1/</id>
    <published>2020-12-18T14:51:00.000Z</published>
    <updated>2020-12-20T13:00:32.339Z</updated>
    
    <content type="html"><![CDATA[<p>目前版本第一的打包工具 Webpack 其之一</p><a id="more"></a><hr><p><a href="https://download.ringoer.com/webpack-demo-1.rar" target="_blank" rel="noopener">点我下载本章代码</a></p><h1 id="什么是-Webpack"><a href="#什么是-Webpack" class="headerlink" title="什么是 Webpack"></a>什么是 Webpack</h1><p>首先贴出 webpack 的官网</p><p><a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a></p><p><a href="https://www.webpackjs.com/" target="_blank" rel="noopener">webpack 中文文档</a></p><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。构建过程是拓扑排序的一种</p><p>说到底，webpack 基本的功能，其实就是把高版本 js 转换成 js，以及把非 js 的文件转换成 js</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>先安装一下吧</p><p>我们可以看到，官方文档的指南里给出了如下命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack-demo &amp;&amp; <span class="built_in">cd</span> webpack-demo</span><br><span class="line">npm init -y</span><br><span class="line">npm install webpack webpack-cli --save-dev</span><br></pre></td></tr></table></figure><p>那我们也照做一下，完成后目录结构如下</p><p><img src="https://pic.ringoer.com/webpack-1-0.png" alt=""></p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>指南里还要求我们首先建一个新目录，里面包含一个 src 的一个 index.js，以及一下 index.html</p><p>index.html 中记得连接到 index.js</p><p><img src="https://pic.ringoer.com/webpack-1-1.png" alt=""></p><p>然后让我们试试高版本 js 转换成低版本 js 的功能。一般是 ES6 转换成 ES5</p><p>让我们先从文档里找一个能用的 webpack 配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就他了！</p><p>建立一个 webpack.config.js 文件用来保存配置</p><p><img src="https://pic.ringoer.com/webpack-1-2.png" alt=""></p><p>然后试试运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>npx 命令指示 node 从当前目录下的 node_modules 中寻找webpack</p><p>然后发现报错了？！怎么回事呢</p><p>看看报错说什么</p><p><img src="https://pic.ringoer.com/webpack-1-3.png" alt=""></p><p>报错说他不能识别 <code>./path/to/my/entry/file.js</code> 这个文件是什么</p><p>这个字符串在哪里提到了呢？在配置中的 entry</p><p>entry 这个词很明显是入口的意思，加上是 js 结尾，我们试试看用我们现在目录中唯一的 js 替换</p><p><img src="https://pic.ringoer.com/webpack-1-4.png" alt=""></p><p>现在配置变成这样，再试试打包吧！</p><p>这次很顺利的成功了</p><p><img src="https://pic.ringoer.com/webpack-1-5.png" alt=""></p><p>检查目录，发现目录下多了个 dist 文件夹，里面多了个 my-first-webpack.bundle.js 文件</p><p><img src="https://pic.ringoer.com/webpack-1-6.png" alt=""></p><p>打开内容一看，就是和我们的 index.js 里面是一样的内容！甚至还自己分析了语义，省去了不必要的代码</p><p>这就是 webpack 的基本功能 js 转换</p><h1 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h1><p>entry 除了上文提到的单入口指定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以指定多个入口，传入一个 hashtable 即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">      app: <span class="string">'./src/index.js'</span>,</span><br><span class="line">      print: <span class="string">'./src/print.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>传入的入口 js 会分别打包，有兴趣的朋友可以自己尝试一下</p><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>显然代码一般都有开发和部署两种状态，webpack 也有不同的对应代码</p><p>在配置中可以添加 mode 字段来指示 webpack 模式，有两种选择</p><ol><li>production，部署模式，默认</li><li>development，开发模式</li></ol><p>具体来说，打包出来的东西会有区别，比如刚才的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(string)</span><br></pre></td></tr></table></figure><p>在部署模式会被打包成上图样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><p>在开发模式会打包成如下样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").</span></span><br><span class="line"><span class="comment"> * This devtool is not neither made for production nor for readable output files.</span></span><br><span class="line"><span class="comment"> * It uses "eval()" calls to create a separate source file in the browser devtools.</span></span><br><span class="line"><span class="comment"> * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)</span></span><br><span class="line"><span class="comment"> * or disable the default devtool with "devtool: false".</span></span><br><span class="line"><span class="comment"> * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/******/</span> (<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/index.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"let string = 'hello'\r\nconsole.log(string)\n\n//# sourceURL=webpack://webpack-demo/./src/index.js?"</span>);</span><br><span class="line"><span class="comment">/******/</span> &#125;)()</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>多了很多不必要的代码，为了方便程序员查看</p><h1 id="输出哈希"><a href="#输出哈希" class="headerlink" title="输出哈希"></a>输出哈希</h1><p>从配置信息中可以看出，配置里不仅指示了入口文件，还指示了 output——输出文件的配置</p><p>上述配置中令输出文件夹命名为 dist，这也是大部分构建工具的配置</p><p>还指示了 filename，可以猜出是输出的 js 文件的文件名</p><p>在刚才尝试不同模式的构建中，我们已经发现不同的构建会覆盖旧有的文件，但输出文件名仍然是同一个</p><p>根据以前学习的浏览器缓存知识可以了解到，浏览器发现你在 html 文件中的连接 js 名称没变，那就会认为现在的页面还是使用原有的缓存，显然不利于页面的更新</p><p>于是我们要为新构建的 js 指定一个每次都不一样的名称</p><p>但是总不能手动配置吧？那也太烦了</p><p>还好 webpack 提供了 filename 模板</p><p>可以通过 <code>[name].[contenthash].js</code> 来指定随机的新 filename，其中的 contenthash 是依据文件内容进行哈希，也就是说只要文件内容有变化，新打包出来的文件一定不同名</p><p>让我们试试吧</p><p><img src="https://pic.ringoer.com/webpack-1-7.png" alt=""></p><p>更换了新配置之后发现生成了一个 main.xxxxx.js 文件！成功了！</p><h1 id="快捷构建"><a href="#快捷构建" class="headerlink" title="快捷构建"></a>快捷构建</h1><p>每次构建都产生一个不同名文件，虽然有利于浏览器更新，但是不利于本地……毕竟总不能每次都手动删除一下 dist 吧2333</p><p>这时候我们可以考虑修改 node 默认的配置</p><p>可以向 package.json 文件中的 scripts 字段加入如下内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与命令行不同，写在此处的命令可以不加 npx，默认是在本目录下查找</p><p>接下来我们运行 <code>npm run build</code> 就等同于运行 <code>npx webpack</code></p><p><img src="https://pic.ringoer.com/webpack-1-8.png" alt=""></p><p>于是我们就可以把 rm 语句也加进去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"rm -rf ./dist &amp;&amp; webpack"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;&amp; 表示前项执行成功才执行后项</p><p>现在就可以在运行 <code>npm run build</code> 的时候同时删除旧文件了</p><p>注：有的不能用 rm 命令的时候，可以用 rimraf 命令代替</p><h1 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h1><p>只有 js 怎么够？！我要完整的三剑客！</p><p><a href="https://ringoer.com/frontend/webpack-2/" target="_blank" rel="noopener">点我查看下集</a></p><hr><p>感谢阅读</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前版本第一的打包工具 Webpack 其之一&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://yoursite.com/categories/frontend/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
</feed>
